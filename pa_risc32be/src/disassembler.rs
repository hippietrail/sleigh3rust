use sleigh4rust::*;
pub type AddrType = u32;
pub trait GlobalSetTrait {
    fn set_phase(&mut self, address: Option<u32>, value: i128);
    fn set_temp1(&mut self, address: Option<u32>, value: i128);
    fn set_nullifyEnable(&mut self, address: Option<u32>, value: i128);
    fn set_branchCouldBeNullified(&mut self, address: Option<u32>, value: i128);
    fn set_branchEnable(&mut self, address: Option<u32>, value: i128);
    fn set_branchType(&mut self, address: Option<u32>, value: i128);
    fn set_branchIsReturn(&mut self, address: Option<u32>, value: i128);
    fn set_padding(&mut self, address: Option<u32>, value: i128);
    fn set_branchImmDest(&mut self, address: Option<u32>, value: i128);
    fn set_temp32(&mut self, address: Option<u32>, value: i128);
}
#[derive(Default)]
pub struct GlobalSetDefault<C: ContextTrait>(
    pub std::collections::HashMap<AddrType, C>,
);
impl<C: ContextTrait> GlobalSetTrait for GlobalSetDefault<C> {
    fn set_phase(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_phase_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_temp1(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_temp1_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_nullifyEnable(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_nullifyEnable_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_branchCouldBeNullified(
        &mut self,
        inst_start: Option<AddrType>,
        value: i128,
    ) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_branchCouldBeNullified_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_branchEnable(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_branchEnable_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_branchType(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_branchType_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_branchIsReturn(
        &mut self,
        inst_start: Option<AddrType>,
        value: i128,
    ) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_branchIsReturn_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_padding(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_padding_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_branchImmDest(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_branchImmDest_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_temp32(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_temp32_disassembly(value)
                .unwrap();
            context
        });
    }
}
pub trait ContextregisterTrait:
    MemoryRead<AddressType = u32> + MemoryWrite
{
    fn read_phase_raw(&self) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<true>(11, 0, 3)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_phase_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<true>(u8::from(param), 11, 0, 3)
    }
    fn read_phase_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_phase_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_phase_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_phase_raw(param as u8)
    }
    fn read_phase_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_phase_raw()
    }
    fn write_phase_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_phase_raw(param)
    }
    fn phase_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_phase_raw()?))
    }
    fn read_temp1_raw(&self) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<true>(11, 3, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_temp1_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<true>(u8::from(param), 11, 3, 1)
    }
    fn read_temp1_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_temp1_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_temp1_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_temp1_raw(param as u8)
    }
    fn read_temp1_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_temp1_raw()
    }
    fn write_temp1_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_temp1_raw(param)
    }
    fn temp1_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_temp1_raw()?))
    }
    fn read_nullifyEnable_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<true>(11, 4, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_nullifyEnable_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<true>(u8::from(param), 11, 4, 1)
    }
    fn read_nullifyEnable_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_nullifyEnable_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_nullifyEnable_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_nullifyEnable_raw(param as u8)
    }
    fn read_nullifyEnable_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_nullifyEnable_raw()
    }
    fn write_nullifyEnable_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_nullifyEnable_raw(param)
    }
    fn nullifyEnable_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_nullifyEnable_raw()?))
    }
    fn read_branchCouldBeNullified_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<true>(11, 5, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_branchCouldBeNullified_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<true>(u8::from(param), 11, 5, 1)
    }
    fn read_branchCouldBeNullified_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_branchCouldBeNullified_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_branchCouldBeNullified_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_branchCouldBeNullified_raw(param as u8)
    }
    fn read_branchCouldBeNullified_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_branchCouldBeNullified_raw()
    }
    fn write_branchCouldBeNullified_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_branchCouldBeNullified_raw(param)
    }
    fn branchCouldBeNullified_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(
            true,
            self.read_branchCouldBeNullified_raw()?,
        ))
    }
    fn read_branchEnable_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<true>(11, 6, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_branchEnable_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<true>(u8::from(param), 11, 6, 1)
    }
    fn read_branchEnable_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_branchEnable_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_branchEnable_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_branchEnable_raw(param as u8)
    }
    fn read_branchEnable_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_branchEnable_raw()
    }
    fn write_branchEnable_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_branchEnable_raw(param)
    }
    fn branchEnable_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_branchEnable_raw()?))
    }
    fn read_branchType_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u16::<true>(10, 7, 3)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_branchType_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u16::<true>(u16::from(param), 10, 7, 3)
    }
    fn read_branchType_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_branchType_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_branchType_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_branchType_raw(param as u8)
    }
    fn read_branchType_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_branchType_raw()
    }
    fn write_branchType_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_branchType_raw(param)
    }
    fn branchType_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_branchType_raw()?))
    }
    fn read_branchIsReturn_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<true>(10, 2, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_branchIsReturn_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<true>(u8::from(param), 10, 2, 1)
    }
    fn read_branchIsReturn_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_branchIsReturn_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_branchIsReturn_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_branchIsReturn_raw(param as u8)
    }
    fn read_branchIsReturn_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_branchIsReturn_raw()
    }
    fn write_branchIsReturn_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_branchIsReturn_raw(param)
    }
    fn branchIsReturn_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_branchIsReturn_raw()?))
    }
    fn read_padding_raw(
        &self,
    ) -> Result<u32, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u32::<true>(8, 2, 22)?;
        Ok(u32::try_from(work_value).unwrap())
    }
    fn write_padding_raw(
        &mut self,
        param: u32,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u32::<true>(u32::from(param), 8, 2, 22)
    }
    fn read_padding_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_padding_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_padding_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_padding_raw(param as u32)
    }
    fn read_padding_execution(
        &self,
    ) -> Result<u32, MemoryReadError<Self::AddressType>> {
        self.read_padding_raw()
    }
    fn write_padding_execution(
        &mut self,
        param: u32,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_padding_raw(param)
    }
    fn padding_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_padding_raw()?))
    }
    fn read_branchImmDest_raw(
        &self,
    ) -> Result<u32, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u32::<true>(4, 0, 32)?;
        Ok(u32::try_from(work_value).unwrap())
    }
    fn write_branchImmDest_raw(
        &mut self,
        param: u32,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u32::<true>(u32::from(param), 4, 0, 32)
    }
    fn read_branchImmDest_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_branchImmDest_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_branchImmDest_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_branchImmDest_raw(param as u32)
    }
    fn read_branchImmDest_execution(
        &self,
    ) -> Result<u32, MemoryReadError<Self::AddressType>> {
        self.read_branchImmDest_raw()
    }
    fn write_branchImmDest_execution(
        &mut self,
        param: u32,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_branchImmDest_raw(param)
    }
    fn branchImmDest_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_branchImmDest_raw()?))
    }
    fn read_temp32_raw(
        &self,
    ) -> Result<u32, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u32::<true>(0, 0, 32)?;
        Ok(u32::try_from(work_value).unwrap())
    }
    fn write_temp32_raw(
        &mut self,
        param: u32,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u32::<true>(u32::from(param), 0, 0, 32)
    }
    fn read_temp32_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_temp32_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_temp32_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_temp32_raw(param as u32)
    }
    fn read_temp32_execution(
        &self,
    ) -> Result<u32, MemoryReadError<Self::AddressType>> {
        self.read_temp32_raw()
    }
    fn write_temp32_execution(
        &mut self,
        param: u32,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_temp32_raw(param)
    }
    fn temp32_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_temp32_raw()?))
    }
}
pub trait ContextTrait: Default {
    type Typeregister: ContextregisterTrait;
    fn register(&self) -> &Self::Typeregister;
    fn register_mut(&mut self) -> &mut Self::Typeregister;
}
#[derive(Debug, Clone, Copy)]
pub struct ContextregisterStructDebug {
    pub chunk_0x0: [Option<bool>; 96],
}
impl Default for ContextregisterStructDebug {
    fn default() -> Self {
        Self {
            chunk_0x0: [None; 96],
        }
    }
}
impl ContextregisterStructDebug {
    fn read_bits(
        &self,
        addr: <Self as MemoryRead>::AddressType,
        buf: &mut [u8],
        mask: &[u8],
    ) -> Result<(), MemoryReadError<<Self as MemoryRead>::AddressType>> {
        assert_eq!(buf.len(), mask.len());
        let buf_len =
            <<Self as MemoryRead>::AddressType>::try_from(buf.len()).unwrap();
        let addr_end = addr + ((buf_len + 7) / 8);
        match (addr, addr_end) {
            (0..=11, 0..=12) => {
                let byte_offset = usize::try_from(addr - 0).unwrap();
                for ((buf_byte, mask_byte), byte) in
                    buf.iter_mut().zip(mask.iter()).zip(byte_offset..)
                {
                    for bit in (0..8)
                        .into_iter()
                        .filter(|bit| ((*mask_byte >> bit) & 1) != 0)
                    {
                        *buf_byte |= (self.chunk_0x0[(byte * 8) + bit].unwrap()
                            as u8)
                            << bit;
                    }
                }
            }
            (addr_start, addr_end) => {
                return Err(MemoryReadError::UnableToReadMemory(
                    addr_start, addr_end,
                ))
            }
        }
        Ok(())
    }
    fn write_bits(
        &mut self,
        addr: <Self as MemoryRead>::AddressType,
        buf: &[u8],
        mask: &[u8],
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        assert_eq!(buf.len(), mask.len());
        let buf_len =
            <<Self as MemoryRead>::AddressType>::try_from(buf.len()).unwrap();
        let addr_end = addr + ((buf_len + 7) / 8);
        match (addr, addr_end) {
            (0..=11, 0..=12) => {
                let byte_offset = usize::try_from(addr - 0).unwrap();
                for ((buf_byte, mask_byte), byte) in
                    buf.iter().zip(mask.iter()).zip(byte_offset..)
                {
                    for bit in (0..8)
                        .into_iter()
                        .filter(|bit| ((*mask_byte >> bit) & 1) != 0)
                    {
                        self.chunk_0x0[(byte * 8) + bit] =
                            Some(*buf_byte & (1 << bit) != 0);
                    }
                }
            }
            (addr_start, addr_end) => {
                return Err(MemoryWriteError::UnableToWriteMemory(
                    addr_start, addr_end,
                ))
            }
        }
        Ok(())
    }
}
impl ContextregisterTrait for ContextregisterStructDebug {}
impl MemoryRead for ContextregisterStructDebug {
    type AddressType = u32;
    fn read(
        &self,
        addr: <Self as MemoryRead>::AddressType,
        buf: &mut [u8],
    ) -> Result<(), MemoryReadError<<Self as MemoryRead>::AddressType>> {
        let mut inner_buf = vec![0xFF; buf.len()];
        self.read_bits(addr, buf, &mut inner_buf)
    }
    fn read_u8<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u8, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u8>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u8>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u8>::from_be_bytes(data)
        } else {
            <u8>::from_le_bytes(data)
        };
        let value_mask = <u8>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
    fn read_u16<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u16, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u16>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u16>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u16>::from_be_bytes(data)
        } else {
            <u16>::from_le_bytes(data)
        };
        let value_mask = <u16>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
    fn read_u32<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u32, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u32>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u32>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u32>::from_be_bytes(data)
        } else {
            <u32>::from_le_bytes(data)
        };
        let value_mask = <u32>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
    fn read_u64<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u64, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u64>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u64>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u64>::from_be_bytes(data)
        } else {
            <u64>::from_le_bytes(data)
        };
        let value_mask = <u64>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
    fn read_u128<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u128, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u128>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u128>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u128>::from_be_bytes(data)
        } else {
            <u128>::from_le_bytes(data)
        };
        let value_mask = <u128>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
}
impl MemoryWrite for ContextregisterStructDebug {
    fn write(
        &mut self,
        addr: <Self as MemoryRead>::AddressType,
        buf: &[u8],
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        let mut inner_buf = vec![0xFF; buf.len()];
        self.write_bits(addr, buf, &inner_buf)
    }
    fn write_u8<const BIG_ENDIAN: bool>(
        &mut self,
        value: u8,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u8>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u8>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
    fn write_u16<const BIG_ENDIAN: bool>(
        &mut self,
        value: u16,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u16>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u16>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
    fn write_u32<const BIG_ENDIAN: bool>(
        &mut self,
        value: u32,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u32>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u32>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
    fn write_u64<const BIG_ENDIAN: bool>(
        &mut self,
        value: u64,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u64>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u64>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
    fn write_u128<const BIG_ENDIAN: bool>(
        &mut self,
        value: u128,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u128>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u128>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
}
#[derive(Debug, Clone, Copy, Default)]
pub struct SpacesStruct {
    pub register: ContextregisterStructDebug,
}
impl ContextTrait for SpacesStruct {
    type Typeregister = ContextregisterStructDebug;
    fn register(&self) -> &Self::Typeregister {
        &self.register
    }
    fn register_mut(&mut self) -> &mut Self::Typeregister {
        &mut self.register
    }
}
fn meaning_number<T>(hex: bool, num: T) -> DisplayElement
where
    i128: TryFrom<T>,
    <i128 as TryFrom<T>>::Error: core::fmt::Debug,
{
    DisplayElement::Number(hex, i128::try_from(num).unwrap())
}
fn meaning_0_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_0_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_0_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::cr0,
        1 => Register::cr1,
        2 => Register::cr2,
        3 => Register::cr3,
        4 => Register::cr4,
        5 => Register::cr5,
        6 => Register::cr6,
        7 => Register::cr7,
        8 => Register::cr8,
        9 => Register::cr9,
        10 => Register::cr10,
        11 => Register::sar,
        12 => Register::cr12,
        13 => Register::cr13,
        14 => Register::cr14,
        15 => Register::cr15,
        16 => Register::cr16,
        17 => Register::cr17,
        18 => Register::cr18,
        19 => Register::cr19,
        20 => Register::cr20,
        21 => Register::cr21,
        22 => Register::cr22,
        23 => Register::cr23,
        24 => Register::cr24,
        25 => Register::cr25,
        26 => Register::cr26,
        27 => Register::cr27,
        28 => Register::cr28,
        29 => Register::cr29,
        30 => Register::cr30,
        31 => Register::cr31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_2_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_2_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_2_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::fr0,
        1 => Register::fpe23,
        2 => Register::fpe45,
        3 => Register::fpe67,
        4 => Register::fr4,
        5 => Register::fr5,
        6 => Register::fr6,
        7 => Register::fr7,
        8 => Register::fr8,
        9 => Register::fr9,
        10 => Register::fr10,
        11 => Register::fr11,
        12 => Register::fr12,
        13 => Register::fr13,
        14 => Register::fr14,
        15 => Register::fr15,
        16 => Register::fr16,
        17 => Register::fr17,
        18 => Register::fr18,
        19 => Register::fr19,
        20 => Register::fr20,
        21 => Register::fr21,
        22 => Register::fr22,
        23 => Register::fr23,
        24 => Register::fr24,
        25 => Register::fr25,
        26 => Register::fr26,
        27 => Register::fr27,
        28 => Register::fr28,
        29 => Register::fr29,
        30 => Register::fr30,
        31 => Register::fr31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_3_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_3_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_3_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::fr0L,
        1 => Register::fpe2,
        2 => Register::fpe4,
        3 => Register::fpe6,
        4 => Register::fr4L,
        5 => Register::fr5L,
        6 => Register::fr6L,
        7 => Register::fr7L,
        8 => Register::fr8L,
        9 => Register::fr9L,
        10 => Register::fr10L,
        11 => Register::fr11L,
        12 => Register::fr12L,
        13 => Register::fr13L,
        14 => Register::fr14L,
        15 => Register::fr15L,
        16 => Register::fr16L,
        17 => Register::fr17L,
        18 => Register::fr18L,
        19 => Register::fr19L,
        20 => Register::fr20L,
        21 => Register::fr21L,
        22 => Register::fr22L,
        23 => Register::fr23L,
        24 => Register::fr24L,
        25 => Register::fr25L,
        26 => Register::fr26L,
        27 => Register::fr27L,
        28 => Register::fr28L,
        29 => Register::fr29L,
        30 => Register::fr30L,
        31 => Register::fr31L,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_4_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_4_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_4_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::fr16L,
        1 => Register::fr17L,
        2 => Register::fr18L,
        3 => Register::fr19L,
        4 => Register::fr20L,
        5 => Register::fr21L,
        6 => Register::fr22L,
        7 => Register::fr23L,
        8 => Register::fr24L,
        9 => Register::fr25L,
        10 => Register::fr26L,
        11 => Register::fr27L,
        12 => Register::fr28L,
        13 => Register::fr29L,
        14 => Register::fr30L,
        15 => Register::fr31L,
        16 => Register::fr16R,
        17 => Register::fr17R,
        18 => Register::fr18R,
        19 => Register::fr19R,
        20 => Register::fr20R,
        21 => Register::fr21R,
        22 => Register::fr22R,
        23 => Register::fr23R,
        24 => Register::fr24R,
        25 => Register::fr25R,
        26 => Register::fr26R,
        27 => Register::fr27R,
        28 => Register::fr28R,
        29 => Register::fr29R,
        30 => Register::fr30R,
        31 => Register::fr31R,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_5_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_5_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_5_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r0,
        1 => Register::r1,
        2 => Register::rp,
        3 => Register::r3,
        4 => Register::r4,
        5 => Register::r5,
        6 => Register::r6,
        7 => Register::r7,
        8 => Register::r8,
        9 => Register::r9,
        10 => Register::r10,
        11 => Register::r11,
        12 => Register::r12,
        13 => Register::r13,
        14 => Register::r14,
        15 => Register::r15,
        16 => Register::r16,
        17 => Register::r17,
        18 => Register::r18,
        19 => Register::r19,
        20 => Register::r20,
        21 => Register::r21,
        22 => Register::r22,
        23 => Register::r23,
        24 => Register::r24,
        25 => Register::r25,
        26 => Register::r26,
        27 => Register::dp,
        28 => Register::r28,
        29 => Register::r29,
        30 => Register::sp,
        31 => Register::r31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_1_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal("RCTR"),
        1 => DisplayElement::Literal("CR1"),
        2 => DisplayElement::Literal("CR2"),
        3 => DisplayElement::Literal("CR3"),
        4 => DisplayElement::Literal("CR4"),
        5 => DisplayElement::Literal("CR5"),
        6 => DisplayElement::Literal("CR6"),
        7 => DisplayElement::Literal("CR7"),
        8 => DisplayElement::Literal("PID1"),
        9 => DisplayElement::Literal("PID2"),
        10 => DisplayElement::Literal("CCR"),
        11 => DisplayElement::Literal("SAR"),
        12 => DisplayElement::Literal("PID3"),
        13 => DisplayElement::Literal("PID4"),
        14 => DisplayElement::Literal("IVA"),
        15 => DisplayElement::Literal("EIEM"),
        16 => DisplayElement::Literal("ITMR"),
        17 => DisplayElement::Literal("IIASQ"),
        18 => DisplayElement::Literal("IIAOQ"),
        19 => DisplayElement::Literal("IIR"),
        20 => DisplayElement::Literal("ISR"),
        21 => DisplayElement::Literal("IOR"),
        22 => DisplayElement::Literal("IPSW"),
        23 => DisplayElement::Literal("EIRR"),
        24 => DisplayElement::Literal("TMP0"),
        25 => DisplayElement::Literal("TMP1"),
        26 => DisplayElement::Literal("TMP2"),
        27 => DisplayElement::Literal("TMP3"),
        28 => DisplayElement::Literal("TMP4"),
        29 => DisplayElement::Literal("TMP5"),
        30 => DisplayElement::Literal("TMP6"),
        31 => DisplayElement::Literal("TMP7"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_6_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(""),
        1 => DisplayElement::Literal(",="),
        2 => DisplayElement::Literal(",&lt;"),
        3 => DisplayElement::Literal(",OD"),
        4 => DisplayElement::Literal(",TR"),
        5 => DisplayElement::Literal(",&lt;&gt;"),
        6 => DisplayElement::Literal(",&gt;="),
        7 => DisplayElement::Literal(",EV"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_7_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(""),
        2 => DisplayElement::Literal(",SBZ"),
        3 => DisplayElement::Literal(",SHZ"),
        4 => DisplayElement::Literal(",SDC"),
        6 => DisplayElement::Literal(",SBC"),
        7 => DisplayElement::Literal(",SHC"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_8_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(""),
        2 => DisplayElement::Literal(",NBZ"),
        3 => DisplayElement::Literal(",NHZ"),
        4 => DisplayElement::Literal(",NDC"),
        6 => DisplayElement::Literal(",NBC"),
        7 => DisplayElement::Literal(",NHC"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_9_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(""),
        1 => DisplayElement::Literal(",="),
        2 => DisplayElement::Literal(",&lt;"),
        3 => DisplayElement::Literal(",&lt;="),
        7 => DisplayElement::Literal(",OD"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_10_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(""),
        1 => DisplayElement::Literal(",&lt;&gt;"),
        2 => DisplayElement::Literal(",&gt;="),
        3 => DisplayElement::Literal(",&gt;"),
        7 => DisplayElement::Literal(",EV"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_11_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(""),
        1 => DisplayElement::Literal(",="),
        2 => DisplayElement::Literal(",&lt;"),
        3 => DisplayElement::Literal(",&lt;="),
        4 => DisplayElement::Literal(",NUV"),
        5 => DisplayElement::Literal(",ZNV"),
        6 => DisplayElement::Literal(",SV"),
        7 => DisplayElement::Literal(",OD"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_12_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(""),
        1 => DisplayElement::Literal(",&lt;&gt;"),
        2 => DisplayElement::Literal(",&gt;="),
        3 => DisplayElement::Literal(",&gt;"),
        4 => DisplayElement::Literal(",UV"),
        5 => DisplayElement::Literal(",VNZ"),
        6 => DisplayElement::Literal(",NSV"),
        7 => DisplayElement::Literal(",EV"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_13_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(""),
        1 => DisplayElement::Literal(",="),
        2 => DisplayElement::Literal(",&lt;"),
        3 => DisplayElement::Literal(",&lt;="),
        4 => DisplayElement::Literal(",&lt;&lt;"),
        5 => DisplayElement::Literal(",&lt;&lt;="),
        6 => DisplayElement::Literal(",SV"),
        7 => DisplayElement::Literal(",OD"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_14_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(""),
        1 => DisplayElement::Literal(",&lt;&gt;"),
        2 => DisplayElement::Literal(",&gt;="),
        3 => DisplayElement::Literal(",&gt;"),
        4 => DisplayElement::Literal(",&gt;&gt;="),
        5 => DisplayElement::Literal(",&gt;&gt;"),
        6 => DisplayElement::Literal(",NSV"),
        7 => DisplayElement::Literal(",EV"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_15_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(",SGL"),
        1 => DisplayElement::Literal(",DBL"),
        2 => DisplayElement::Literal(",QUAD"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_16_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(",UW"),
        1 => DisplayElement::Literal(",UD"),
        2 => DisplayElement::Literal(",UQ"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_17_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(",SGL"),
        1 => DisplayElement::Literal(",DBL"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_18_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal("none"),
        1 => DisplayElement::Literal("resv"),
        2 => DisplayElement::Literal("sl"),
        3 => DisplayElement::Literal("resv"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_19_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal("none"),
        1 => DisplayElement::Literal("BC"),
        2 => DisplayElement::Literal("SL"),
        3 => DisplayElement::Literal("resv"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_20_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal("none"),
        1 => DisplayElement::Literal("CO"),
        2 => DisplayElement::Literal("resv"),
        3 => DisplayElement::Literal("resv"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_21_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(",DBL"),
        1 => DisplayElement::Literal(",SGL"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_22_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(""),
        1 => DisplayElement::Literal("ACC"),
        2 => DisplayElement::Literal("REJ"),
        5 => DisplayElement::Literal("ACC8"),
        6 => DisplayElement::Literal("REJ8"),
        9 => DisplayElement::Literal("ACC6"),
        13 => DisplayElement::Literal("ACC4"),
        17 => DisplayElement::Literal("ACC2"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_opfam(u8);
impl TokenField_opfam {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_cr(u8);
impl TokenField_cr {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_crname2(u8);
impl TokenField_crname2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_freg2(u8);
impl TokenField_freg2 {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_freg2sgl(u8);
impl TokenField_freg2sgl {
    fn execution(&self) -> Register {
        meaning_3_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_3_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fr2half(u8);
impl TokenField_fr2half {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fusedr2(u8);
impl TokenField_fusedr2 {
    fn execution(&self) -> Register {
        meaning_4_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_4_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_reg2(u8);
impl TokenField_reg2 {
    fn execution(&self) -> Register {
        meaning_5_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_5_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_b(u8);
impl TokenField_b {
    fn execution(&self) -> Register {
        meaning_5_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_5_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bboffset(u8);
impl TokenField_bboffset {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_crname1(u8);
impl TokenField_crname1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit20(i8);
impl TokenField_bit20 {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpc1sub2(u8);
impl TokenField_fpc1sub2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_highIm10(u16);
impl TokenField_highIm10 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_reg1(u8);
impl TokenField_reg1 {
    fn execution(&self) -> Register {
        meaning_5_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_5_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fusedr1(u8);
impl TokenField_fusedr1 {
    fn execution(&self) -> Register {
        meaning_4_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_4_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_freg1(u8);
impl TokenField_freg1 {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_freg1sgl(u8);
impl TokenField_freg1sgl {
    fn execution(&self) -> Register {
        meaning_3_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_3_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fr1half(u8);
impl TokenField_fr1half {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_r(u8);
impl TokenField_r {
    fn execution(&self) -> Register {
        meaning_5_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_5_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_highIm5(i8);
impl TokenField_highIm5 {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_highIm5less16(u8);
impl TokenField_highIm5less16 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_tr(u8);
impl TokenField_tr {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_x(u8);
impl TokenField_x {
    fn execution(&self) -> Register {
        meaning_5_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_5_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_w1(u8);
impl TokenField_w1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit16(u8);
impl TokenField_bit16 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpc1sub(u8);
impl TokenField_fpc1sub {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_srbit1(u8);
impl TokenField_srbit1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_s(u8);
impl TokenField_s {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_srbit0(u8);
impl TokenField_srbit0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im13(i16);
impl TokenField_im13 {
    fn execution(&self) -> i16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_SEDCondSym(u8);
impl TokenField_SEDCondSym {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_6_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RegUnitCondSym(u8);
impl TokenField_RegUnitCondSym {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_7_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_InvUnitCondSym(u8);
impl TokenField_InvUnitCondSym {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_8_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RegLogicCondSym(u8);
impl TokenField_RegLogicCondSym {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_9_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_InvLogicCondSym(u8);
impl TokenField_InvLogicCondSym {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_10_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RegAddCondSym(u8);
impl TokenField_RegAddCondSym {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_11_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_InvAddCondSym(u8);
impl TokenField_InvAddCondSym {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_12_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RegCSCondSym(u8);
impl TokenField_RegCSCondSym {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_13_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_InvCSCondSym(u8);
impl TokenField_InvCSCondSym {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_14_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c(u8);
impl TokenField_c {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpsub(u8);
impl TokenField_fpsub {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_srbit2(u8);
impl TokenField_srbit2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpdf(u8);
impl TokenField_fpdf {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_15_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fixeddf(u8);
impl TokenField_fixeddf {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_16_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpdfraw(u8);
impl TokenField_fpdfraw {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fixedsf(u8);
impl TokenField_fixedsf {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_16_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_a(u8);
impl TokenField_a {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_u(u8);
impl TokenField_u {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpr1x(u8);
impl TokenField_fpr1x {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_f(u8);
impl TokenField_f {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fv(u8);
impl TokenField_fv {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_zero(u8);
impl TokenField_zero {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_one(u8);
impl TokenField_one {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_subop1012(u8);
impl TokenField_subop1012 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im15(u16);
impl TokenField_im15 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sopim10(i16);
impl TokenField_sopim10 {
    fn execution(&self) -> i16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sopim5(i8);
impl TokenField_sopim5 {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpta(u8);
impl TokenField_fpta {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fusedta(u8);
impl TokenField_fusedta {
    fn execution(&self) -> Register {
        meaning_4_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_4_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpsf(u8);
impl TokenField_fpsf {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_15_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpsfraw(u8);
impl TokenField_fpsfraw {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpfmt(u8);
impl TokenField_fpfmt {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_15_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpfmt1bit(u8);
impl TokenField_fpfmt1bit {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_17_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit11(u8);
impl TokenField_bit11 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_cc(u8);
impl TokenField_cc {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_ldcc(u8);
impl TokenField_ldcc {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_18_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_stcc(u8);
impl TokenField_stcc {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_19_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_ldcwcc(u8);
impl TokenField_ldcwcc {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_20_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit10(u8);
impl TokenField_bit10 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sopim17(u32);
impl TokenField_sopim17 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_pmuop(u8);
impl TokenField_pmuop {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_specop(u8);
impl TokenField_specop {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpclass(u8);
impl TokenField_fpclass {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit9(u8);
impl TokenField_bit9 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit8(u8);
impl TokenField_bit8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpx(u8);
impl TokenField_fpx {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bits78(u8);
impl TokenField_bits78 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpr2x(u8);
impl TokenField_fpr2x {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpra(u8);
impl TokenField_fpra {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fusedra(u8);
impl TokenField_fusedra {
    fn execution(&self) -> Register {
        meaning_4_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_4_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_ext4(u8);
impl TokenField_ext4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_C(u8);
impl TokenField_C {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_subop(u8);
impl TokenField_subop {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sysopshifted(u8);
impl TokenField_sysopshifted {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sysopshiftedshort(u8);
impl TokenField_sysopshiftedshort {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op(u8);
impl TokenField_op {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sfu(u8);
impl TokenField_sfu {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fp0czero(u8);
impl TokenField_fp0czero {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fptx(u8);
impl TokenField_fptx {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit6(u8);
impl TokenField_bit6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sysop(u8);
impl TokenField_sysop {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_i2(u8);
impl TokenField_i2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bits59(u8);
impl TokenField_bits59 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_cp(u8);
impl TokenField_cp {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fusedfmt(u8);
impl TokenField_fusedfmt {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_21_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit5(u8);
impl TokenField_bit5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_m(u8);
impl TokenField_m {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_spn(u8);
impl TokenField_spn {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_w2(u16);
impl TokenField_w2 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_w2_2(u8);
impl TokenField_w2_2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_w2less2(u16);
impl TokenField_w2less2 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_n(u8);
impl TokenField_n {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im26(i32);
impl TokenField_im26 {
    fn execution(&self) -> i32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sim21(i32);
impl TokenField_sim21 {
    fn execution(&self) -> i32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sim14(i16);
impl TokenField_sim14 {
    fn execution(&self) -> i16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im21less0(u32);
impl TokenField_im21less0 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im21_1_12(u16);
impl TokenField_im21_1_12 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im21_12_14(u8);
impl TokenField_im21_12_14 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im21_14_16(u8);
impl TokenField_im21_14_16 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im21_16_21(u8);
impl TokenField_im21_16_21 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im14(u16);
impl TokenField_im14 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im14less0(u16);
impl TokenField_im14less0 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im11(i16);
impl TokenField_im11 {
    fn execution(&self) -> i16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im11less0(u16);
impl TokenField_im11less0 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sim5(i8);
impl TokenField_sim5 {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im5(u8);
impl TokenField_im5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im5less0(u8);
impl TokenField_im5less0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpcond(u8);
impl TokenField_fpcond {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fptest(u8);
impl TokenField_fptest {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_22_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpt(u8);
impl TokenField_fpt {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fptsgl(u8);
impl TokenField_fptsgl {
    fn execution(&self) -> Register {
        meaning_3_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_3_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fusedrt(u8);
impl TokenField_fusedrt {
    fn execution(&self) -> Register {
        meaning_4_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_4_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpthalf(u8);
impl TokenField_fpthalf {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_crnamet(u8);
impl TokenField_crnamet {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_t(u8);
impl TokenField_t {
    fn execution(&self) -> Register {
        meaning_5_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_5_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit0(u8);
impl TokenField_bit0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_w(u8);
impl TokenField_w {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
struct TokenParser<const LEN: usize>([u8; LEN]);
impl<const LEN: usize> MemoryRead for TokenParser<LEN> {
    type AddressType = usize;
    fn read(
        &self,
        addr: Self::AddressType,
        buf: &mut [u8],
    ) -> Result<(), MemoryReadError<Self::AddressType>> {
        let end = addr + buf.len();
        self.0
            .get(addr..end)
            .map(|src| buf.copy_from_slice(src))
            .ok_or(MemoryReadError::UnableToReadMemory(addr, end))
    }
}
impl<const LEN: usize> TokenParser<LEN> {
    fn new(data: &[u8]) -> Option<Self> {
        let token_slice: &[u8] = data.get(..LEN)?;
        let token_data = <[u8; LEN]>::try_from(token_slice).unwrap();
        Some(Self(token_data))
    }
    fn TokenFieldopfam(&self) -> TokenField_opfam {
        let inner_value = self.read_u8::<true>(0, 2, 6).unwrap();
        TokenField_opfam(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldcr(&self) -> TokenField_cr {
        let inner_value = self.read_u16::<true>(0, 5, 5).unwrap();
        TokenField_cr(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldcrname2(&self) -> TokenField_crname2 {
        let inner_value = self.read_u16::<true>(0, 5, 5).unwrap();
        TokenField_crname2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfreg2(&self) -> TokenField_freg2 {
        let inner_value = self.read_u16::<true>(0, 5, 5).unwrap();
        TokenField_freg2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfreg2sgl(&self) -> TokenField_freg2sgl {
        let inner_value = self.read_u16::<true>(0, 5, 5).unwrap();
        TokenField_freg2sgl(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfr2half(&self) -> TokenField_fr2half {
        let inner_value = self.read_u16::<true>(0, 5, 5).unwrap();
        TokenField_fr2half(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfusedr2(&self) -> TokenField_fusedr2 {
        let inner_value = self.read_u16::<true>(0, 5, 5).unwrap();
        TokenField_fusedr2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldreg2(&self) -> TokenField_reg2 {
        let inner_value = self.read_u16::<true>(0, 5, 5).unwrap();
        TokenField_reg2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldb(&self) -> TokenField_b {
        let inner_value = self.read_u16::<true>(0, 5, 5).unwrap();
        TokenField_b(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbboffset(&self) -> TokenField_bboffset {
        let inner_value = self.read_u16::<true>(0, 5, 5).unwrap();
        TokenField_bboffset(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldcrname1(&self) -> TokenField_crname1 {
        let inner_value = self.read_u16::<true>(0, 5, 5).unwrap();
        TokenField_crname1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbit20(&self) -> TokenField_bit20 {
        let inner_value = self.read_i8::<true>(1, 4, 1).unwrap();
        TokenField_bit20(i8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfpc1sub2(&self) -> TokenField_fpc1sub2 {
        let inner_value = self.read_u8::<true>(1, 1, 4).unwrap();
        TokenField_fpc1sub2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldhighIm10(&self) -> TokenField_highIm10 {
        let inner_value = self.read_u16::<true>(0, 0, 10).unwrap();
        TokenField_highIm10(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldreg1(&self) -> TokenField_reg1 {
        let inner_value = self.read_u8::<true>(1, 0, 5).unwrap();
        TokenField_reg1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfusedr1(&self) -> TokenField_fusedr1 {
        let inner_value = self.read_u8::<true>(1, 0, 5).unwrap();
        TokenField_fusedr1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfreg1(&self) -> TokenField_freg1 {
        let inner_value = self.read_u8::<true>(1, 0, 5).unwrap();
        TokenField_freg1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfreg1sgl(&self) -> TokenField_freg1sgl {
        let inner_value = self.read_u8::<true>(1, 0, 5).unwrap();
        TokenField_freg1sgl(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfr1half(&self) -> TokenField_fr1half {
        let inner_value = self.read_u8::<true>(1, 0, 5).unwrap();
        TokenField_fr1half(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldr(&self) -> TokenField_r {
        let inner_value = self.read_u8::<true>(1, 0, 5).unwrap();
        TokenField_r(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldhighIm5(&self) -> TokenField_highIm5 {
        let inner_value = self.read_i8::<true>(1, 0, 5).unwrap();
        TokenField_highIm5(i8::try_from(inner_value).unwrap())
    }
    fn TokenFieldhighIm5less16(&self) -> TokenField_highIm5less16 {
        let inner_value = self.read_u8::<true>(1, 1, 4).unwrap();
        TokenField_highIm5less16(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldtr(&self) -> TokenField_tr {
        let inner_value = self.read_u8::<true>(1, 0, 5).unwrap();
        TokenField_tr(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldx(&self) -> TokenField_x {
        let inner_value = self.read_u8::<true>(1, 0, 5).unwrap();
        TokenField_x(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldw1(&self) -> TokenField_w1 {
        let inner_value = self.read_u8::<true>(1, 0, 5).unwrap();
        TokenField_w1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbit16(&self) -> TokenField_bit16 {
        let inner_value = self.read_u8::<true>(1, 0, 1).unwrap();
        TokenField_bit16(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfpc1sub(&self) -> TokenField_fpc1sub {
        let inner_value = self.read_u16::<true>(1, 7, 2).unwrap();
        TokenField_fpc1sub(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsrbit1(&self) -> TokenField_srbit1 {
        let inner_value = self.read_u8::<true>(2, 7, 1).unwrap();
        TokenField_srbit1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFields(&self) -> TokenField_s {
        let inner_value = self.read_u8::<true>(2, 6, 2).unwrap();
        TokenField_s(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsrbit0(&self) -> TokenField_srbit0 {
        let inner_value = self.read_u8::<true>(2, 6, 1).unwrap();
        TokenField_srbit0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldim13(&self) -> TokenField_im13 {
        let inner_value = self.read_i32::<true>(0, 5, 13).unwrap();
        TokenField_im13(i16::try_from(inner_value).unwrap())
    }
    fn TokenFieldSEDCondSym(&self) -> TokenField_SEDCondSym {
        let inner_value = self.read_u8::<true>(2, 5, 3).unwrap();
        TokenField_SEDCondSym(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRegUnitCondSym(&self) -> TokenField_RegUnitCondSym {
        let inner_value = self.read_u8::<true>(2, 5, 3).unwrap();
        TokenField_RegUnitCondSym(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldInvUnitCondSym(&self) -> TokenField_InvUnitCondSym {
        let inner_value = self.read_u8::<true>(2, 5, 3).unwrap();
        TokenField_InvUnitCondSym(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRegLogicCondSym(&self) -> TokenField_RegLogicCondSym {
        let inner_value = self.read_u8::<true>(2, 5, 3).unwrap();
        TokenField_RegLogicCondSym(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldInvLogicCondSym(&self) -> TokenField_InvLogicCondSym {
        let inner_value = self.read_u8::<true>(2, 5, 3).unwrap();
        TokenField_InvLogicCondSym(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRegAddCondSym(&self) -> TokenField_RegAddCondSym {
        let inner_value = self.read_u8::<true>(2, 5, 3).unwrap();
        TokenField_RegAddCondSym(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldInvAddCondSym(&self) -> TokenField_InvAddCondSym {
        let inner_value = self.read_u8::<true>(2, 5, 3).unwrap();
        TokenField_InvAddCondSym(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRegCSCondSym(&self) -> TokenField_RegCSCondSym {
        let inner_value = self.read_u8::<true>(2, 5, 3).unwrap();
        TokenField_RegCSCondSym(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldInvCSCondSym(&self) -> TokenField_InvCSCondSym {
        let inner_value = self.read_u8::<true>(2, 5, 3).unwrap();
        TokenField_InvCSCondSym(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc(&self) -> TokenField_c {
        let inner_value = self.read_u8::<true>(2, 5, 3).unwrap();
        TokenField_c(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfpsub(&self) -> TokenField_fpsub {
        let inner_value = self.read_u8::<true>(2, 5, 3).unwrap();
        TokenField_fpsub(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsrbit2(&self) -> TokenField_srbit2 {
        let inner_value = self.read_u8::<true>(2, 5, 1).unwrap();
        TokenField_srbit2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfpdf(&self) -> TokenField_fpdf {
        let inner_value = self.read_u8::<true>(2, 5, 2).unwrap();
        TokenField_fpdf(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfixeddf(&self) -> TokenField_fixeddf {
        let inner_value = self.read_u8::<true>(2, 5, 2).unwrap();
        TokenField_fixeddf(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfpdfraw(&self) -> TokenField_fpdfraw {
        let inner_value = self.read_u8::<true>(2, 5, 2).unwrap();
        TokenField_fpdfraw(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfixedsf(&self) -> TokenField_fixedsf {
        let inner_value = self.read_u8::<true>(2, 5, 2).unwrap();
        TokenField_fixedsf(u8::try_from(inner_value).unwrap())
    }
    fn TokenFielda(&self) -> TokenField_a {
        let inner_value = self.read_u8::<true>(2, 5, 1).unwrap();
        TokenField_a(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldu(&self) -> TokenField_u {
        let inner_value = self.read_u8::<true>(2, 5, 1).unwrap();
        TokenField_u(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfpr1x(&self) -> TokenField_fpr1x {
        let inner_value = self.read_u8::<true>(2, 4, 1).unwrap();
        TokenField_fpr1x(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldf(&self) -> TokenField_f {
        let inner_value = self.read_u8::<true>(2, 4, 1).unwrap();
        TokenField_f(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfv(&self) -> TokenField_fv {
        let inner_value = self.read_u8::<true>(2, 4, 1).unwrap();
        TokenField_fv(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldzero(&self) -> TokenField_zero {
        let inner_value = self.read_u8::<true>(2, 4, 1).unwrap();
        TokenField_zero(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldone(&self) -> TokenField_one {
        let inner_value = self.read_u8::<true>(2, 4, 1).unwrap();
        TokenField_one(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsubop1012(&self) -> TokenField_subop1012 {
        let inner_value = self.read_u8::<true>(2, 2, 3).unwrap();
        TokenField_subop1012(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldim15(&self) -> TokenField_im15 {
        let inner_value = self.read_u32::<true>(0, 3, 15).unwrap();
        TokenField_im15(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldsopim10(&self) -> TokenField_sopim10 {
        let inner_value = self.read_i16::<true>(1, 3, 10).unwrap();
        TokenField_sopim10(i16::try_from(inner_value).unwrap())
    }
    fn TokenFieldsopim5(&self) -> TokenField_sopim5 {
        let inner_value = self.read_i8::<true>(2, 3, 5).unwrap();
        TokenField_sopim5(i8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfpta(&self) -> TokenField_fpta {
        let inner_value = self.read_u8::<true>(2, 3, 5).unwrap();
        TokenField_fpta(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfusedta(&self) -> TokenField_fusedta {
        let inner_value = self.read_u8::<true>(2, 3, 5).unwrap();
        TokenField_fusedta(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfpsf(&self) -> TokenField_fpsf {
        let inner_value = self.read_u8::<true>(2, 3, 2).unwrap();
        TokenField_fpsf(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfpsfraw(&self) -> TokenField_fpsfraw {
        let inner_value = self.read_u8::<true>(2, 3, 2).unwrap();
        TokenField_fpsfraw(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfpfmt(&self) -> TokenField_fpfmt {
        let inner_value = self.read_u8::<true>(2, 3, 2).unwrap();
        TokenField_fpfmt(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfpfmt1bit(&self) -> TokenField_fpfmt1bit {
        let inner_value = self.read_u8::<true>(2, 3, 1).unwrap();
        TokenField_fpfmt1bit(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbit11(&self) -> TokenField_bit11 {
        let inner_value = self.read_u8::<true>(2, 3, 1).unwrap();
        TokenField_bit11(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldcc(&self) -> TokenField_cc {
        let inner_value = self.read_u8::<true>(2, 2, 2).unwrap();
        TokenField_cc(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldldcc(&self) -> TokenField_ldcc {
        let inner_value = self.read_u8::<true>(2, 2, 2).unwrap();
        TokenField_ldcc(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldstcc(&self) -> TokenField_stcc {
        let inner_value = self.read_u8::<true>(2, 2, 2).unwrap();
        TokenField_stcc(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldldcwcc(&self) -> TokenField_ldcwcc {
        let inner_value = self.read_u8::<true>(2, 2, 2).unwrap();
        TokenField_ldcwcc(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbit10(&self) -> TokenField_bit10 {
        let inner_value = self.read_u8::<true>(2, 2, 1).unwrap();
        TokenField_bit10(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsopim17(&self) -> TokenField_sopim17 {
        let inner_value = self.read_u32::<true>(0, 1, 17).unwrap();
        TokenField_sopim17(u32::try_from(inner_value).unwrap())
    }
    fn TokenFieldpmuop(&self) -> TokenField_pmuop {
        let inner_value = self.read_u8::<true>(2, 1, 5).unwrap();
        TokenField_pmuop(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldspecop(&self) -> TokenField_specop {
        let inner_value = self.read_u8::<true>(2, 1, 2).unwrap();
        TokenField_specop(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfpclass(&self) -> TokenField_fpclass {
        let inner_value = self.read_u8::<true>(2, 1, 2).unwrap();
        TokenField_fpclass(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbit9(&self) -> TokenField_bit9 {
        let inner_value = self.read_u8::<true>(2, 1, 1).unwrap();
        TokenField_bit9(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbit8(&self) -> TokenField_bit8 {
        let inner_value = self.read_u8::<true>(2, 0, 1).unwrap();
        TokenField_bit8(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfpx(&self) -> TokenField_fpx {
        let inner_value = self.read_u8::<true>(2, 0, 1).unwrap();
        TokenField_fpx(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbits78(&self) -> TokenField_bits78 {
        let inner_value = self.read_u16::<true>(2, 7, 2).unwrap();
        TokenField_bits78(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfpr2x(&self) -> TokenField_fpr2x {
        let inner_value = self.read_u8::<true>(3, 7, 1).unwrap();
        TokenField_fpr2x(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfpra(&self) -> TokenField_fpra {
        let inner_value = self.read_u16::<true>(2, 6, 5).unwrap();
        TokenField_fpra(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfusedra(&self) -> TokenField_fusedra {
        let inner_value = self.read_u16::<true>(2, 6, 5).unwrap();
        TokenField_fusedra(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldext4(&self) -> TokenField_ext4 {
        let inner_value = self.read_u16::<true>(2, 6, 4).unwrap();
        TokenField_ext4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldC(&self) -> TokenField_C {
        let inner_value = self.read_u16::<true>(2, 6, 4).unwrap();
        TokenField_C(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsubop(&self) -> TokenField_subop {
        let inner_value = self.read_u16::<true>(2, 6, 4).unwrap();
        TokenField_subop(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsysopshifted(&self) -> TokenField_sysopshifted {
        let inner_value = self.read_u16::<true>(2, 6, 8).unwrap();
        TokenField_sysopshifted(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsysopshiftedshort(&self) -> TokenField_sysopshiftedshort {
        let inner_value = self.read_u16::<true>(2, 6, 7).unwrap();
        TokenField_sysopshiftedshort(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldop(&self) -> TokenField_op {
        let inner_value = self.read_u16::<true>(2, 6, 6).unwrap();
        TokenField_op(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsfu(&self) -> TokenField_sfu {
        let inner_value = self.read_u16::<true>(2, 6, 3).unwrap();
        TokenField_sfu(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfp0czero(&self) -> TokenField_fp0czero {
        let inner_value = self.read_u16::<true>(2, 6, 3).unwrap();
        TokenField_fp0czero(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfptx(&self) -> TokenField_fptx {
        let inner_value = self.read_u8::<true>(3, 6, 1).unwrap();
        TokenField_fptx(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbit6(&self) -> TokenField_bit6 {
        let inner_value = self.read_u8::<true>(3, 6, 1).unwrap();
        TokenField_bit6(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsysop(&self) -> TokenField_sysop {
        let inner_value = self.read_u16::<true>(2, 5, 8).unwrap();
        TokenField_sysop(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldi2(&self) -> TokenField_i2 {
        let inner_value = self.read_u16::<true>(2, 5, 7).unwrap();
        TokenField_i2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbits59(&self) -> TokenField_bits59 {
        let inner_value = self.read_u16::<true>(2, 5, 5).unwrap();
        TokenField_bits59(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldcp(&self) -> TokenField_cp {
        let inner_value = self.read_u16::<true>(2, 5, 5).unwrap();
        TokenField_cp(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfusedfmt(&self) -> TokenField_fusedfmt {
        let inner_value = self.read_u8::<true>(3, 5, 1).unwrap();
        TokenField_fusedfmt(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbit5(&self) -> TokenField_bit5 {
        let inner_value = self.read_u8::<true>(3, 5, 1).unwrap();
        TokenField_bit5(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldm(&self) -> TokenField_m {
        let inner_value = self.read_u8::<true>(3, 5, 1).unwrap();
        TokenField_m(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldspn(&self) -> TokenField_spn {
        let inner_value = self.read_u8::<true>(3, 5, 1).unwrap();
        TokenField_spn(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldw2(&self) -> TokenField_w2 {
        let inner_value = self.read_u16::<true>(2, 2, 11).unwrap();
        TokenField_w2(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldw2_2(&self) -> TokenField_w2_2 {
        let inner_value = self.read_u8::<true>(3, 2, 1).unwrap();
        TokenField_w2_2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldw2less2(&self) -> TokenField_w2less2 {
        let inner_value = self.read_u16::<true>(2, 3, 10).unwrap();
        TokenField_w2less2(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldn(&self) -> TokenField_n {
        let inner_value = self.read_u8::<true>(3, 1, 1).unwrap();
        TokenField_n(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldim26(&self) -> TokenField_im26 {
        let inner_value = self.read_i32::<true>(0, 0, 26).unwrap();
        TokenField_im26(i32::try_from(inner_value).unwrap())
    }
    fn TokenFieldsim21(&self) -> TokenField_sim21 {
        let inner_value = self.read_i32::<true>(1, 0, 21).unwrap();
        TokenField_sim21(i32::try_from(inner_value).unwrap())
    }
    fn TokenFieldsim14(&self) -> TokenField_sim14 {
        let inner_value = self.read_i16::<true>(2, 0, 14).unwrap();
        TokenField_sim14(i16::try_from(inner_value).unwrap())
    }
    fn TokenFieldim21less0(&self) -> TokenField_im21less0 {
        let inner_value = self.read_u32::<true>(1, 1, 20).unwrap();
        TokenField_im21less0(u32::try_from(inner_value).unwrap())
    }
    fn TokenFieldim21_1_12(&self) -> TokenField_im21_1_12 {
        let inner_value = self.read_u16::<true>(2, 1, 11).unwrap();
        TokenField_im21_1_12(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldim21_12_14(&self) -> TokenField_im21_12_14 {
        let inner_value = self.read_u8::<true>(2, 4, 2).unwrap();
        TokenField_im21_12_14(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldim21_14_16(&self) -> TokenField_im21_14_16 {
        let inner_value = self.read_u8::<true>(2, 6, 2).unwrap();
        TokenField_im21_14_16(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldim21_16_21(&self) -> TokenField_im21_16_21 {
        let inner_value = self.read_u8::<true>(1, 0, 5).unwrap();
        TokenField_im21_16_21(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldim14(&self) -> TokenField_im14 {
        let inner_value = self.read_u16::<true>(2, 0, 14).unwrap();
        TokenField_im14(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldim14less0(&self) -> TokenField_im14less0 {
        let inner_value = self.read_u16::<true>(2, 1, 13).unwrap();
        TokenField_im14less0(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldim11(&self) -> TokenField_im11 {
        let inner_value = self.read_i16::<true>(2, 0, 11).unwrap();
        TokenField_im11(i16::try_from(inner_value).unwrap())
    }
    fn TokenFieldim11less0(&self) -> TokenField_im11less0 {
        let inner_value = self.read_u16::<true>(2, 1, 11).unwrap();
        TokenField_im11less0(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldsim5(&self) -> TokenField_sim5 {
        let inner_value = self.read_i8::<true>(3, 0, 5).unwrap();
        TokenField_sim5(i8::try_from(inner_value).unwrap())
    }
    fn TokenFieldim5(&self) -> TokenField_im5 {
        let inner_value = self.read_u8::<true>(3, 0, 5).unwrap();
        TokenField_im5(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldim5less0(&self) -> TokenField_im5less0 {
        let inner_value = self.read_u8::<true>(3, 1, 4).unwrap();
        TokenField_im5less0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfpcond(&self) -> TokenField_fpcond {
        let inner_value = self.read_u8::<true>(3, 0, 5).unwrap();
        TokenField_fpcond(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfptest(&self) -> TokenField_fptest {
        let inner_value = self.read_u8::<true>(3, 0, 5).unwrap();
        TokenField_fptest(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfpt(&self) -> TokenField_fpt {
        let inner_value = self.read_u8::<true>(3, 0, 5).unwrap();
        TokenField_fpt(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfptsgl(&self) -> TokenField_fptsgl {
        let inner_value = self.read_u8::<true>(3, 0, 5).unwrap();
        TokenField_fptsgl(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfusedrt(&self) -> TokenField_fusedrt {
        let inner_value = self.read_u8::<true>(3, 0, 5).unwrap();
        TokenField_fusedrt(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfpthalf(&self) -> TokenField_fpthalf {
        let inner_value = self.read_u8::<true>(3, 0, 5).unwrap();
        TokenField_fpthalf(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldcrnamet(&self) -> TokenField_crnamet {
        let inner_value = self.read_u8::<true>(3, 0, 5).unwrap();
        TokenField_crnamet(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldt(&self) -> TokenField_t {
        let inner_value = self.read_u8::<true>(3, 0, 5).unwrap();
        TokenField_t(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbit0(&self) -> TokenField_bit0 {
        let inner_value = self.read_u8::<true>(3, 0, 1).unwrap();
        TokenField_bit0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldw(&self) -> TokenField_w {
        let inner_value = self.read_u8::<true>(3, 0, 1).unwrap();
        TokenField_w(u8::try_from(inner_value).unwrap())
    }
}
#[derive(Clone, Copy, Debug)]
pub enum Register {
    r0,
    r1,
    rp,
    r3,
    r4,
    r5,
    r6,
    r7,
    r8,
    r9,
    r10,
    r11,
    r12,
    r13,
    r14,
    r15,
    r16,
    r17,
    r18,
    r19,
    r20,
    r21,
    r22,
    r23,
    r24,
    r25,
    r26,
    dp,
    r28,
    r29,
    sp,
    r31,
    fr0,
    fpe23,
    fpe45,
    fpe67,
    fr4,
    fr5,
    fr6,
    fr7,
    fr8,
    fr9,
    fr10,
    fr11,
    fr12,
    fr13,
    fr14,
    fr15,
    fr16,
    fr17,
    fr18,
    fr19,
    fr20,
    fr21,
    fr22,
    fr23,
    fr24,
    fr25,
    fr26,
    fr27,
    fr28,
    fr29,
    fr30,
    fr31,
    fr0R,
    fr0L,
    fpe2,
    fpe3,
    fpe4,
    fpe5,
    fpe6,
    fpe7,
    fr4L,
    fr4R,
    fr5L,
    fr5R,
    fr6L,
    fr6R,
    fr7L,
    fr7R,
    fr8L,
    fr8R,
    fr9L,
    fr9R,
    fr10L,
    fr10R,
    fr11L,
    fr11R,
    fr12L,
    fr12R,
    fr13L,
    fr13R,
    fr14L,
    fr14R,
    fr15L,
    fr15R,
    fr16L,
    fr16R,
    fr17L,
    fr17R,
    fr18L,
    fr18R,
    fr19L,
    fr19R,
    fr20L,
    fr20R,
    fr21L,
    fr21R,
    fr22L,
    fr22R,
    fr23L,
    fr23R,
    fr24L,
    fr24R,
    fr25L,
    fr25R,
    fr26L,
    fr26R,
    fr27L,
    fr27R,
    fr28L,
    fr28R,
    fr29L,
    fr29R,
    fr30L,
    fr30R,
    fr31L,
    fr31R,
    compareBit,
    compareQueue,
    shr0,
    shr1,
    shr2,
    shr3,
    shr4,
    shr5,
    shr6,
    sr0,
    sr1,
    sr2,
    sr3,
    sr4,
    sr5,
    sr6,
    sr7,
    pswY,
    pswZ,
    pswE,
    pswS,
    pswT,
    pswH,
    pswL,
    pswN,
    pswX,
    pswB,
    pswC,
    pswV,
    pswM,
    pswCB,
    pswG,
    pswF,
    pswR,
    pswQ,
    pswP,
    pswD,
    pswI,
    cr0,
    cr1,
    cr2,
    cr3,
    cr4,
    cr5,
    cr6,
    cr7,
    cr8,
    cr9,
    cr10,
    sar,
    cr12,
    cr13,
    cr14,
    cr15,
    cr16,
    cr17,
    cr18,
    cr19,
    cr20,
    cr21,
    cr22,
    cr23,
    cr24,
    cr25,
    cr26,
    cr27,
    cr28,
    cr29,
    cr30,
    cr31,
    iasq_front,
    iasq_back,
    iaoq_front,
    iaoq_back,
    nullifyCond,
    nullifyNextCond,
    branchCond,
    branchExecuted,
    branchIndDest,
    nullifyCondResult,
    contextreg,
}
impl core::fmt::Display for Register {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::r0 => write!(f, "r0"),
            Self::r1 => write!(f, "r1"),
            Self::rp => write!(f, "rp"),
            Self::r3 => write!(f, "r3"),
            Self::r4 => write!(f, "r4"),
            Self::r5 => write!(f, "r5"),
            Self::r6 => write!(f, "r6"),
            Self::r7 => write!(f, "r7"),
            Self::r8 => write!(f, "r8"),
            Self::r9 => write!(f, "r9"),
            Self::r10 => write!(f, "r10"),
            Self::r11 => write!(f, "r11"),
            Self::r12 => write!(f, "r12"),
            Self::r13 => write!(f, "r13"),
            Self::r14 => write!(f, "r14"),
            Self::r15 => write!(f, "r15"),
            Self::r16 => write!(f, "r16"),
            Self::r17 => write!(f, "r17"),
            Self::r18 => write!(f, "r18"),
            Self::r19 => write!(f, "r19"),
            Self::r20 => write!(f, "r20"),
            Self::r21 => write!(f, "r21"),
            Self::r22 => write!(f, "r22"),
            Self::r23 => write!(f, "r23"),
            Self::r24 => write!(f, "r24"),
            Self::r25 => write!(f, "r25"),
            Self::r26 => write!(f, "r26"),
            Self::dp => write!(f, "dp"),
            Self::r28 => write!(f, "r28"),
            Self::r29 => write!(f, "r29"),
            Self::sp => write!(f, "sp"),
            Self::r31 => write!(f, "r31"),
            Self::fr0 => write!(f, "fr0"),
            Self::fpe23 => write!(f, "fpe23"),
            Self::fpe45 => write!(f, "fpe45"),
            Self::fpe67 => write!(f, "fpe67"),
            Self::fr4 => write!(f, "fr4"),
            Self::fr5 => write!(f, "fr5"),
            Self::fr6 => write!(f, "fr6"),
            Self::fr7 => write!(f, "fr7"),
            Self::fr8 => write!(f, "fr8"),
            Self::fr9 => write!(f, "fr9"),
            Self::fr10 => write!(f, "fr10"),
            Self::fr11 => write!(f, "fr11"),
            Self::fr12 => write!(f, "fr12"),
            Self::fr13 => write!(f, "fr13"),
            Self::fr14 => write!(f, "fr14"),
            Self::fr15 => write!(f, "fr15"),
            Self::fr16 => write!(f, "fr16"),
            Self::fr17 => write!(f, "fr17"),
            Self::fr18 => write!(f, "fr18"),
            Self::fr19 => write!(f, "fr19"),
            Self::fr20 => write!(f, "fr20"),
            Self::fr21 => write!(f, "fr21"),
            Self::fr22 => write!(f, "fr22"),
            Self::fr23 => write!(f, "fr23"),
            Self::fr24 => write!(f, "fr24"),
            Self::fr25 => write!(f, "fr25"),
            Self::fr26 => write!(f, "fr26"),
            Self::fr27 => write!(f, "fr27"),
            Self::fr28 => write!(f, "fr28"),
            Self::fr29 => write!(f, "fr29"),
            Self::fr30 => write!(f, "fr30"),
            Self::fr31 => write!(f, "fr31"),
            Self::fr0R => write!(f, "fr0R"),
            Self::fr0L => write!(f, "fr0L"),
            Self::fpe2 => write!(f, "fpe2"),
            Self::fpe3 => write!(f, "fpe3"),
            Self::fpe4 => write!(f, "fpe4"),
            Self::fpe5 => write!(f, "fpe5"),
            Self::fpe6 => write!(f, "fpe6"),
            Self::fpe7 => write!(f, "fpe7"),
            Self::fr4L => write!(f, "fr4L"),
            Self::fr4R => write!(f, "fr4R"),
            Self::fr5L => write!(f, "fr5L"),
            Self::fr5R => write!(f, "fr5R"),
            Self::fr6L => write!(f, "fr6L"),
            Self::fr6R => write!(f, "fr6R"),
            Self::fr7L => write!(f, "fr7L"),
            Self::fr7R => write!(f, "fr7R"),
            Self::fr8L => write!(f, "fr8L"),
            Self::fr8R => write!(f, "fr8R"),
            Self::fr9L => write!(f, "fr9L"),
            Self::fr9R => write!(f, "fr9R"),
            Self::fr10L => write!(f, "fr10L"),
            Self::fr10R => write!(f, "fr10R"),
            Self::fr11L => write!(f, "fr11L"),
            Self::fr11R => write!(f, "fr11R"),
            Self::fr12L => write!(f, "fr12L"),
            Self::fr12R => write!(f, "fr12R"),
            Self::fr13L => write!(f, "fr13L"),
            Self::fr13R => write!(f, "fr13R"),
            Self::fr14L => write!(f, "fr14L"),
            Self::fr14R => write!(f, "fr14R"),
            Self::fr15L => write!(f, "fr15L"),
            Self::fr15R => write!(f, "fr15R"),
            Self::fr16L => write!(f, "fr16L"),
            Self::fr16R => write!(f, "fr16R"),
            Self::fr17L => write!(f, "fr17L"),
            Self::fr17R => write!(f, "fr17R"),
            Self::fr18L => write!(f, "fr18L"),
            Self::fr18R => write!(f, "fr18R"),
            Self::fr19L => write!(f, "fr19L"),
            Self::fr19R => write!(f, "fr19R"),
            Self::fr20L => write!(f, "fr20L"),
            Self::fr20R => write!(f, "fr20R"),
            Self::fr21L => write!(f, "fr21L"),
            Self::fr21R => write!(f, "fr21R"),
            Self::fr22L => write!(f, "fr22L"),
            Self::fr22R => write!(f, "fr22R"),
            Self::fr23L => write!(f, "fr23L"),
            Self::fr23R => write!(f, "fr23R"),
            Self::fr24L => write!(f, "fr24L"),
            Self::fr24R => write!(f, "fr24R"),
            Self::fr25L => write!(f, "fr25L"),
            Self::fr25R => write!(f, "fr25R"),
            Self::fr26L => write!(f, "fr26L"),
            Self::fr26R => write!(f, "fr26R"),
            Self::fr27L => write!(f, "fr27L"),
            Self::fr27R => write!(f, "fr27R"),
            Self::fr28L => write!(f, "fr28L"),
            Self::fr28R => write!(f, "fr28R"),
            Self::fr29L => write!(f, "fr29L"),
            Self::fr29R => write!(f, "fr29R"),
            Self::fr30L => write!(f, "fr30L"),
            Self::fr30R => write!(f, "fr30R"),
            Self::fr31L => write!(f, "fr31L"),
            Self::fr31R => write!(f, "fr31R"),
            Self::compareBit => write!(f, "compareBit"),
            Self::compareQueue => write!(f, "compareQueue"),
            Self::shr0 => write!(f, "shr0"),
            Self::shr1 => write!(f, "shr1"),
            Self::shr2 => write!(f, "shr2"),
            Self::shr3 => write!(f, "shr3"),
            Self::shr4 => write!(f, "shr4"),
            Self::shr5 => write!(f, "shr5"),
            Self::shr6 => write!(f, "shr6"),
            Self::sr0 => write!(f, "sr0"),
            Self::sr1 => write!(f, "sr1"),
            Self::sr2 => write!(f, "sr2"),
            Self::sr3 => write!(f, "sr3"),
            Self::sr4 => write!(f, "sr4"),
            Self::sr5 => write!(f, "sr5"),
            Self::sr6 => write!(f, "sr6"),
            Self::sr7 => write!(f, "sr7"),
            Self::pswY => write!(f, "pswY"),
            Self::pswZ => write!(f, "pswZ"),
            Self::pswE => write!(f, "pswE"),
            Self::pswS => write!(f, "pswS"),
            Self::pswT => write!(f, "pswT"),
            Self::pswH => write!(f, "pswH"),
            Self::pswL => write!(f, "pswL"),
            Self::pswN => write!(f, "pswN"),
            Self::pswX => write!(f, "pswX"),
            Self::pswB => write!(f, "pswB"),
            Self::pswC => write!(f, "pswC"),
            Self::pswV => write!(f, "pswV"),
            Self::pswM => write!(f, "pswM"),
            Self::pswCB => write!(f, "pswCB"),
            Self::pswG => write!(f, "pswG"),
            Self::pswF => write!(f, "pswF"),
            Self::pswR => write!(f, "pswR"),
            Self::pswQ => write!(f, "pswQ"),
            Self::pswP => write!(f, "pswP"),
            Self::pswD => write!(f, "pswD"),
            Self::pswI => write!(f, "pswI"),
            Self::cr0 => write!(f, "cr0"),
            Self::cr1 => write!(f, "cr1"),
            Self::cr2 => write!(f, "cr2"),
            Self::cr3 => write!(f, "cr3"),
            Self::cr4 => write!(f, "cr4"),
            Self::cr5 => write!(f, "cr5"),
            Self::cr6 => write!(f, "cr6"),
            Self::cr7 => write!(f, "cr7"),
            Self::cr8 => write!(f, "cr8"),
            Self::cr9 => write!(f, "cr9"),
            Self::cr10 => write!(f, "cr10"),
            Self::sar => write!(f, "sar"),
            Self::cr12 => write!(f, "cr12"),
            Self::cr13 => write!(f, "cr13"),
            Self::cr14 => write!(f, "cr14"),
            Self::cr15 => write!(f, "cr15"),
            Self::cr16 => write!(f, "cr16"),
            Self::cr17 => write!(f, "cr17"),
            Self::cr18 => write!(f, "cr18"),
            Self::cr19 => write!(f, "cr19"),
            Self::cr20 => write!(f, "cr20"),
            Self::cr21 => write!(f, "cr21"),
            Self::cr22 => write!(f, "cr22"),
            Self::cr23 => write!(f, "cr23"),
            Self::cr24 => write!(f, "cr24"),
            Self::cr25 => write!(f, "cr25"),
            Self::cr26 => write!(f, "cr26"),
            Self::cr27 => write!(f, "cr27"),
            Self::cr28 => write!(f, "cr28"),
            Self::cr29 => write!(f, "cr29"),
            Self::cr30 => write!(f, "cr30"),
            Self::cr31 => write!(f, "cr31"),
            Self::iasq_front => write!(f, "iasq_front"),
            Self::iasq_back => write!(f, "iasq_back"),
            Self::iaoq_front => write!(f, "iaoq_front"),
            Self::iaoq_back => write!(f, "iaoq_back"),
            Self::nullifyCond => write!(f, "nullifyCond"),
            Self::nullifyNextCond => write!(f, "nullifyNextCond"),
            Self::branchCond => write!(f, "branchCond"),
            Self::branchExecuted => write!(f, "branchExecuted"),
            Self::branchIndDest => write!(f, "branchIndDest"),
            Self::nullifyCondResult => write!(f, "nullifyCondResult"),
            Self::contextreg => write!(f, "contextreg"),
        }
    }
}
#[derive(Clone, Copy, Debug)]
pub enum DisplayElement {
    Literal(&'static str),
    Register(Register),
    Number(bool, i128),
}
impl core::fmt::Display for DisplayElement {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Literal(lit) => lit.fmt(f),
            Self::Register(reg) => reg.fmt(f),
            Self::Number(hex, value) => match (*hex, value.is_negative()) {
                (true, true) => write!(f, "-0x{:x}", value.abs()),
                (true, false) => write!(f, "0x{:x}", value),
                (false, _) => value.fmt(f),
            },
        }
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1012:1, end:1012:2))"]
#[derive(Clone, Debug)]
struct NOP_instructionVar0 {}
impl NOP_instructionVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("NOP")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldreg1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldreg2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldt().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfv().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1876:1, end:1876:2))"]
#[derive(Clone, Debug)]
struct COPR_0_0_instructionVar1 {}
impl COPR_0_0_instructionVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("COPR.0.0")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldim26().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1007:1, end:1007:2))"]
#[derive(Clone, Debug)]
struct COPY_instructionVar2 {
    R1: TableR1,
    RT: TableRT,
}
impl COPY_instructionVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("COPY"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldreg2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfv().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1399:1, end:1399:2))"]
#[derive(Clone, Debug)]
struct SYNC_instructionVar3 {}
impl SYNC_instructionVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("SYNC")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 32i128 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit20().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1400:1, end:1400:2))"]
#[derive(Clone, Debug)]
struct SYNCDMA_instructionVar4 {}
impl SYNCDMA_instructionVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("SYNCDMA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 32i128 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit20().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1359:1, end:1359:2))"]
#[derive(Clone, Debug)]
struct MTSM_instructionVar5 {
    R1: TableR1,
}
impl MTSM_instructionVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MTSM"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 195i128 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1428:1, end:1428:2))"]
#[derive(Clone, Debug)]
struct IITLBT_instructionVar6 {
    R2: TableR2,
    R1: TableR1,
}
impl IITLBT_instructionVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("IITLBT"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshiftedshort().disassembly() != 32i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 0i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, R1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1327:1, end:1327:2))"]
#[derive(Clone, Debug)]
struct SSM_instructionVar7 {
    highIm10: TokenField_highIm10,
    RT: TableRT,
}
impl SSM_instructionVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("SSM"),
            DisplayElement::Literal(" "),
            self.highIm10.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 107i128 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highIm10 = token_parser.TokenFieldhighIm10();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, highIm10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1343:1, end:1343:2))"]
#[derive(Clone, Debug)]
struct RSM_instructionVar8 {
    highIm10: TokenField_highIm10,
    RT: TableRT,
}
impl RSM_instructionVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("RSM"),
            DisplayElement::Literal(" "),
            self.highIm10.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 115i128 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highIm10 = token_parser.TokenFieldhighIm10();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, highIm10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1665:1, end:1665:2))"]
#[derive(Clone, Debug)]
struct FCNVXF_instructionVar9 {
    fixedsf: TokenField_fixedsf,
    fpdf: TokenField_fpdf,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FCNVXF_instructionVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNVXF"),
            self.fixedsf.display(),
            self.fpdf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpdfraw().disassembly() != 0i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fixedsf = token_parser.TokenFieldfixedsf();
        let fpdf = token_parser.TokenFieldfpdf();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fixedsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1669:1, end:1669:2))"]
#[derive(Clone, Debug)]
struct FCNVXF_instructionVar10 {
    fixedsf: TokenField_fixedsf,
    fpdf: TokenField_fpdf,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FCNVXF_instructionVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNVXF"),
            self.fixedsf.display(),
            self.fpdf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpdfraw().disassembly() != 1i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fixedsf = token_parser.TokenFieldfixedsf();
        let fpdf = token_parser.TokenFieldfpdf();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fixedsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1673:1, end:1673:2))"]
#[derive(Clone, Debug)]
struct FCNVXF_instructionVar11 {
    fixedsf: TokenField_fixedsf,
    fpdf: TokenField_fpdf,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FCNVXF_instructionVar11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNVXF"),
            self.fixedsf.display(),
            self.fpdf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpdfraw().disassembly() != 0i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fixedsf = token_parser.TokenFieldfixedsf();
        let fpdf = token_parser.TokenFieldfpdf();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fixedsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1677:1, end:1677:2))"]
#[derive(Clone, Debug)]
struct FCNVXF_instructionVar12 {
    fixedsf: TokenField_fixedsf,
    fpdf: TokenField_fpdf,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FCNVXF_instructionVar12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNVXF"),
            self.fixedsf.display(),
            self.fpdf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpdfraw().disassembly() != 1i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fixedsf = token_parser.TokenFieldfixedsf();
        let fpdf = token_parser.TokenFieldfpdf();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fixedsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:80:1, end:80:2))"]
#[derive(Clone, Debug)]
struct LDWAX_instructionVar13 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    loadCC: TableloadCC,
    RX: TableRX,
    SRRB: TableSRRB,
    RB: TableRB,
    RT: TableRT,
}
impl LDWAX_instructionVar13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("LDWAX")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("),")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFields().disassembly() != 0i128 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                loadCC,
                RX,
                SRRB,
                RB,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:193:1, end:193:2))"]
#[derive(Clone, Debug)]
struct COPY_instructionVar14 {
    RB: TableRB,
    R1dst: TableR1dst,
}
impl COPY_instructionVar14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("COPY"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldim14().disassembly() != 0i128 {
            return None;
        }
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RB, R1dst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1424:1, end:1424:2))"]
#[derive(Clone, Debug)]
struct IDTLBA_instructionVar15 {
    SRRB: TableSRRB,
    R1: TableR1,
    SPCBASE: TableSPCBASE,
}
impl IDTLBA_instructionVar15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("IDTLBA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 65i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i128 {
            return None;
        }
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SRRB, R1, SPCBASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1426:1, end:1426:2))"]
#[derive(Clone, Debug)]
struct IDTLBP_instructionVar16 {
    SRRB: TableSRRB,
    R1: TableR1,
    SPCBASE: TableSPCBASE,
}
impl IDTLBP_instructionVar16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("IDTLBP"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 64i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i128 {
            return None;
        }
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SRRB, R1, SPCBASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1431:1, end:1431:2))"]
#[derive(Clone, Debug)]
struct PDC_instructionVar17 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
}
impl PDC_instructionVar17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("PDC")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 78i128 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                SRRB,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1432:1, end:1432:2))"]
#[derive(Clone, Debug)]
struct PDC_instructionVar18 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    RB: TableRB,
}
impl PDC_instructionVar18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("PDC")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 78i128 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                SRRB,
                SPCBASE,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1369:1, end:1369:2))"]
#[derive(Clone, Debug)]
struct LDSID_instructionVar19 {
    RT: TableRT,
    SRRB: TableSRRB,
    SR: TableSR,
    SRVAL: TableSRVAL,
}
impl LDSID_instructionVar19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LDSID"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 133i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR = if let Some((len, table)) =
            TableSR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRVAL = if let Some((len, table)) =
            TableSRVAL::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT,
                SRRB,
                SR,
                SRVAL,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1402:1, end:1402:2))"]
#[derive(Clone, Debug)]
struct PROBER_instructionVar20 {
    SRRB: TableSRRB,
    R1: TableR1,
    RT: TableRT,
    SPCBASE: TableSPCBASE,
}
impl PROBER_instructionVar20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("PROBER"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 70i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SRRB,
                R1,
                RT,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1403:1, end:1403:2))"]
#[derive(Clone, Debug)]
struct PROBERI_instructionVar21 {
    highIm5: TokenField_highIm5,
    SRRB: TableSRRB,
    RT: TableRT,
    SPCBASE: TableSPCBASE,
}
impl PROBERI_instructionVar21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("PROBERI"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            self.highIm5.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 198i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highIm5 = token_parser.TokenFieldhighIm5();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SRRB,
                RT,
                SPCBASE,
                highIm5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1404:1, end:1404:2))"]
#[derive(Clone, Debug)]
struct PROBEW_instructionVar22 {
    SRRB: TableSRRB,
    R1: TableR1,
    RT: TableRT,
    SPCBASE: TableSPCBASE,
}
impl PROBEW_instructionVar22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("PROBEW"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 71i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SRRB,
                R1,
                RT,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1405:1, end:1405:2))"]
#[derive(Clone, Debug)]
struct PROBEWI_instructionVar23 {
    highIm5: TokenField_highIm5,
    SRRB: TableSRRB,
    RT: TableRT,
    SPCBASE: TableSPCBASE,
}
impl PROBEWI_instructionVar23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("PROBEWI"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            self.highIm5.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 199i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highIm5 = token_parser.TokenFieldhighIm5();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SRRB,
                RT,
                SPCBASE,
                highIm5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1409:1, end:1409:2))"]
#[derive(Clone, Debug)]
struct LCI_instructionVar24 {
    RX: TableRX,
    SRRB: TableSRRB,
    RT: TableRT,
    SPCBASE: TableSPCBASE,
}
impl LCI_instructionVar24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LCI"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 76i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB,
                RT,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1411:1, end:1411:2))"]
#[derive(Clone, Debug)]
struct PDTLB_instructionVar25 {
    RX: TableRX,
    SRRB3bit: TableSRRB3bit,
    sysCmplt: TablesysCmplt,
    SPCBASE: TableSPCBASE,
}
impl PDTLB_instructionVar25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PDTLB")];
        display.extend_from_slice(&extend);
        self.sysCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 72i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) = TableSRRB3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) = TablesysCmplt::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB3bit,
                sysCmplt,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1412:1, end:1412:2))"]
#[derive(Clone, Debug)]
struct PDTLB_instructionVar26 {
    RX: TableRX,
    SRRB3bit: TableSRRB3bit,
    sysCmplt: TablesysCmplt,
    SPCBASE: TableSPCBASE,
    RB: TableRB,
}
impl PDTLB_instructionVar26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PDTLB")];
        display.extend_from_slice(&extend);
        self.sysCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 72i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) = TableSRRB3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) = TablesysCmplt::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB3bit,
                sysCmplt,
                SPCBASE,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1414:1, end:1414:2))"]
#[derive(Clone, Debug)]
struct PITLB_instructionVar27 {
    RX: TableRX,
    SRRB3bit: TableSRRB3bit,
    sysCmplt: TablesysCmplt,
    SPCBASE: TableSPCBASE,
}
impl PITLB_instructionVar27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PITLB")];
        display.extend_from_slice(&extend);
        self.sysCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) = TableSRRB3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) = TablesysCmplt::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB3bit,
                sysCmplt,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1415:1, end:1415:2))"]
#[derive(Clone, Debug)]
struct PITLB_instructionVar28 {
    RX: TableRX,
    SRRB3bit: TableSRRB3bit,
    sysCmplt: TablesysCmplt,
    SPCBASE: TableSPCBASE,
    RB: TableRB,
}
impl PITLB_instructionVar28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PITLB")];
        display.extend_from_slice(&extend);
        self.sysCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) = TableSRRB3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) = TablesysCmplt::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB3bit,
                sysCmplt,
                SPCBASE,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1417:1, end:1417:2))"]
#[derive(Clone, Debug)]
struct PDTLBE_instructionVar29 {
    RX: TableRX,
    SRRB3bit: TableSRRB3bit,
    sysCmplt: TablesysCmplt,
    SPCBASE: TableSPCBASE,
}
impl PDTLBE_instructionVar29 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PDTLBE")];
        display.extend_from_slice(&extend);
        self.sysCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 73i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) = TableSRRB3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) = TablesysCmplt::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB3bit,
                sysCmplt,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1418:1, end:1418:2))"]
#[derive(Clone, Debug)]
struct PDTLBE_instructionVar30 {
    RX: TableRX,
    SRRB3bit: TableSRRB3bit,
    sysCmplt: TablesysCmplt,
    SPCBASE: TableSPCBASE,
    RB: TableRB,
}
impl PDTLBE_instructionVar30 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PDTLBE")];
        display.extend_from_slice(&extend);
        self.sysCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 73i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) = TableSRRB3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) = TablesysCmplt::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB3bit,
                sysCmplt,
                SPCBASE,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1420:1, end:1420:2))"]
#[derive(Clone, Debug)]
struct PITLBE_instructionVar31 {
    RX: TableRX,
    SRRB3bit: TableSRRB3bit,
    sysCmplt: TablesysCmplt,
    SPCBASE: TableSPCBASE,
}
impl PITLBE_instructionVar31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PITLBE")];
        display.extend_from_slice(&extend);
        self.sysCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) = TableSRRB3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) = TablesysCmplt::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB3bit,
                sysCmplt,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1421:1, end:1421:2))"]
#[derive(Clone, Debug)]
struct PITLBE_instructionVar32 {
    RX: TableRX,
    SRRB3bit: TableSRRB3bit,
    sysCmplt: TablesysCmplt,
    SPCBASE: TableSPCBASE,
    RB: TableRB,
}
impl PITLBE_instructionVar32 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PITLBE")];
        display.extend_from_slice(&extend);
        self.sysCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) = TableSRRB3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) = TablesysCmplt::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB3bit,
                sysCmplt,
                SPCBASE,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1434:1, end:1434:2))"]
#[derive(Clone, Debug)]
struct FDC_instructionVar33 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
}
impl FDC_instructionVar33 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("FDC")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 74i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                SRRB,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1435:1, end:1435:2))"]
#[derive(Clone, Debug)]
struct FDC_instructionVar34 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    RB: TableRB,
}
impl FDC_instructionVar34 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("FDC")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 74i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                SRRB,
                SPCBASE,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1440:1, end:1440:2))"]
#[derive(Clone, Debug)]
struct FDCE_instructionVar35 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
}
impl FDCE_instructionVar35 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FDCE")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 75i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                SRRB,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1441:1, end:1441:2))"]
#[derive(Clone, Debug)]
struct FDCE_instructionVar36 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    RB: TableRB,
}
impl FDCE_instructionVar36 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FDCE")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 75i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                SRRB,
                SPCBASE,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1881:1, end:1881:2))"]
#[derive(Clone, Debug)]
struct PMENB_instructionVar37 {}
impl PMENB_instructionVar37 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PMENB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldbit5().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldpmuop().disassembly() != 3i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1882:1, end:1882:2))"]
#[derive(Clone, Debug)]
struct PMDIS_instructionVar38 {}
impl PMDIS_instructionVar38 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PMDIS")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldbit5().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldpmuop().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1407:1, end:1407:2))"]
#[derive(Clone, Debug)]
struct LPA_instructionVar39 {
    sysCmplt: TablesysCmplt,
    RX: TableRX,
    SRRB: TableSRRB,
    RT: TableRT,
    SPCBASE: TableSPCBASE,
}
impl LPA_instructionVar39 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("LPA")];
        display.extend_from_slice(&extend);
        self.sysCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 77i128 {
            return None;
        }
        let sysCmplt = if let Some((len, table)) = TablesysCmplt::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                sysCmplt,
                RX,
                SRRB,
                RT,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1498:1, end:1498:2))"]
#[derive(Clone, Debug)]
struct FLDD_instructionVar40 {
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RX: TableRX,
    FPRT64: TableFPRT64,
    SPCBASE: TableSPCBASE,
}
impl FLDD_instructionVar40 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDD")];
        display.extend_from_slice(&extend);
        self.indexedDoublewordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedDoublewordAccessCmplt,
                loadCC,
                SRRB,
                RX,
                FPRT64,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1503:1, end:1503:2))"]
#[derive(Clone, Debug)]
struct FLDD_instructionVar41 {
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RX: TableRX,
    FPRT64: TableFPRT64,
    SPCBASE: TableSPCBASE,
}
impl FLDD_instructionVar41 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDD")];
        display.extend_from_slice(&extend);
        self.indexedDoublewordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedDoublewordAccessCmplt,
                loadCC,
                SRRB,
                RX,
                FPRT64,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1508:1, end:1508:2))"]
#[derive(Clone, Debug)]
struct FLDD_instructionVar42 {
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RX: TableRX,
    RB: TableRB,
    FPRT64: TableFPRT64,
    SPCBASE: TableSPCBASE,
}
impl FLDD_instructionVar42 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDD")];
        display.extend_from_slice(&extend);
        self.indexedDoublewordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedDoublewordAccessCmplt,
                loadCC,
                SRRB,
                RX,
                RB,
                FPRT64,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1514:1, end:1514:2))"]
#[derive(Clone, Debug)]
struct FLDD_instructionVar43 {
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RB: TableRB,
    RX: TableRX,
    FPRT64: TableFPRT64,
    SPCBASE: TableSPCBASE,
}
impl FLDD_instructionVar43 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDD")];
        display.extend_from_slice(&extend);
        self.indexedDoublewordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedDoublewordAccessCmplt,
                loadCC,
                SRRB,
                RB,
                RX,
                FPRT64,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1592:1, end:1592:2))"]
#[derive(Clone, Debug)]
struct FLDD_instructionVar44 {
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
    FPRT64: TableFPRT64,
    highlse5: Tablehighlse5,
}
impl FLDD_instructionVar44 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDD")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldbit6().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                loadCC,
                SRRB,
                RB,
                SPCBASE,
                FPRT64,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1598:1, end:1598:2))"]
#[derive(Clone, Debug)]
struct FLDD_instructionVar45 {
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
    FPRT64: TableFPRT64,
    highlse5: Tablehighlse5,
}
impl FLDD_instructionVar45 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDD")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldbit6().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                loadCC,
                SRRB,
                RB,
                SPCBASE,
                FPRT64,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1626:1, end:1626:2))"]
#[derive(Clone, Debug)]
struct FSTD_instructionVar46 {
    shortDispCmplt: TableshortDispCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
    FPRT64: TableFPRT64,
    highlse5: Tablehighlse5,
}
impl FSTD_instructionVar46 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTD")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldbit6().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                storeCC,
                SRRB,
                RB,
                SPCBASE,
                FPRT64,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1632:1, end:1632:2))"]
#[derive(Clone, Debug)]
struct FSTD_instructionVar47 {
    shortDispCmplt: TableshortDispCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
    FPRT64: TableFPRT64,
    highlse5: Tablehighlse5,
}
impl FSTD_instructionVar47 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTD")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldbit6().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                storeCC,
                SRRB,
                RB,
                SPCBASE,
                FPRT64,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:144:1, end:144:2))"]
#[derive(Clone, Debug)]
struct STBYS_instructionVar48 {
    storeBytesShortCmplt: TablestoreBytesShortCmplt,
    storeCC: TablestoreCC,
    lse5: Tablelse5,
    SRRB: TableSRRB,
    RR: TableRR,
}
impl STBYS_instructionVar48 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("STBYS")];
        display.extend_from_slice(&extend);
        self.storeBytesShortCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.lse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        let storeBytesShortCmplt = if let Some((len, table)) =
            TablestoreBytesShortCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                storeBytesShortCmplt,
                storeCC,
                lse5,
                SRRB,
                RR,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:164:1, end:164:2))"]
#[derive(Clone, Debug)]
struct STBYS_instructionVar49 {
    storeBytesShortCmplt: TablestoreBytesShortCmplt,
    storeCC: TablestoreCC,
    lse5: Tablelse5,
    SRRB: TableSRRB,
    RR: TableRR,
}
impl STBYS_instructionVar49 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("STBYS")];
        display.extend_from_slice(&extend);
        self.storeBytesShortCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.lse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        let storeBytesShortCmplt = if let Some((len, table)) =
            TablestoreBytesShortCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                storeBytesShortCmplt,
                storeCC,
                lse5,
                SRRB,
                RR,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1381:1, end:1381:2))"]
#[derive(Clone, Debug)]
struct MTSAR_instructionVar50 {
    R1: TableR1,
}
impl MTSAR_instructionVar50 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MTSAR"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 194i128 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcr().disassembly() != 11i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let crname2 = token_parser.TokenFieldcrname2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1296:1, end:1296:2))"]
#[derive(Clone, Debug)]
struct RFI_instructionVar51 {}
impl RFI_instructionVar51 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("RFI")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 96i128 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1307:1, end:1307:2))"]
#[derive(Clone, Debug)]
struct RFI_instructionVar52 {}
impl RFI_instructionVar52 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("RFI"),
            DisplayElement::Literal(",R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 101i128 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1373:1, end:1373:2))"]
#[derive(Clone, Debug)]
struct MTSP_instructionVar53 {
    R1: TableR1,
    SR3bit: TableSR3bit,
}
impl MTSP_instructionVar53 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MTSP"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SR3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 193i128 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, SR3bit }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1377:1, end:1377:2))"]
#[derive(Clone, Debug)]
struct MTCTL_instructionVar54 {
    crname2: TokenField_crname2,
    R1: TableR1,
}
impl MTCTL_instructionVar54 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MTCTL"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.crname2.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 194i128 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let crname2 = token_parser.TokenFieldcrname2();
        let cr = token_parser.TokenFieldcr();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, crname2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1643:1, end:1643:2))"]
#[derive(Clone, Debug)]
struct FCNV_instructionVar55 {
    fpsf: TokenField_fpsf,
    fpdf: TokenField_fpdf,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FCNV_instructionVar55 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNV"),
            self.fpsf.display(),
            self.fpdf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit5().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 0i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpsf = token_parser.TokenFieldfpsf();
        let fpdf = token_parser.TokenFieldfpdf();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        let fptsgl = token_parser.TokenFieldfptsgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1651:1, end:1651:2))"]
#[derive(Clone, Debug)]
struct FCNV_instructionVar56 {
    fpsf: TokenField_fpsf,
    fpdf: TokenField_fpdf,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FCNV_instructionVar56 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNV"),
            self.fpsf.display(),
            self.fpdf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit5().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 1i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpsf = token_parser.TokenFieldfpsf();
        let fpdf = token_parser.TokenFieldfpdf();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        let fptsgl = token_parser.TokenFieldfptsgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1385:1, end:1385:2))"]
#[derive(Clone, Debug)]
struct MFSP_instructionVar57 {
    RT: TableRT,
    SR3bit: TableSR3bit,
}
impl MFSP_instructionVar57 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MFSP"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.SR3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 37i128 {
            return None;
        }
        if token_parser.TokenFieldreg1().disassembly() != 0i128 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, SR3bit }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1389:1, end:1389:2))"]
#[derive(Clone, Debug)]
struct MFCTL_instructionVar58 {
    crname2: TokenField_crname2,
    RT: TableRT,
}
impl MFCTL_instructionVar58 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MFCTL"),
            DisplayElement::Literal(" "),
            self.crname2.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 69i128 {
            return None;
        }
        if token_parser.TokenFieldreg1().disassembly() != 0i128 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let crname2 = token_parser.TokenFieldcrname2();
        let cr = token_parser.TokenFieldcr();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, crname2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1394:1, end:1394:2))"]
#[derive(Clone, Debug)]
struct MFIA_instructionVar59 {
    RT: TableRT,
}
impl MFIA_instructionVar59 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MFIA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 165i128 {
            return None;
        }
        if token_parser.TokenFieldreg1().disassembly() != 0i128 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1425:1, end:1425:2))"]
#[derive(Clone, Debug)]
struct IITLBA_instructionVar60 {
    SR3bit: TableSR3bit,
    RB: TableRB,
    R1: TableR1,
}
impl IITLBA_instructionVar60 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("IITLBA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",(")];
        display.extend_from_slice(&extend);
        self.SR3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshiftedshort().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i128 {
            return None;
        }
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SR3bit, RB, R1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1427:1, end:1427:2))"]
#[derive(Clone, Debug)]
struct IITLBP_instructionVar61 {
    SR3bit: TableSR3bit,
    RB: TableRB,
    R1: TableR1,
}
impl IITLBP_instructionVar61 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("IITLBP"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",(")];
        display.extend_from_slice(&extend);
        self.SR3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshiftedshort().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i128 {
            return None;
        }
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SR3bit, RB, R1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1125:1, end:1125:2))"]
#[derive(Clone, Debug)]
struct SHRPW_instructionVar62 {
    SEDCondSym: TokenField_SEDCondSym,
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    ShiftCondNullify: TableShiftCondNullify,
    SAR: TableSAR,
}
impl SHRPW_instructionVar62 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("SHRPW"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 52i128 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbits59().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ShiftCondNullify = if let Some((len, table)) =
            TableShiftCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                ShiftCondNullify,
                SAR,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1147:1, end:1147:2))"]
#[derive(Clone, Debug)]
struct EXTRW_instructionVar63 {
    SEDCondSym: TokenField_SEDCondSym,
    R2: TableR2,
    shiftCLen: TableshiftCLen,
    R1dst: TableR1dst,
    ExtrCondNullify: TableExtrCondNullify,
    SAR: TableSAR,
}
impl EXTRW_instructionVar63 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("EXTRW"),
            DisplayElement::Literal(",U"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 52i128 {
            return None;
        }
        if token_parser.TokenFieldbits59().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 4i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ExtrCondNullify = if let Some((len, table)) =
            TableExtrCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                shiftCLen,
                R1dst,
                ExtrCondNullify,
                SAR,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1157:1, end:1157:2))"]
#[derive(Clone, Debug)]
struct EXTRW_instructionVar64 {
    SEDCondSym: TokenField_SEDCondSym,
    R2: TableR2,
    shiftCLen: TableshiftCLen,
    R1dst: TableR1dst,
    ExtrCondNullify: TableExtrCondNullify,
    SAR: TableSAR,
}
impl EXTRW_instructionVar64 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("EXTRW"),
            DisplayElement::Literal(",S"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 52i128 {
            return None;
        }
        if token_parser.TokenFieldbits59().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 5i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ExtrCondNullify = if let Some((len, table)) =
            TableExtrCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                shiftCLen,
                R1dst,
                ExtrCondNullify,
                SAR,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1187:1, end:1187:2))"]
#[derive(Clone, Debug)]
struct DEPW_instructionVar65 {
    SEDCondSym: TokenField_SEDCondSym,
    R1: TableR1,
    R2: TableR2,
    R2dst: TableR2dst,
    shiftCLen: TableshiftCLen,
    DepCondNullify: TableDepCondNullify,
    SAR: TableSAR,
}
impl DEPW_instructionVar65 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("DEPW"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 53i128 {
            return None;
        }
        if token_parser.TokenFieldbits59().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 1i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                R2dst,
                shiftCLen,
                DepCondNullify,
                SAR,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1214:1, end:1214:2))"]
#[derive(Clone, Debug)]
struct DEPWI_instructionVar66 {
    SEDCondSym: TokenField_SEDCondSym,
    shiftCLen: TableshiftCLen,
    highlse5: Tablehighlse5,
    R2: TableR2,
    R2dst: TableR2dst,
    DepCondNullify: TableDepCondNullify,
    SAR: TableSAR,
}
impl DEPWI_instructionVar66 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("DEPWI"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 53i128 {
            return None;
        }
        if token_parser.TokenFieldbits59().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 5i128 {
            return None;
        }
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shiftCLen,
                highlse5,
                R2,
                R2dst,
                DepCondNullify,
                SAR,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1243:1, end:1243:2))"]
#[derive(Clone, Debug)]
struct DEPW_instructionVar67 {
    SEDCondSym: TokenField_SEDCondSym,
    R1: TableR1,
    shiftCLen: TableshiftCLen,
    R2: TableR2,
    R2dst: TableR2dst,
    DepCondNullify: TableDepCondNullify,
    SAR: TableSAR,
}
impl DEPW_instructionVar67 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("DEPW"),
            DisplayElement::Literal(",Z"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 53i128 {
            return None;
        }
        if token_parser.TokenFieldbits59().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                shiftCLen,
                R2,
                R2dst,
                DepCondNullify,
                SAR,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1263:1, end:1263:2))"]
#[derive(Clone, Debug)]
struct DEPWI_instructionVar68 {
    SEDCondSym: TokenField_SEDCondSym,
    SAR: TableSAR,
    shiftCLen: TableshiftCLen,
    highlse5: Tablehighlse5,
    R2dst: TableR2dst,
    DepCondNullify: TableDepCondNullify,
}
impl DEPWI_instructionVar68 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("DEPWI"),
            DisplayElement::Literal(",Z"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 53i128 {
            return None;
        }
        if token_parser.TokenFieldbits59().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 4i128 {
            return None;
        }
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SAR,
                shiftCLen,
                highlse5,
                R2dst,
                DepCondNullify,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1294:1, end:1294:2))"]
#[derive(Clone, Debug)]
struct BREAK_instructionVar69 {
    im5: TokenField_im5,
    im13: TokenField_im13,
}
impl BREAK_instructionVar69 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("BREAK"),
            DisplayElement::Literal(" "),
            self.im5.display(),
            DisplayElement::Literal(","),
            self.im13.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 0i128 {
            return None;
        }
        let im5 = token_parser.TokenFieldim5();
        let im13 = token_parser.TokenFieldim13();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { im5, im13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1437:1, end:1437:2))"]
#[derive(Clone, Debug)]
struct FIC_instructionVar70 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    SR3bit: TableSR3bit,
    RB: TableRB,
}
impl FIC_instructionVar70 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("FIC")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.SR3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshiftedshort().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                SR3bit,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1438:1, end:1438:2))"]
#[derive(Clone, Debug)]
struct FIC_instructionVar71 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    SR3bit: TableSR3bit,
    RB: TableRB,
}
impl FIC_instructionVar71 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("FIC")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.SR3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshiftedshort().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                SR3bit,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1443:1, end:1443:2))"]
#[derive(Clone, Debug)]
struct FICE_instructionVar72 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    SR3bit: TableSR3bit,
    RB: TableRB,
}
impl FICE_instructionVar72 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FICE")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.SR3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshiftedshort().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                SR3bit,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1444:1, end:1444:2))"]
#[derive(Clone, Debug)]
struct FICE_instructionVar73 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    SR3bit: TableSR3bit,
    RB: TableRB,
}
impl FICE_instructionVar73 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FICE")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.SR3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsysopshiftedshort().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                SR3bit,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1587:1, end:1587:2))"]
#[derive(Clone, Debug)]
struct FLDD_instructionVar74 {
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    FPRT64: TableFPRT64,
    highlse5: Tablehighlse5,
}
impl FLDD_instructionVar74 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDD")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldbit6().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                loadCC,
                SRRB,
                SPCBASE,
                FPRT64,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1621:1, end:1621:2))"]
#[derive(Clone, Debug)]
struct FSTD_instructionVar75 {
    shortDispCmplt: TableshortDispCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    FPRT64: TableFPRT64,
    highlse5: Tablehighlse5,
}
impl FSTD_instructionVar75 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTD")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldbit6().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                storeCC,
                SRRB,
                SPCBASE,
                FPRT64,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1686:1, end:1686:2))"]
#[derive(Clone, Debug)]
struct FCNVFX_instructionVar76 {
    fpsf: TokenField_fpsf,
    fixeddf: TokenField_fixeddf,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FCNVFX_instructionVar76 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNVFX"),
            self.fpsf.display(),
            self.fixeddf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 1i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpsf = token_parser.TokenFieldfpsf();
        let fixeddf = token_parser.TokenFieldfixeddf();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpsf,
                fixeddf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1692:1, end:1692:2))"]
#[derive(Clone, Debug)]
struct FCNVFX_instructionVar77 {
    fpsf: TokenField_fpsf,
    fixeddf: TokenField_fixeddf,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FCNVFX_instructionVar77 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNVFX"),
            self.fpsf.display(),
            self.fixeddf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 0i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpsf = token_parser.TokenFieldfpsf();
        let fixeddf = token_parser.TokenFieldfixeddf();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpsf,
                fixeddf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1702:1, end:1702:2))"]
#[derive(Clone, Debug)]
struct FCNVFXT_instructionVar78 {
    fpsf: TokenField_fpsf,
    fixeddf: TokenField_fixeddf,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FCNVFXT_instructionVar78 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNVFXT"),
            self.fpsf.display(),
            self.fixeddf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 1i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpsf = token_parser.TokenFieldfpsf();
        let fixeddf = token_parser.TokenFieldfixeddf();
        let fpsfraw = token_parser.TokenFieldfpsfraw();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpsf,
                fixeddf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1707:1, end:1707:2))"]
#[derive(Clone, Debug)]
struct FCNVFXT_instructionVar79 {
    fpsf: TokenField_fpsf,
    fixeddf: TokenField_fixeddf,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FCNVFXT_instructionVar79 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNVFXT"),
            self.fpsf.display(),
            self.fixeddf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 0i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpsf = token_parser.TokenFieldfpsf();
        let fixeddf = token_parser.TokenFieldfixeddf();
        let fpsfraw = token_parser.TokenFieldfpsfraw();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpsf,
                fixeddf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:62:1, end:62:2))"]
#[derive(Clone, Debug)]
struct LDW_instructionVar80 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    loadCC: TableloadCC,
    RX: TableRX,
    RT: TableRT,
    SRRB: TableSRRB,
}
impl LDW_instructionVar80 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("LDW")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                loadCC,
                RX,
                RT,
                SRRB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:68:1, end:68:2))"]
#[derive(Clone, Debug)]
struct LDH_instructionVar81 {
    indexedHalfwordAccessCmplt: TableindexedHalfwordAccessCmplt,
    loadCC: TableloadCC,
    RX: TableRX,
    SRRB: TableSRRB,
    RT: TableRT,
}
impl LDH_instructionVar81 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("LDH")];
        display.extend_from_slice(&extend);
        self.indexedHalfwordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        let indexedHalfwordAccessCmplt = if let Some((len, table)) =
            TableindexedHalfwordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedHalfwordAccessCmplt,
                loadCC,
                RX,
                SRRB,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:74:1, end:74:2))"]
#[derive(Clone, Debug)]
struct LDB_instructionVar82 {
    indexedByteAccessCmplt: TableindexedByteAccessCmplt,
    loadCC: TableloadCC,
    RX: TableRX,
    SRRB: TableSRRB,
    RT: TableRT,
}
impl LDB_instructionVar82 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("LDB")];
        display.extend_from_slice(&extend);
        self.indexedByteAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        let indexedByteAccessCmplt = if let Some((len, table)) =
            TableindexedByteAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedByteAccessCmplt,
                loadCC,
                RX,
                SRRB,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:85:1, end:85:2))"]
#[derive(Clone, Debug)]
struct LDCWX_instructionVar83 {
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    loadClearCC: TableloadClearCC,
    RX: TableRX,
    SRRB: TableSRRB,
    RT: TableRT,
}
impl LDCWX_instructionVar83 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("LDCWX")];
        display.extend_from_slice(&extend);
        self.indexedDoublewordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadClearCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadClearCC = if let Some((len, table)) = TableloadClearCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedDoublewordAccessCmplt,
                loadClearCC,
                RX,
                SRRB,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:92:1, end:92:2))"]
#[derive(Clone, Debug)]
struct LDW_instructionVar84 {
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    highlse5: Tablehighlse5,
    SRRB: TableSRRB,
    RT: TableRT,
}
impl LDW_instructionVar84 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("LDW")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                loadCC,
                highlse5,
                SRRB,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:98:1, end:98:2))"]
#[derive(Clone, Debug)]
struct LDH_instructionVar85 {
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    highlse5: Tablehighlse5,
    SRRB: TableSRRB,
    RT: TableRT,
}
impl LDH_instructionVar85 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("LDH")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                loadCC,
                highlse5,
                SRRB,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:104:1, end:104:2))"]
#[derive(Clone, Debug)]
struct LDB_instructionVar86 {
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    highlse5: Tablehighlse5,
    SRRB: TableSRRB,
    RT: TableRT,
}
impl LDB_instructionVar86 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("LDB")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                loadCC,
                highlse5,
                SRRB,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:110:1, end:110:2))"]
#[derive(Clone, Debug)]
struct STW_instructionVar87 {
    storeShortDispCmplt: TablestoreShortDispCmplt,
    storeCC: TablestoreCC,
    lse5: Tablelse5,
    SRRB: TableSRRB,
    RR: TableRR,
}
impl STW_instructionVar87 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("STW")];
        display.extend_from_slice(&extend);
        self.storeShortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.lse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        let storeShortDispCmplt = if let Some((len, table)) =
            TablestoreShortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                storeShortDispCmplt,
                storeCC,
                lse5,
                SRRB,
                RR,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:116:1, end:116:2))"]
#[derive(Clone, Debug)]
struct STH_instructionVar88 {
    storeShortDispCmplt: TablestoreShortDispCmplt,
    storeCC: TablestoreCC,
    lse5: Tablelse5,
    SRRB: TableSRRB,
    RR: TableRR,
}
impl STH_instructionVar88 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("STH")];
        display.extend_from_slice(&extend);
        self.storeShortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.lse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        let storeShortDispCmplt = if let Some((len, table)) =
            TablestoreShortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                storeShortDispCmplt,
                storeCC,
                lse5,
                SRRB,
                RR,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:122:1, end:122:2))"]
#[derive(Clone, Debug)]
struct STB_instructionVar89 {
    storeShortDispCmplt: TablestoreShortDispCmplt,
    storeCC: TablestoreCC,
    lse5: Tablelse5,
    SRRB: TableSRRB,
    RR: TableRR,
}
impl STB_instructionVar89 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("STB")];
        display.extend_from_slice(&extend);
        self.storeShortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.lse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        let storeShortDispCmplt = if let Some((len, table)) =
            TablestoreShortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                storeShortDispCmplt,
                storeCC,
                lse5,
                SRRB,
                RR,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:127:1, end:127:2))"]
#[derive(Clone, Debug)]
struct LDWAS_instructionVar90 {
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    highlse5: Tablehighlse5,
    RB: TableRB,
    RT: TableRT,
}
impl LDWAS_instructionVar90 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("LDWAS")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("),")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                loadCC,
                highlse5,
                RB,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:132:1, end:132:2))"]
#[derive(Clone, Debug)]
struct LDCWS_instructionVar91 {
    shortDispCmplt: TableshortDispCmplt,
    loadClearCC: TableloadClearCC,
    highlse5: Tablehighlse5,
    SRRB: TableSRRB,
    RT: TableRT,
}
impl LDCWS_instructionVar91 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("LDCWS")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadClearCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadClearCC = if let Some((len, table)) = TableloadClearCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                loadClearCC,
                highlse5,
                SRRB,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:138:1, end:138:2))"]
#[derive(Clone, Debug)]
struct STWAS_instructionVar92 {
    shortDispCmplt: TableshortDispCmplt,
    storeCC: TablestoreCC,
    lse5: Tablelse5,
    RB: TableRB,
    RR: TableRR,
}
impl STWAS_instructionVar92 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("STWAS")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.lse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                storeCC,
                lse5,
                RB,
                RR,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:247:1, end:247:2))"]
#[derive(Clone, Debug)]
struct B_instructionVar93 {
    nullifyForBranch: TablenullifyForBranch,
    branchTarget3W: TablebranchTarget3W,
}
impl B_instructionVar93 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("B")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.branchTarget3W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i128 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldreg2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget3W = if let Some((len, table)) =
            TablebranchTarget3W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifyForBranch,
                branchTarget3W,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:264:1, end:264:2))"]
#[derive(Clone, Debug)]
struct B_instructionVar94 {
    nullifySymForBranch: TablenullifySymForBranch,
    branchTarget3W: TablebranchTarget3W,
}
impl B_instructionVar94 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("B")];
        display.extend_from_slice(&extend);
        self.nullifySymForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.branchTarget3W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i128 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldreg2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let nullifySymForBranch = if let Some((len, table)) =
            TablenullifySymForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget3W = if let Some((len, table)) =
            TablebranchTarget3W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifySymForBranch,
                branchTarget3W,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:197:1, end:197:2))"]
#[derive(Clone, Debug)]
struct LDI_instructionVar95 {
    lse14: Tablelse14,
    R1dst: TableR1dst,
}
impl LDI_instructionVar95 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDI"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldb().disassembly() != 0i128 {
            return None;
        }
        let lse14 = if let Some((len, table)) =
            Tablelse14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse14, R1dst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:430:1, end:430:2))"]
#[derive(Clone, Debug)]
struct BV_instructionVar96 {
    RB: TableRB,
    nullifyForBranch: TablenullifyForBranch,
    ReturnTarget: TableReturnTarget,
}
impl BV_instructionVar96 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchIsReturn(
            Some(inst_next),
            context
                .register()
                .read_branchIsReturn_disassembly()
                .unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("BV")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(" "), DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i128 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldreg1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit0().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ReturnTarget = if let Some((len, table)) = TableReturnTarget::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                nullifyForBranch,
                ReturnTarget,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:447:1, end:447:2))"]
#[derive(Clone, Debug)]
struct BV_instructionVar97 {
    RB: TableRB,
    nullifyForBranch: TablenullifyForBranch,
    ReturnTarget: TableReturnTarget,
}
impl BV_instructionVar97 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("BV")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(" "), DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i128 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldreg1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit0().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ReturnTarget = if let Some((len, table)) = TableReturnTarget::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                nullifyForBranch,
                ReturnTarget,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:409:1, end:409:2))"]
#[derive(Clone, Debug)]
struct BV_instructionVar98 {
    RB: TableRB,
    nullifyForBranch: TablenullifyForBranch,
    RX: TableRX,
    IndexedTarget: TableIndexedTarget,
}
impl BV_instructionVar98 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("BV")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i128 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldbit0().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let IndexedTarget = if let Some((len, table)) =
            TableIndexedTarget::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                nullifyForBranch,
                RX,
                IndexedTarget,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:423:1, end:423:2))"]
#[derive(Clone, Debug)]
struct BV_instructionVar99 {
    RB: TableRB,
    nullifySymForBranch: TablenullifySymForBranch,
    RX: TableRX,
    IndexedTarget: TableIndexedTarget,
}
impl BV_instructionVar99 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("BV")];
        display.extend_from_slice(&extend);
        self.nullifySymForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i128 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldbit0().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifySymForBranch = if let Some((len, table)) =
            TablenullifySymForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let IndexedTarget = if let Some((len, table)) =
            TableIndexedTarget::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                nullifySymForBranch,
                RX,
                IndexedTarget,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:219:1, end:219:2))"]
#[derive(Clone, Debug)]
struct B_instructionVar100 {
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget3W: TablebranchTarget3W,
}
impl B_instructionVar100 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("B"), DisplayElement::Literal(",L")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.branchTarget3W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i128 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget3W = if let Some((len, table)) =
            TablebranchTarget3W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                nullifyForBranch,
                branchTarget3W,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:235:1, end:235:2))"]
#[derive(Clone, Debug)]
struct B_instructionVar101 {
    R2dst: TableR2dst,
    nullifySymForBranch: TablenullifySymForBranch,
    branchTarget3W: TablebranchTarget3W,
}
impl B_instructionVar101 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("B"), DisplayElement::Literal(",L")];
        display.extend_from_slice(&extend);
        self.nullifySymForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.branchTarget3W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i128 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifySymForBranch = if let Some((len, table)) =
            TablenullifySymForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget3W = if let Some((len, table)) =
            TablebranchTarget3W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                nullifySymForBranch,
                branchTarget3W,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:387:1, end:387:2))"]
#[derive(Clone, Debug)]
struct BLR_instructionVar102 {
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    RR: TableRR,
    IPRelativeIndexedTarget: TableIPRelativeIndexedTarget,
}
impl BLR_instructionVar102 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("BLR")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i128 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let IPRelativeIndexedTarget = if let Some((len, table)) =
            TableIPRelativeIndexedTarget::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                nullifyForBranch,
                RR,
                IPRelativeIndexedTarget,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:402:1, end:402:2))"]
#[derive(Clone, Debug)]
struct BLR_instructionVar103 {
    R2dst: TableR2dst,
    nullifySymForBranch: TablenullifySymForBranch,
    RR: TableRR,
    IPRelativeIndexedTarget: TableIPRelativeIndexedTarget,
}
impl BLR_instructionVar103 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("BLR")];
        display.extend_from_slice(&extend);
        self.nullifySymForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i128 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifySymForBranch = if let Some((len, table)) =
            TablenullifySymForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let IPRelativeIndexedTarget = if let Some((len, table)) =
            TableIPRelativeIndexedTarget::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                nullifySymForBranch,
                RR,
                IPRelativeIndexedTarget,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:762:1, end:762:2))"]
#[derive(Clone, Debug)]
struct B_instructionVar104 {
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget3W: TablebranchTarget3W,
}
impl B_instructionVar104 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("B"),
            DisplayElement::Literal(",GATE"),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.branchTarget3W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i128 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget3W = if let Some((len, table)) =
            TablebranchTarget3W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                nullifyForBranch,
                branchTarget3W,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:776:1, end:776:2))"]
#[derive(Clone, Debug)]
struct B_instructionVar105 {
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget3W: TablebranchTarget3W,
}
impl B_instructionVar105 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("B"),
            DisplayElement::Literal(",GATE"),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.branchTarget3W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i128 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget3W = if let Some((len, table)) =
            TablebranchTarget3W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                nullifyForBranch,
                branchTarget3W,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:272:1, end:272:2))"]
#[derive(Clone, Debug)]
struct CMPBT_instructionVar106 {
    RegCSCondSym: TokenField_RegCSCondSym,
    R1: TableR1,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    RegCSCond: TableRegCSCond,
}
impl CMPBT_instructionVar106 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPBT"),
            self.RegCSCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 32i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCond = if let Some((len, table)) = TableRegCSCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_parser.TokenFieldRegCSCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                nullifyForBranch,
                branchTarget2W,
                RegCSCond,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:285:2, end:285:3))"]
#[derive(Clone, Debug)]
struct CMPBT_instructionVar107 {
    RegCSCondSym: TokenField_RegCSCondSym,
    R1: TableR1,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    RegCSCond: TableRegCSCond,
}
impl CMPBT_instructionVar107 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPBT"),
            self.RegCSCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 32i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCond = if let Some((len, table)) = TableRegCSCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_parser.TokenFieldRegCSCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                nullifyForBranch,
                branchTarget2W,
                displacement2W,
                RegCSCond,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:299:1, end:299:2))"]
#[derive(Clone, Debug)]
struct CMPBF_instructionVar108 {
    RegCSCondSym: TokenField_RegCSCondSym,
    R1: TableR1,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    RegCSCond: TableRegCSCond,
}
impl CMPBF_instructionVar108 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPBF"),
            self.RegCSCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 34i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCond = if let Some((len, table)) = TableRegCSCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_parser.TokenFieldRegCSCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                nullifyForBranch,
                branchTarget2W,
                RegCSCond,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:312:1, end:312:2))"]
#[derive(Clone, Debug)]
struct CMPBF_instructionVar109 {
    RegCSCondSym: TokenField_RegCSCondSym,
    R1: TableR1,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    RegCSCond: TableRegCSCond,
}
impl CMPBF_instructionVar109 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPBF"),
            self.RegCSCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 34i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCond = if let Some((len, table)) = TableRegCSCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_parser.TokenFieldRegCSCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                nullifyForBranch,
                branchTarget2W,
                displacement2W,
                RegCSCond,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:329:1, end:329:2))"]
#[derive(Clone, Debug)]
struct CMPIBT_instructionVar110 {
    RegCSCondSym: TokenField_RegCSCondSym,
    highlse5: Tablehighlse5,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    RegCSCondI: TableRegCSCondI,
}
impl CMPIBT_instructionVar110 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPIBT"),
            self.RegCSCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 33i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondI = if let Some((len, table)) = TableRegCSCondI::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_parser.TokenFieldRegCSCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                highlse5,
                R2,
                nullifyForBranch,
                branchTarget2W,
                RegCSCondI,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:342:1, end:342:2))"]
#[derive(Clone, Debug)]
struct CMPIBT_instructionVar111 {
    RegCSCondSym: TokenField_RegCSCondSym,
    highlse5: Tablehighlse5,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    RegCSCondI: TableRegCSCondI,
}
impl CMPIBT_instructionVar111 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPIBT"),
            self.RegCSCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 33i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondI = if let Some((len, table)) = TableRegCSCondI::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_parser.TokenFieldRegCSCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                highlse5,
                R2,
                nullifyForBranch,
                branchTarget2W,
                displacement2W,
                RegCSCondI,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:356:1, end:356:2))"]
#[derive(Clone, Debug)]
struct CMPIBF_instructionVar112 {
    RegCSCondSym: TokenField_RegCSCondSym,
    highlse5: Tablehighlse5,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    RegCSCondI: TableRegCSCondI,
}
impl CMPIBF_instructionVar112 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPIBF"),
            self.RegCSCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 35i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondI = if let Some((len, table)) = TableRegCSCondI::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_parser.TokenFieldRegCSCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                highlse5,
                R2,
                nullifyForBranch,
                branchTarget2W,
                RegCSCondI,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:369:1, end:369:2))"]
#[derive(Clone, Debug)]
struct CMPIBF_instructionVar113 {
    RegCSCondSym: TokenField_RegCSCondSym,
    highlse5: Tablehighlse5,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    RegCSCondI: TableRegCSCondI,
}
impl CMPIBF_instructionVar113 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPIBF"),
            self.RegCSCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 35i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondI = if let Some((len, table)) = TableRegCSCondI::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_parser.TokenFieldRegCSCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                highlse5,
                R2,
                nullifyForBranch,
                branchTarget2W,
                displacement2W,
                RegCSCondI,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:456:1, end:456:2))"]
#[derive(Clone, Debug)]
struct MOVB_instructionVar114 {
    SEDCondSym: TokenField_SEDCondSym,
    R2dst: TableR2dst,
    R1: TableR1,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    DepCond: TableDepCond,
}
impl MOVB_instructionVar114 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOVB"), self.SEDCondSym.display()];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 50i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCond = if let Some((len, table)) = TableDepCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                R1,
                nullifyForBranch,
                branchTarget2W,
                DepCond,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:472:1, end:472:2))"]
#[derive(Clone, Debug)]
struct MOVB_instructionVar115 {
    SEDCondSym: TokenField_SEDCondSym,
    R2dst: TableR2dst,
    R1: TableR1,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    DepCond: TableDepCond,
}
impl MOVB_instructionVar115 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOVB"), self.SEDCondSym.display()];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 50i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCond = if let Some((len, table)) = TableDepCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                R1,
                nullifyForBranch,
                branchTarget2W,
                displacement2W,
                DepCond,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:493:1, end:493:2))"]
#[derive(Clone, Debug)]
struct MOVIB_instructionVar116 {
    SEDCondSym: TokenField_SEDCondSym,
    im5: TokenField_im5,
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    DepCond: TableDepCond,
}
impl MOVIB_instructionVar116 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOVIB"), self.SEDCondSym.display()];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.im5.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 51i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCond = if let Some((len, table)) = TableDepCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let im5 = token_parser.TokenFieldim5();
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                nullifyForBranch,
                branchTarget2W,
                DepCond,
                im5,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:509:1, end:509:2))"]
#[derive(Clone, Debug)]
struct MOVIB_instructionVar117 {
    SEDCondSym: TokenField_SEDCondSym,
    im5: TokenField_im5,
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    DepCond: TableDepCond,
}
impl MOVIB_instructionVar117 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOVIB"), self.SEDCondSym.display()];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.im5.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 51i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCond = if let Some((len, table)) = TableDepCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let im5 = token_parser.TokenFieldim5();
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                nullifyForBranch,
                branchTarget2W,
                displacement2W,
                DepCond,
                im5,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:527:1, end:527:2))"]
#[derive(Clone, Debug)]
struct ADDBT_instructionVar118 {
    RegAddCondSym: TokenField_RegAddCondSym,
    R1: TableR1,
    R2dst: TableR2dst,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    RegAddCond: TableRegAddCond,
}
impl ADDBT_instructionVar118 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDBT"),
            self.RegAddCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 40i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCond = if let Some((len, table)) = TableRegAddCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_parser.TokenFieldRegAddCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2dst,
                R2,
                nullifyForBranch,
                branchTarget2W,
                RegAddCond,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:542:1, end:542:2))"]
#[derive(Clone, Debug)]
struct ADDBT_instructionVar119 {
    RegAddCondSym: TokenField_RegAddCondSym,
    R1: TableR1,
    R2dst: TableR2dst,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    RegAddCond: TableRegAddCond,
}
impl ADDBT_instructionVar119 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDBT"),
            self.RegAddCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 40i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCond = if let Some((len, table)) = TableRegAddCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_parser.TokenFieldRegAddCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2dst,
                R2,
                nullifyForBranch,
                branchTarget2W,
                displacement2W,
                RegAddCond,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:560:1, end:560:2))"]
#[derive(Clone, Debug)]
struct ADDBF_instructionVar120 {
    RegAddCondSym: TokenField_RegAddCondSym,
    R1: TableR1,
    R2dst: TableR2dst,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    RegAddCond: TableRegAddCond,
}
impl ADDBF_instructionVar120 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDBF"),
            self.RegAddCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 42i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCond = if let Some((len, table)) = TableRegAddCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_parser.TokenFieldRegAddCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2dst,
                R2,
                nullifyForBranch,
                branchTarget2W,
                RegAddCond,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:575:1, end:575:2))"]
#[derive(Clone, Debug)]
struct ADDBF_instructionVar121 {
    RegAddCondSym: TokenField_RegAddCondSym,
    R1: TableR1,
    R2: TableR2,
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    RegAddCond: TableRegAddCond,
}
impl ADDBF_instructionVar121 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDBF"),
            self.RegAddCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 42i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCond = if let Some((len, table)) = TableRegAddCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_parser.TokenFieldRegAddCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                R2dst,
                nullifyForBranch,
                branchTarget2W,
                displacement2W,
                RegAddCond,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:592:1, end:592:2))"]
#[derive(Clone, Debug)]
struct ADDIBT_instructionVar122 {
    RegAddCondSym: TokenField_RegAddCondSym,
    highlse5: Tablehighlse5,
    R2: TableR2,
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    RegAddCondI: TableRegAddCondI,
}
impl ADDIBT_instructionVar122 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDIBT"),
            self.RegAddCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 41i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondI = if let Some((len, table)) = TableRegAddCondI::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_parser.TokenFieldRegAddCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                highlse5,
                R2,
                R2dst,
                nullifyForBranch,
                branchTarget2W,
                RegAddCondI,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:607:1, end:607:2))"]
#[derive(Clone, Debug)]
struct ADDIBT_instructionVar123 {
    RegAddCondSym: TokenField_RegAddCondSym,
    highlse5: Tablehighlse5,
    R2: TableR2,
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    RegAddCondI: TableRegAddCondI,
}
impl ADDIBT_instructionVar123 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDIBT"),
            self.RegAddCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 41i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondI = if let Some((len, table)) = TableRegAddCondI::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_parser.TokenFieldRegAddCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                highlse5,
                R2,
                R2dst,
                nullifyForBranch,
                branchTarget2W,
                displacement2W,
                RegAddCondI,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:623:1, end:623:2))"]
#[derive(Clone, Debug)]
struct ADDIBF_instructionVar124 {
    RegAddCondSym: TokenField_RegAddCondSym,
    highlse5: Tablehighlse5,
    R2: TableR2,
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    RegAddCondI: TableRegAddCondI,
}
impl ADDIBF_instructionVar124 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDIBF"),
            self.RegAddCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 43i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondI = if let Some((len, table)) = TableRegAddCondI::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_parser.TokenFieldRegAddCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                highlse5,
                R2,
                R2dst,
                nullifyForBranch,
                branchTarget2W,
                RegAddCondI,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:638:1, end:638:2))"]
#[derive(Clone, Debug)]
struct ADDIBF_instructionVar125 {
    RegAddCondSym: TokenField_RegAddCondSym,
    highlse5: Tablehighlse5,
    R2: TableR2,
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    RegAddCondI: TableRegAddCondI,
}
impl ADDIBF_instructionVar125 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDIBF"),
            self.RegAddCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 43i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondI = if let Some((len, table)) = TableRegAddCondI::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_parser.TokenFieldRegAddCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                highlse5,
                R2,
                R2dst,
                nullifyForBranch,
                branchTarget2W,
                displacement2W,
                RegAddCondI,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:655:1, end:655:2))"]
#[derive(Clone, Debug)]
struct BB_instructionVar126 {
    SEDCondSym: TokenField_SEDCondSym,
    branchTarget2W: TablebranchTarget2W,
    nullifyForBranch: TablenullifyForBranch,
    R1: TableR1,
    BVBCond: TableBVBCond,
    SAR: TableSAR,
}
impl BB_instructionVar126 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BB"), self.SEDCondSym.display()];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 48i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BVBCond = if let Some((len, table)) = TableBVBCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                branchTarget2W,
                nullifyForBranch,
                R1,
                BVBCond,
                SAR,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:668:1, end:668:2))"]
#[derive(Clone, Debug)]
struct BB_instructionVar127 {
    SEDCondSym: TokenField_SEDCondSym,
    branchTarget2W: TablebranchTarget2W,
    nullifyForBranch: TablenullifyForBranch,
    displacement2W: Tabledisplacement2W,
    R1: TableR1,
    BVBCond: TableBVBCond,
    SAR: TableSAR,
}
impl BB_instructionVar127 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BB"), self.SEDCondSym.display()];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 48i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BVBCond = if let Some((len, table)) = TableBVBCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                branchTarget2W,
                nullifyForBranch,
                displacement2W,
                R1,
                BVBCond,
                SAR,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:683:1, end:683:2))"]
#[derive(Clone, Debug)]
struct BB_instructionVar128 {
    SEDCondSym: TokenField_SEDCondSym,
    bboffset: TokenField_bboffset,
    branchTarget2W: TablebranchTarget2W,
    nullifyForBranch: TablenullifyForBranch,
    R1: TableR1,
    BBCond: TableBBCond,
}
impl BB_instructionVar128 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BB"), self.SEDCondSym.display()];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            self.bboffset.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 49i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BBCond = if let Some((len, table)) = TableBBCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        let bboffset = token_parser.TokenFieldbboffset();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                branchTarget2W,
                nullifyForBranch,
                R1,
                BBCond,
                SEDCondSym,
                bboffset,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:696:1, end:696:2))"]
#[derive(Clone, Debug)]
struct BB_instructionVar129 {
    SEDCondSym: TokenField_SEDCondSym,
    bboffset: TokenField_bboffset,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    nullifyForBranch: TablenullifyForBranch,
    R1: TableR1,
    BBCond: TableBBCond,
}
impl BB_instructionVar129 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BB"), self.SEDCondSym.display()];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            self.bboffset.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 49i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BBCond = if let Some((len, table)) = TableBBCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        let bboffset = token_parser.TokenFieldbboffset();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                branchTarget2W,
                displacement2W,
                nullifyForBranch,
                R1,
                BBCond,
                SEDCondSym,
                bboffset,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:716:1, end:716:2))"]
#[derive(Clone, Debug)]
struct BE_instructionVar130 {
    nullifyForBranch: TablenullifyForBranch,
    externalTarget: TableexternalTarget,
    SR3bit: TableSR3bit,
}
impl BE_instructionVar130 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("BE")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.externalTarget.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 56i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let externalTarget = if let Some((len, table)) =
            TableexternalTarget::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifyForBranch,
                externalTarget,
                SR3bit,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:731:1, end:731:2))"]
#[derive(Clone, Debug)]
struct BE_instructionVar131 {
    nullifyForBranch: TablenullifyForBranch,
    externalTarget: TableexternalTarget,
    SR3bit: TableSR3bit,
}
impl BE_instructionVar131 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("BE")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.externalTarget.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 56i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let externalTarget = if let Some((len, table)) =
            TableexternalTarget::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifyForBranch,
                externalTarget,
                SR3bit,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:737:1, end:737:2))"]
#[derive(Clone, Debug)]
struct BE_instructionVar132 {
    nullifyForBranch: TablenullifyForBranch,
    SR0: TableSR0,
    R31: TableR31,
    SR3bit: TableSR3bit,
    externalTarget: TableexternalTarget,
}
impl BE_instructionVar132 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly().unwrap(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly().unwrap(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context
                .register()
                .read_branchCouldBeNullified_disassembly()
                .unwrap(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BE"), DisplayElement::Literal(",L")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.externalTarget.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SR0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R31.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 57i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp)
            .unwrap();
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR0 = if let Some((len, table)) =
            TableSR0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R31 = if let Some((len, table)) =
            TableR31::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let externalTarget = if let Some((len, table)) =
            TableexternalTarget::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifyForBranch,
                SR0,
                R31,
                SR3bit,
                externalTarget,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:754:1, end:754:2))"]
#[derive(Clone, Debug)]
struct BE_instructionVar133 {
    nullifyForBranch: TablenullifyForBranch,
    SR0: TableSR0,
    R31: TableR31,
    SR3bit: TableSR3bit,
    externalTarget: TableexternalTarget,
}
impl BE_instructionVar133 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BE"), DisplayElement::Literal(",L")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.externalTarget.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SR0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R31.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 57i128 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR0 = if let Some((len, table)) =
            TableSR0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R31 = if let Some((len, table)) =
            TableR31::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let externalTarget = if let Some((len, table)) =
            TableexternalTarget::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifyForBranch,
                SR0,
                R31,
                SR3bit,
                externalTarget,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:790:1, end:790:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar134 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
    AddCondSym: TableAddCondSym,
}
impl ADD_instructionVar134 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ADD")];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 24i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondNullify,
                AddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:797:1, end:797:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar135 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
    AddCondSym: TableAddCondSym,
}
impl ADD_instructionVar135 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADD"),
            DisplayElement::Literal(",L"),
        ];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 40i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondNullify,
                AddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:802:1, end:802:2))"]
#[derive(Clone, Debug)]
struct ADDO_instructionVar136 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondSym: TableAddCondSym,
    AddCondNullify: TableAddCondNullify,
}
impl ADDO_instructionVar136 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ADDO")];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 56i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondSym,
                AddCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:813:1, end:813:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar137 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondSym: TableAddCondSym,
    AddCondNullify: TableAddCondNullify,
}
impl ADD_instructionVar137 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADD"),
            DisplayElement::Literal(",C"),
        ];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 28i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondSym,
                AddCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:821:1, end:821:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar138 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondSym: TableAddCondSym,
    AddCondNullify: TableAddCondNullify,
}
impl ADD_instructionVar138 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADD"),
            DisplayElement::Literal(",CO"),
        ];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 60i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondSym,
                AddCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:840:1, end:840:2))"]
#[derive(Clone, Debug)]
struct SH1ADD_instructionVar139 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCond: TableAddCond,
    AddCondSym: TableAddCondSym,
    AddCondNullify: TableAddCondNullify,
}
impl SH1ADD_instructionVar139 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("SH1ADD")];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 25i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCond = if let Some((len, table)) = TableAddCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCond,
                AddCondSym,
                AddCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:847:1, end:847:2))"]
#[derive(Clone, Debug)]
struct SH1ADDL_instructionVar140 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
    AddCondSym: TableAddCondSym,
}
impl SH1ADDL_instructionVar140 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("SH1ADDL")];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 41i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondNullify,
                AddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:853:1, end:853:2))"]
#[derive(Clone, Debug)]
struct SH1ADDO_instructionVar141 {
    SEDCondSym: TokenField_SEDCondSym,
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
}
impl SH1ADDO_instructionVar141 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("SH1ADDO"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 57i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondNullify,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:865:1, end:865:2))"]
#[derive(Clone, Debug)]
struct SH2ADD_instructionVar142 {
    SEDCondSym: TokenField_SEDCondSym,
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
}
impl SH2ADD_instructionVar142 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("SH2ADD"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 26i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondNullify,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:872:1, end:872:2))"]
#[derive(Clone, Debug)]
struct SH2ADDL_instructionVar143 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
    AddCondSym: TableAddCondSym,
}
impl SH2ADDL_instructionVar143 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("SH2ADDL")];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 42i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondNullify,
                AddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:878:1, end:878:2))"]
#[derive(Clone, Debug)]
struct SH2ADDO_instructionVar144 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
    AddCondSym: TableAddCondSym,
}
impl SH2ADDO_instructionVar144 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("SH2ADDO")];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 58i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondNullify,
                AddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:890:1, end:890:2))"]
#[derive(Clone, Debug)]
struct SH3ADD_instructionVar145 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
    AddCondSym: TableAddCondSym,
}
impl SH3ADD_instructionVar145 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("SH3ADD")];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 27i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondNullify,
                AddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:897:1, end:897:2))"]
#[derive(Clone, Debug)]
struct SH3ADDL_instructionVar146 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
    AddCondSym: TableAddCondSym,
}
impl SH3ADDL_instructionVar146 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("SH3ADDL")];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 43i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondNullify,
                AddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:903:1, end:903:2))"]
#[derive(Clone, Debug)]
struct SH3ADDO_instructionVar147 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
    AddCondSym: TableAddCondSym,
}
impl SH3ADDO_instructionVar147 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("SH3ADDO")];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 59i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondNullify,
                AddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:915:1, end:915:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar148 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    CSCondSym: TableCSCondSym,
    CSCondNullify: TableCSCondNullify,
}
impl SUB_instructionVar148 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("SUB")];
        display.extend_from_slice(&extend);
        self.CSCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 16i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) = TableCSCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondNullify = if let Some((len, table)) =
            TableCSCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                CSCondSym,
                CSCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:921:1, end:921:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar149 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    CSCondSym: TableCSCondSym,
    CSCondNullify: TableCSCondNullify,
}
impl SUB_instructionVar149 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUB"),
            DisplayElement::Literal(",O"),
        ];
        display.extend_from_slice(&extend);
        self.CSCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 48i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) = TableCSCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondNullify = if let Some((len, table)) =
            TableCSCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                CSCondSym,
                CSCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:932:1, end:932:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar150 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    CSCondSym: TableCSCondSym,
    CSCondNullify: TableCSCondNullify,
}
impl SUB_instructionVar150 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUB"),
            DisplayElement::Literal(",B"),
        ];
        display.extend_from_slice(&extend);
        self.CSCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 20i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) = TableCSCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondNullify = if let Some((len, table)) =
            TableCSCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                CSCondSym,
                CSCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:939:1, end:939:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar151 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    CSCondSym: TableCSCondSym,
    CSCondNullify: TableCSCondNullify,
}
impl SUB_instructionVar151 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUB"),
            DisplayElement::Literal(",BO"),
        ];
        display.extend_from_slice(&extend);
        self.CSCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 52i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) = TableCSCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondNullify = if let Some((len, table)) =
            TableCSCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                CSCondSym,
                CSCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:953:1, end:953:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar152 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    CSCondSym: TableCSCondSym,
    CSCond: TableCSCond,
}
impl SUB_instructionVar152 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUB"),
            DisplayElement::Literal(",T"),
        ];
        display.extend_from_slice(&extend);
        self.CSCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 19i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) = TableCSCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCond = if let Some((len, table)) = TableCSCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                CSCondSym,
                CSCond,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:964:1, end:964:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar153 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    CSCondSym: TableCSCondSym,
    CSCond: TableCSCond,
}
impl SUB_instructionVar153 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUB"),
            DisplayElement::Literal(",TO"),
        ];
        display.extend_from_slice(&extend);
        self.CSCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 51i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) = TableCSCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCond = if let Some((len, table)) = TableCSCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                CSCondSym,
                CSCond,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:977:1, end:977:2))"]
#[derive(Clone, Debug)]
struct DS_instructionVar154 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    CSCondSym: TableCSCondSym,
    CSCondNullify: TableCSCondNullify,
}
impl DS_instructionVar154 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("DS")];
        display.extend_from_slice(&extend);
        self.CSCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 17i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) = TableCSCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondNullify = if let Some((len, table)) =
            TableCSCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                CSCondSym,
                CSCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1000:1, end:1000:2))"]
#[derive(Clone, Debug)]
struct CMPCLR_instructionVar155 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    CSCondSym: TableCSCondSym,
    CSCondNullify: TableCSCondNullify,
}
impl CMPCLR_instructionVar155 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("CMPCLR")];
        display.extend_from_slice(&extend);
        self.CSCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 34i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) = TableCSCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondNullify = if let Some((len, table)) =
            TableCSCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                CSCondSym,
                CSCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1014:1, end:1014:2))"]
#[derive(Clone, Debug)]
struct OR_instructionVar156 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    LogicCondSym: TableLogicCondSym,
    LogicCondNullify: TableLogicCondNullify,
}
impl OR_instructionVar156 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("OR")];
        display.extend_from_slice(&extend);
        self.LogicCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let LogicCondSym = if let Some((len, table)) = TableLogicCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let LogicCondNullify = if let Some((len, table)) =
            TableLogicCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                LogicCondSym,
                LogicCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1019:1, end:1019:2))"]
#[derive(Clone, Debug)]
struct XOR_instructionVar157 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    LogicCondSym: TableLogicCondSym,
    LogicCondNullify: TableLogicCondNullify,
}
impl XOR_instructionVar157 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("XOR")];
        display.extend_from_slice(&extend);
        self.LogicCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let LogicCondSym = if let Some((len, table)) = TableLogicCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let LogicCondNullify = if let Some((len, table)) =
            TableLogicCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                LogicCondSym,
                LogicCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1024:1, end:1024:2))"]
#[derive(Clone, Debug)]
struct AND_instructionVar158 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    LogicCondSym: TableLogicCondSym,
    LogicCondNullify: TableLogicCondNullify,
}
impl AND_instructionVar158 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("AND")];
        display.extend_from_slice(&extend);
        self.LogicCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let LogicCondSym = if let Some((len, table)) = TableLogicCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let LogicCondNullify = if let Some((len, table)) =
            TableLogicCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                LogicCondSym,
                LogicCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1029:1, end:1029:2))"]
#[derive(Clone, Debug)]
struct ANDCM_instructionVar159 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    LogicCondSym: TableLogicCondSym,
    LogicCondNullify: TableLogicCondNullify,
}
impl ANDCM_instructionVar159 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ANDCM")];
        display.extend_from_slice(&extend);
        self.LogicCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let LogicCondSym = if let Some((len, table)) = TableLogicCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let LogicCondNullify = if let Some((len, table)) =
            TableLogicCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                LogicCondSym,
                LogicCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1034:1, end:1034:2))"]
#[derive(Clone, Debug)]
struct UXOR_instructionVar160 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    UnitCondSym: TableUnitCondSym,
    UnitCondNullify: TableUnitCondNullify,
}
impl UXOR_instructionVar160 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("UXOR")];
        display.extend_from_slice(&extend);
        self.UnitCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UnitCondSym = if let Some((len, table)) = TableUnitCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UnitCondNullify = if let Some((len, table)) =
            TableUnitCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                UnitCondSym,
                UnitCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1039:1, end:1039:2))"]
#[derive(Clone, Debug)]
struct UADDCM_instructionVar161 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    UnitCondSym: TableUnitCondSym,
    UnitCondNullify: TableUnitCondNullify,
}
impl UADDCM_instructionVar161 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("UADDCM")];
        display.extend_from_slice(&extend);
        self.UnitCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 38i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UnitCondSym = if let Some((len, table)) = TableUnitCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UnitCondNullify = if let Some((len, table)) =
            TableUnitCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                UnitCondSym,
                UnitCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1045:1, end:1045:2))"]
#[derive(Clone, Debug)]
struct UADDCMT_instructionVar162 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    UnitCond: TableUnitCond,
    UnitCondSym: TableUnitCondSym,
}
impl UADDCMT_instructionVar162 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("UADDCMT")];
        display.extend_from_slice(&extend);
        self.UnitCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 39i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UnitCond = if let Some((len, table)) = TableUnitCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UnitCondSym = if let Some((len, table)) = TableUnitCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                UnitCond,
                UnitCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1717:1, end:1717:2))"]
#[derive(Clone, Debug)]
struct FCPY_instructionVar163 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FCPY_instructionVar163 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FCPY"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldfreg1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 1i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1721:1, end:1721:2))"]
#[derive(Clone, Debug)]
struct FCPY_instructionVar164 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FCPY_instructionVar164 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FCPY"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldfreg1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 0i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1776:1, end:1776:2))"]
#[derive(Clone, Debug)]
struct FMPY_instructionVar165 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
    FPR164: TableFPR164,
}
impl FMPY_instructionVar165 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FMPY"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldbit8().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 0i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg1sgl = token_parser.TokenFieldfreg1sgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                FPR164,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1780:1, end:1780:2))"]
#[derive(Clone, Debug)]
struct FMPY_instructionVar166 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
    FPR164: TableFPR164,
}
impl FMPY_instructionVar166 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FMPY"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldbit8().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 1i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg1sgl = token_parser.TokenFieldfreg1sgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                FPR164,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1752:1, end:1752:2))"]
#[derive(Clone, Debug)]
struct FADD_instructionVar167 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
    FPR164: TableFPR164,
}
impl FADD_instructionVar167 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FADD"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 0i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        let freg1sgl = token_parser.TokenFieldfreg1sgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        let fptsgl = token_parser.TokenFieldfptsgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                FPR164,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1756:1, end:1756:2))"]
#[derive(Clone, Debug)]
struct FADD_instructionVar168 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
    FPR164: TableFPR164,
}
impl FADD_instructionVar168 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FADD"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 1i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        let freg1sgl = token_parser.TokenFieldfreg1sgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        let fptsgl = token_parser.TokenFieldfptsgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                FPR164,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1764:1, end:1764:2))"]
#[derive(Clone, Debug)]
struct FSUB_instructionVar169 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
    FPR164: TableFPR164,
}
impl FSUB_instructionVar169 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FSUB"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 0i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg1sgl = token_parser.TokenFieldfreg1sgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                FPR164,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1768:1, end:1768:2))"]
#[derive(Clone, Debug)]
struct FSUB_instructionVar170 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
    FPR164: TableFPR164,
}
impl FSUB_instructionVar170 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FSUB"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 1i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg1sgl = token_parser.TokenFieldfreg1sgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                FPR164,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1788:1, end:1788:2))"]
#[derive(Clone, Debug)]
struct FDIV_instructionVar171 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
    FPR164: TableFPR164,
}
impl FDIV_instructionVar171 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FDIV"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 0i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg1sgl = token_parser.TokenFieldfreg1sgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                FPR164,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1792:1, end:1792:2))"]
#[derive(Clone, Debug)]
struct FDIV_instructionVar172 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
    FPR164: TableFPR164,
}
impl FDIV_instructionVar172 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FDIV"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 1i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg1sgl = token_parser.TokenFieldfreg1sgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                FPR164,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1848:1, end:1848:2))"]
#[derive(Clone, Debug)]
struct FCMP_instructionVar173 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPR164: TableFPR164,
    fpcmp: Tablefpcmp,
}
impl FCMP_instructionVar173 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("FCMP"), self.fpfmt.display()];
        display.extend_from_slice(&extend);
        self.fpcmp.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 0i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpcmp = if let Some((len, table)) =
            Tablefpcmp::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPR164,
                fpcmp,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1857:1, end:1857:2))"]
#[derive(Clone, Debug)]
struct FCMP_instructionVar174 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPR164: TableFPR164,
    fpcmp64: Tablefpcmp64,
}
impl FCMP_instructionVar174 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("FCMP"), self.fpfmt.display()];
        display.extend_from_slice(&extend);
        self.fpcmp64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 1i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpcmp64 = if let Some((len, table)) = Tablefpcmp64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPR164,
                fpcmp64,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1136:1, end:1136:2))"]
#[derive(Clone, Debug)]
struct SHRPW_instructionVar175 {
    SEDCondSym: TokenField_SEDCondSym,
    R2: TableR2,
    R1: TableR1,
    shiftC: TableshiftC,
    RT: TableRT,
    ShiftCondNullify: TableShiftCondNullify,
}
impl SHRPW_instructionVar175 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("SHRPW"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 52i128 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 2i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftC = if let Some((len, table)) = TableshiftC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ShiftCondNullify = if let Some((len, table)) =
            TableShiftCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                R1,
                shiftC,
                RT,
                ShiftCondNullify,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1167:1, end:1167:2))"]
#[derive(Clone, Debug)]
struct EXTRW_instructionVar176 {
    SEDCondSym: TokenField_SEDCondSym,
    cp: TokenField_cp,
    R2: TableR2,
    shiftCLen: TableshiftCLen,
    R1dst: TableR1dst,
    ExtrCondNullify: TableExtrCondNullify,
    shiftC: TableshiftC,
}
impl EXTRW_instructionVar176 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("EXTRW"),
            DisplayElement::Literal(",U"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            self.cp.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 52i128 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 6i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ExtrCondNullify = if let Some((len, table)) =
            TableExtrCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftC = if let Some((len, table)) = TableshiftC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let cp = token_parser.TokenFieldcp();
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                shiftCLen,
                R1dst,
                ExtrCondNullify,
                shiftC,
                cp,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1177:1, end:1177:2))"]
#[derive(Clone, Debug)]
struct EXTRW_instructionVar177 {
    SEDCondSym: TokenField_SEDCondSym,
    cp: TokenField_cp,
    R2: TableR2,
    shiftC: TableshiftC,
    shiftCLen: TableshiftCLen,
    R1dst: TableR1dst,
    ExtrCondNullify: TableExtrCondNullify,
}
impl EXTRW_instructionVar177 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("EXTRW"),
            DisplayElement::Literal(",S"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            self.cp.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 52i128 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 7i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftC = if let Some((len, table)) = TableshiftC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ExtrCondNullify = if let Some((len, table)) =
            TableExtrCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let cp = token_parser.TokenFieldcp();
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                shiftC,
                shiftCLen,
                R1dst,
                ExtrCondNullify,
                cp,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1201:1, end:1201:2))"]
#[derive(Clone, Debug)]
struct DEPW_instructionVar178 {
    SEDCondSym: TokenField_SEDCondSym,
    shiftC: TableshiftC,
    shiftCLen: TableshiftCLen,
    R1: TableR1,
    R2: TableR2,
    R2dst: TableR2dst,
    DepCondNullify: TableDepCondNullify,
}
impl DEPW_instructionVar178 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("DEPW"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 53i128 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 3i128 {
            return None;
        }
        let shiftC = if let Some((len, table)) = TableshiftC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        let cp = token_parser.TokenFieldcp();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shiftC,
                shiftCLen,
                R1,
                R2,
                R2dst,
                DepCondNullify,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1229:1, end:1229:2))"]
#[derive(Clone, Debug)]
struct DEPWI_instructionVar179 {
    SEDCondSym: TokenField_SEDCondSym,
    shiftC: TableshiftC,
    highlse5: Tablehighlse5,
    R2: TableR2,
    R2dst: TableR2dst,
    shiftCLen: TableshiftCLen,
    DepCondNullify: TableDepCondNullify,
}
impl DEPWI_instructionVar179 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("DEPWI"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 53i128 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 7i128 {
            return None;
        }
        let shiftC = if let Some((len, table)) = TableshiftC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        let cp = token_parser.TokenFieldcp();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shiftC,
                highlse5,
                R2,
                R2dst,
                shiftCLen,
                DepCondNullify,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1253:1, end:1253:2))"]
#[derive(Clone, Debug)]
struct DEPW_instructionVar180 {
    SEDCondSym: TokenField_SEDCondSym,
    shiftC: TableshiftC,
    R2: TableR2,
    R2dst: TableR2dst,
    shiftCLen: TableshiftCLen,
    R1: TableR1,
    DepCondNullify: TableDepCondNullify,
}
impl DEPW_instructionVar180 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("DEPW"),
            DisplayElement::Literal(",Z"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 53i128 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 2i128 {
            return None;
        }
        let shiftC = if let Some((len, table)) = TableshiftC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        let cp = token_parser.TokenFieldcp();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shiftC,
                R2,
                R2dst,
                shiftCLen,
                R1,
                DepCondNullify,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1274:1, end:1274:2))"]
#[derive(Clone, Debug)]
struct DEPWI_instructionVar181 {
    SEDCondSym: TokenField_SEDCondSym,
    shiftC: TableshiftC,
    highlse5: Tablehighlse5,
    R2dst: TableR2dst,
    shiftCLen: TableshiftCLen,
    DepCondNullify: TableDepCondNullify,
}
impl DEPWI_instructionVar181 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("DEPWI"),
            DisplayElement::Literal(",Z"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 53i128 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 6i128 {
            return None;
        }
        let shiftC = if let Some((len, table)) = TableshiftC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        let cp = token_parser.TokenFieldcp();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shiftC,
                highlse5,
                R2dst,
                shiftCLen,
                DepCondNullify,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1287:1, end:1287:2))"]
#[derive(Clone, Debug)]
struct DCOR_instructionVar182 {
    R2: TableR2,
    RT: TableRT,
    UnitCond: TableUnitCond,
    UnitCondSym: TableUnitCondSym,
}
impl DCOR_instructionVar182 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("DCOR")];
        display.extend_from_slice(&extend);
        self.UnitCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 46i128 {
            return None;
        }
        if token_parser.TokenFieldreg1().disassembly() != 0i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UnitCond = if let Some((len, table)) = TableUnitCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UnitCondSym = if let Some((len, table)) = TableUnitCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                RT,
                UnitCond,
                UnitCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1288:1, end:1288:2))"]
#[derive(Clone, Debug)]
struct IDCOR_instructionVar183 {
    R2: TableR2,
    RT: TableRT,
    UnitCond: TableUnitCond,
    UnitCondSym: TableUnitCondSym,
}
impl IDCOR_instructionVar183 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("IDCOR")];
        display.extend_from_slice(&extend);
        self.UnitCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 47i128 {
            return None;
        }
        if token_parser.TokenFieldreg1().disassembly() != 0i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UnitCond = if let Some((len, table)) = TableUnitCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UnitCondSym = if let Some((len, table)) = TableUnitCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                RT,
                UnitCond,
                UnitCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1829:1, end:1829:2))"]
#[derive(Clone, Debug)]
struct FCMP_instructionVar184 {
    fpfmt1bit: TokenField_fpfmt1bit,
    FPR232: TableFPR232,
    FPR132: TableFPR132,
    fpcmp: Tablefpcmp,
}
impl FCMP_instructionVar184 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("FCMP"), self.fpfmt1bit.display()];
        display.extend_from_slice(&extend);
        self.fpcmp.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR132.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit11().disassembly() != 0i128 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpcmp = if let Some((len, table)) =
            Tablefpcmp::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt1bit = token_parser.TokenFieldfpfmt1bit();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPR132,
                fpcmp,
                fpfmt1bit,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1838:1, end:1838:2))"]
#[derive(Clone, Debug)]
struct FCMP_instructionVar185 {
    fpfmt1bit: TokenField_fpfmt1bit,
    FPR232: TableFPR232,
    FPR132: TableFPR132,
    fpcmp64: Tablefpcmp64,
}
impl FCMP_instructionVar185 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("FCMP"), self.fpfmt1bit.display()];
        display.extend_from_slice(&extend);
        self.fpcmp64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR132.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit11().disassembly() != 1i128 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpcmp64 = if let Some((len, table)) = Tablefpcmp64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt1bit = token_parser.TokenFieldfpfmt1bit();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPR132,
                fpcmp64,
                fpfmt1bit,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1054:1, end:1054:2))"]
#[derive(Clone, Debug)]
struct ADDI_instructionVar186 {
    lse11: Tablelse11,
    R2: TableR2,
    R1dst: TableR1dst,
    AddCondSym: TableAddCondSym,
    AddCondI11Nullify: TableAddCondI11Nullify,
}
impl ADDI_instructionVar186 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ADDI")];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 45i128 {
            return None;
        }
        if token_parser.TokenFieldbit11().disassembly() != 0i128 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondI11Nullify = if let Some((len, table)) =
            TableAddCondI11Nullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                lse11,
                R2,
                R1dst,
                AddCondSym,
                AddCondI11Nullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1062:1, end:1062:2))"]
#[derive(Clone, Debug)]
struct ADDI_instructionVar187 {
    lse11: Tablelse11,
    R2: TableR2,
    R1dst: TableR1dst,
    AddCondSym: TableAddCondSym,
    AddCondI11Nullify: TableAddCondI11Nullify,
}
impl ADDI_instructionVar187 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDI"),
            DisplayElement::Literal(",TSV"),
        ];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 45i128 {
            return None;
        }
        if token_parser.TokenFieldbit11().disassembly() != 1i128 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondI11Nullify = if let Some((len, table)) =
            TableAddCondI11Nullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                lse11,
                R2,
                R1dst,
                AddCondSym,
                AddCondI11Nullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1075:1, end:1075:2))"]
#[derive(Clone, Debug)]
struct ADDI_instructionVar188 {
    lse11: Tablelse11,
    R2: TableR2,
    R1dst: TableR1dst,
    AddCondSym: TableAddCondSym,
    AddCondI11: TableAddCondI11,
}
impl ADDI_instructionVar188 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDI"),
            DisplayElement::Literal(",TC"),
        ];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 44i128 {
            return None;
        }
        if token_parser.TokenFieldbit11().disassembly() != 0i128 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondI11 = if let Some((len, table)) = TableAddCondI11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                lse11,
                R2,
                R1dst,
                AddCondSym,
                AddCondI11,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1088:1, end:1088:2))"]
#[derive(Clone, Debug)]
struct ADDI_instructionVar189 {
    lse11: Tablelse11,
    R2: TableR2,
    R1dst: TableR1dst,
    AddCondSym: TableAddCondSym,
    AddCondI11: TableAddCondI11,
}
impl ADDI_instructionVar189 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDI"),
            DisplayElement::Literal(",TC,TSV"),
        ];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 44i128 {
            return None;
        }
        if token_parser.TokenFieldbit11().disassembly() != 1i128 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondI11 = if let Some((len, table)) = TableAddCondI11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                lse11,
                R2,
                R1dst,
                AddCondSym,
                AddCondI11,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1101:1, end:1101:2))"]
#[derive(Clone, Debug)]
struct SUBI_instructionVar190 {
    lse11: Tablelse11,
    R2: TableR2,
    R1dst: TableR1dst,
    CSCondI11Nullify: TableCSCondI11Nullify,
    CSCondSym: TableCSCondSym,
}
impl SUBI_instructionVar190 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("SUBI")];
        display.extend_from_slice(&extend);
        self.CSCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 37i128 {
            return None;
        }
        if token_parser.TokenFieldbit11().disassembly() != 0i128 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondI11Nullify = if let Some((len, table)) =
            TableCSCondI11Nullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) = TableCSCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                lse11,
                R2,
                R1dst,
                CSCondI11Nullify,
                CSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1108:1, end:1108:2))"]
#[derive(Clone, Debug)]
struct SUBI_instructionVar191 {
    lse11: Tablelse11,
    R2: TableR2,
    R1dst: TableR1dst,
    CSCondI11: TableCSCondI11,
    CSCondSym: TableCSCondSym,
    CSCondI11Nullify: TableCSCondI11Nullify,
}
impl SUBI_instructionVar191 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBI"),
            DisplayElement::Literal(",TSV"),
        ];
        display.extend_from_slice(&extend);
        self.CSCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 37i128 {
            return None;
        }
        if token_parser.TokenFieldbit11().disassembly() != 1i128 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondI11 = if let Some((len, table)) = TableCSCondI11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) = TableCSCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondI11Nullify = if let Some((len, table)) =
            TableCSCondI11Nullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                lse11,
                R2,
                R1dst,
                CSCondI11,
                CSCondSym,
                CSCondI11Nullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1120:1, end:1120:2))"]
#[derive(Clone, Debug)]
struct CMPICLR_instructionVar192 {
    lse11: Tablelse11,
    R2: TableR2,
    R1dst: TableR1dst,
    CSCondI11Nullify: TableCSCondI11Nullify,
    CSCondSym: TableCSCondSym,
}
impl CMPICLR_instructionVar192 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("CMPICLR")];
        display.extend_from_slice(&extend);
        self.CSCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 36i128 {
            return None;
        }
        if token_parser.TokenFieldbit11().disassembly() != 0i128 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondI11Nullify = if let Some((len, table)) =
            TableCSCondI11Nullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) = TableCSCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                lse11,
                R2,
                R1dst,
                CSCondI11Nullify,
                CSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1729:1, end:1729:2))"]
#[derive(Clone, Debug)]
struct FABS_instructionVar193 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FABS_instructionVar193 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FABS"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldfreg1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbits59().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit10().disassembly() != 0i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1725:1, end:1725:2))"]
#[derive(Clone, Debug)]
struct FABS_instructionVar194 {
    fpfmt: TokenField_fpfmt,
    FPR232: TableFPR232,
    FPRT32: TableFPRT32,
}
impl FABS_instructionVar194 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FABS"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldfreg1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit5().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit8().disassembly() != 0i128 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPRT32,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1713:1, end:1713:2))"]
#[derive(Clone, Debug)]
struct FCPY_instructionVar195 {
    fpfmt: TokenField_fpfmt,
    FPR232: TableFPR232,
    FPRT32: TableFPRT32,
}
impl FCPY_instructionVar195 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FCPY"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldfreg1().disassembly() != 0i128 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPRT32,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1733:1, end:1733:2))"]
#[derive(Clone, Debug)]
struct FSQRT_instructionVar196 {
    fpfmt: TokenField_fpfmt,
    FPR232: TableFPR232,
    FPRT32: TableFPRT32,
}
impl FSQRT_instructionVar196 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FSQRT"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldfreg1().disassembly() != 0i128 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPRT32,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1736:1, end:1736:2))"]
#[derive(Clone, Debug)]
struct FSQRT_instructionVar197 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FSQRT_instructionVar197 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FSQRT"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldfreg1().disassembly() != 0i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1639:1, end:1639:2))"]
#[derive(Clone, Debug)]
struct FCNV_instructionVar198 {
    fpsf: TokenField_fpsf,
    fpdf: TokenField_fpdf,
    FPR232: TableFPR232,
    FPRT32: TableFPRT32,
}
impl FCNV_instructionVar198 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNV"),
            self.fpsf.display(),
            self.fpdf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i128 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpsf = token_parser.TokenFieldfpsf();
        let fpdf = token_parser.TokenFieldfpdf();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPRT32,
                fpsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1659:1, end:1659:2))"]
#[derive(Clone, Debug)]
struct FCNVXF_instructionVar199 {
    fpsf: TokenField_fpsf,
    fpdf: TokenField_fpdf,
    FPR232: TableFPR232,
    FPRT32: TableFPRT32,
}
impl FCNVXF_instructionVar199 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNVXF"),
            self.fpsf.display(),
            self.fpdf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i128 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpsf = token_parser.TokenFieldfpsf();
        let fpdf = token_parser.TokenFieldfpdf();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPRT32,
                fpsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1681:1, end:1681:2))"]
#[derive(Clone, Debug)]
struct FCNVFX_instructionVar200 {
    fpsf: TokenField_fpsf,
    fixeddf: TokenField_fixeddf,
    FPR232: TableFPR232,
    FPRT32: TableFPRT32,
}
impl FCNVFX_instructionVar200 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNVFX"),
            self.fpsf.display(),
            self.fixeddf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i128 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpsf = token_parser.TokenFieldfpsf();
        let fixeddf = token_parser.TokenFieldfixeddf();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPRT32,
                fpsf,
                fixeddf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1698:1, end:1698:2))"]
#[derive(Clone, Debug)]
struct FCNVFXT_instructionVar201 {
    fpsf: TokenField_fpsf,
    fixeddf: TokenField_fixeddf,
    FPR232: TableFPR232,
    FPRT32: TableFPRT32,
}
impl FCNVFXT_instructionVar201 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNVFXT"),
            self.fpsf.display(),
            self.fixeddf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i128 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpsf = token_parser.TokenFieldfpsf();
        let fixeddf = token_parser.TokenFieldfixeddf();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPRT32,
                fpsf,
                fixeddf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1772:1, end:1772:2))"]
#[derive(Clone, Debug)]
struct FMPY_instructionVar202 {
    fpfmt: TokenField_fpfmt,
    FPR232: TableFPR232,
    FPR132: TableFPR132,
    FPRT32: TableFPRT32,
}
impl FMPY_instructionVar202 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FMPY"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR132.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldbit8().disassembly() != 0i128 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPR132,
                FPRT32,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1820:1, end:1820:2))"]
#[derive(Clone, Debug)]
struct XMPYU_instructionVar203 {
    fpfmt: TokenField_fpfmt,
    FPR232: TableFPR232,
    FPR132: TableFPR132,
    FPRT64: TableFPRT64,
}
impl XMPYU_instructionVar203 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("XMPYU"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR132.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldbit8().disassembly() != 1i128 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        let fptsgl = token_parser.TokenFieldfptsgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPR132,
                FPRT64,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1740:1, end:1740:2))"]
#[derive(Clone, Debug)]
struct FRND_instructionVar204 {
    fpfmt: TokenField_fpfmt,
    FPR232: TableFPR232,
    FPRT32: TableFPRT32,
}
impl FRND_instructionVar204 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FRND"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 5i128 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPRT32,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1744:1, end:1744:2))"]
#[derive(Clone, Debug)]
struct FRND_instructionVar205 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FRND_instructionVar205 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FRND"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 5i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1748:1, end:1748:2))"]
#[derive(Clone, Debug)]
struct FADD_instructionVar206 {
    fpfmt: TokenField_fpfmt,
    FPR232: TableFPR232,
    FPR132: TableFPR132,
    FPRT32: TableFPRT32,
}
impl FADD_instructionVar206 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FADD"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR132.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 0i128 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPR132,
                FPRT32,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1760:1, end:1760:2))"]
#[derive(Clone, Debug)]
struct FSUB_instructionVar207 {
    fpfmt: TokenField_fpfmt,
    FPR232: TableFPR232,
    FPR132: TableFPR132,
    FPRT32: TableFPRT32,
}
impl FSUB_instructionVar207 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FSUB"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR132.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 1i128 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPR132,
                FPRT32,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1784:1, end:1784:2))"]
#[derive(Clone, Debug)]
struct FDIV_instructionVar208 {
    fpfmt: TokenField_fpfmt,
    FPR232: TableFPR232,
    FPR132: TableFPR132,
    FPRT32: TableFPRT32,
}
impl FDIV_instructionVar208 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FDIV"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR132.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 3i128 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPR132,
                FPRT32,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1866:1, end:1866:2))"]
#[derive(Clone, Debug)]
struct FTEST_instructionVar209 {
    fptest: TokenField_fptest,
}
impl FTEST_instructionVar209 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_nullifyEnable(
            Some(inst_next),
            context.register().read_nullifyEnable_disassembly().unwrap(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("FTEST"), self.fptest.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 1i128 {
            return None;
        }
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_nullifyEnable_disassembly(tmp)
            .unwrap();
        let fptest = token_parser.TokenFieldfptest();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fptest }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1452:1, end:1452:2))"]
#[derive(Clone, Debug)]
struct SPOP0_instructionVar210 {
    im15: TokenField_im15,
    im5: TokenField_im5,
    SFU: TableSFU,
    nullifyForSpecial: TablenullifyForSpecial,
}
impl SPOP0_instructionVar210 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_sop: i128 = 0;
        calc_sop = (u32::try_from(5i128)
            .ok()
            .map(|shl| self.im15.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            | self.im5.disassembly());
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SPOP0"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.nullifyForSpecial.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Number(true, calc_sop),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_sop: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldspecop().disassembly() != 0i128 {
            return None;
        }
        calc_sop = (u32::try_from(5i128)
            .ok()
            .map(|shl| {
                token_parser.TokenFieldim15().disassembly().checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldim5().disassembly());
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForSpecial = if let Some((len, table)) =
            TablenullifyForSpecial::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let im5 = token_parser.TokenFieldim5();
        let im15 = token_parser.TokenFieldim15();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SFU,
                nullifyForSpecial,
                im5,
                im15,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1453:1, end:1453:2))"]
#[derive(Clone, Debug)]
struct SPOP1_instructionVar211 {
    sopim10: TokenField_sopim10,
    im5: TokenField_im5,
    SFU: TableSFU,
    nullifyForSpecial: TablenullifyForSpecial,
}
impl SPOP1_instructionVar211 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_sop: i128 = 0;
        calc_sop = (u32::try_from(5i128)
            .ok()
            .map(|shl| self.sopim10.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            | self.im5.disassembly());
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SPOP1"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.nullifyForSpecial.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Number(true, calc_sop),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_sop: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldspecop().disassembly() != 1i128 {
            return None;
        }
        calc_sop = (u32::try_from(5i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldsopim10()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldim5().disassembly());
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForSpecial = if let Some((len, table)) =
            TablenullifyForSpecial::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let im5 = token_parser.TokenFieldim5();
        let sopim10 = token_parser.TokenFieldsopim10();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SFU,
                nullifyForSpecial,
                im5,
                sopim10,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1454:1, end:1454:2))"]
#[derive(Clone, Debug)]
struct SPOP2_instructionVar212 {
    sopim5: TokenField_sopim5,
    im5: TokenField_im5,
    SFU: TableSFU,
    nullifyForSpecial: TablenullifyForSpecial,
    R2: TableR2,
}
impl SPOP2_instructionVar212 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_sop: i128 = 0;
        calc_sop = (u32::try_from(5i128)
            .ok()
            .map(|shl| self.sopim5.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            | self.im5.disassembly());
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SPOP2"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.nullifyForSpecial.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Number(true, calc_sop),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_sop: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldspecop().disassembly() != 2i128 {
            return None;
        }
        calc_sop = (u32::try_from(5i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldsopim5()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldim5().disassembly());
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForSpecial = if let Some((len, table)) =
            TablenullifyForSpecial::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let im5 = token_parser.TokenFieldim5();
        let sopim5 = token_parser.TokenFieldsopim5();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SFU,
                nullifyForSpecial,
                R2,
                im5,
                sopim5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1455:1, end:1455:2))"]
#[derive(Clone, Debug)]
struct SPOP3_instructionVar213 {
    sopim5: TokenField_sopim5,
    im5: TokenField_im5,
    SFU: TableSFU,
    nullifyForSpecial: TablenullifyForSpecial,
    R1: TableR1,
    R2: TableR2,
}
impl SPOP3_instructionVar213 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_sop: i128 = 0;
        calc_sop = (u32::try_from(5i128)
            .ok()
            .map(|shl| self.sopim5.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            | self.im5.disassembly());
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SPOP3"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.nullifyForSpecial.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Number(true, calc_sop),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_sop: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldspecop().disassembly() != 3i128 {
            return None;
        }
        calc_sop = (u32::try_from(5i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldsopim5()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldim5().disassembly());
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForSpecial = if let Some((len, table)) =
            TablenullifyForSpecial::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let im5 = token_parser.TokenFieldim5();
        let sopim5 = token_parser.TokenFieldsopim5();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SFU,
                nullifyForSpecial,
                R1,
                R2,
                im5,
                sopim5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1475:1, end:1475:2))"]
#[derive(Clone, Debug)]
struct FLDW_instructionVar214 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RX: TableRX,
    FPRT32: TableFPRT32,
    SPCBASE: TableSPCBASE,
}
impl FLDW_instructionVar214 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDW")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                loadCC,
                SRRB,
                RX,
                FPRT32,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1480:1, end:1480:2))"]
#[derive(Clone, Debug)]
struct FLDW_instructionVar215 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RX: TableRX,
    FPRT32: TableFPRT32,
    SPCBASE: TableSPCBASE,
}
impl FLDW_instructionVar215 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDW")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                loadCC,
                SRRB,
                RX,
                FPRT32,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1485:1, end:1485:2))"]
#[derive(Clone, Debug)]
struct FLDW_instructionVar216 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RX: TableRX,
    RB: TableRB,
    FPRT32: TableFPRT32,
    SPCBASE: TableSPCBASE,
}
impl FLDW_instructionVar216 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDW")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                loadCC,
                SRRB,
                RX,
                RB,
                FPRT32,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1491:1, end:1491:2))"]
#[derive(Clone, Debug)]
struct FLDW_instructionVar217 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RB: TableRB,
    RX: TableRX,
    FPRT32: TableFPRT32,
    SPCBASE: TableSPCBASE,
}
impl FLDW_instructionVar217 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDW")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                loadCC,
                SRRB,
                RB,
                RX,
                FPRT32,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1522:1, end:1522:2))"]
#[derive(Clone, Debug)]
struct FSTW_instructionVar218 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    RX: TableRX,
    FPRT32: TableFPRT32,
    SPCBASE: TableSPCBASE,
}
impl FSTW_instructionVar218 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTW")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                storeCC,
                SRRB,
                RX,
                FPRT32,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1527:1, end:1527:2))"]
#[derive(Clone, Debug)]
struct FSTW_instructionVar219 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    RX: TableRX,
    FPRT32: TableFPRT32,
    SPCBASE: TableSPCBASE,
}
impl FSTW_instructionVar219 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTW")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                storeCC,
                SRRB,
                RX,
                FPRT32,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1532:1, end:1532:2))"]
#[derive(Clone, Debug)]
struct FSTW_instructionVar220 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    RX: TableRX,
    RB: TableRB,
    FPRT32: TableFPRT32,
    SPCBASE: TableSPCBASE,
}
impl FSTW_instructionVar220 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTW")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                storeCC,
                SRRB,
                RX,
                RB,
                FPRT32,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1538:1, end:1538:2))"]
#[derive(Clone, Debug)]
struct FSTW_instructionVar221 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    RX: TableRX,
    RB: TableRB,
    FPRT32: TableFPRT32,
    SPCBASE: TableSPCBASE,
}
impl FSTW_instructionVar221 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTW")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                storeCC,
                SRRB,
                RX,
                RB,
                FPRT32,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1544:1, end:1544:2))"]
#[derive(Clone, Debug)]
struct FSTD_instructionVar222 {
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    RX: TableRX,
    FPRT64: TableFPRT64,
    SPCBASE: TableSPCBASE,
}
impl FSTD_instructionVar222 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTD")];
        display.extend_from_slice(&extend);
        self.indexedDoublewordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedDoublewordAccessCmplt,
                storeCC,
                SRRB,
                RX,
                FPRT64,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1549:1, end:1549:2))"]
#[derive(Clone, Debug)]
struct FSTD_instructionVar223 {
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    RX: TableRX,
    FPRT64: TableFPRT64,
    SPCBASE: TableSPCBASE,
}
impl FSTD_instructionVar223 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTD")];
        display.extend_from_slice(&extend);
        self.indexedDoublewordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedDoublewordAccessCmplt,
                storeCC,
                SRRB,
                RX,
                FPRT64,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1554:1, end:1554:2))"]
#[derive(Clone, Debug)]
struct FSTD_instructionVar224 {
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    RX: TableRX,
    RB: TableRB,
    FPRT64: TableFPRT64,
    SPCBASE: TableSPCBASE,
}
impl FSTD_instructionVar224 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTD")];
        display.extend_from_slice(&extend);
        self.indexedDoublewordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedDoublewordAccessCmplt,
                storeCC,
                SRRB,
                RX,
                RB,
                FPRT64,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1560:1, end:1560:2))"]
#[derive(Clone, Debug)]
struct FSTD_instructionVar225 {
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    RX: TableRX,
    RB: TableRB,
    FPRT64: TableFPRT64,
    SPCBASE: TableSPCBASE,
}
impl FSTD_instructionVar225 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTD")];
        display.extend_from_slice(&extend);
        self.indexedDoublewordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedDoublewordAccessCmplt,
                storeCC,
                SRRB,
                RX,
                RB,
                FPRT64,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1574:1, end:1574:2))"]
#[derive(Clone, Debug)]
struct FLDW_instructionVar226 {
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    FPRT32: TableFPRT32,
    RB: TableRB,
    highlse5: Tablehighlse5,
}
impl FLDW_instructionVar226 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDW")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                loadCC,
                SRRB,
                SPCBASE,
                FPRT32,
                RB,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1581:1, end:1581:2))"]
#[derive(Clone, Debug)]
struct FLDW_instructionVar227 {
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
    FPRT32: TableFPRT32,
    highlse5: Tablehighlse5,
}
impl FLDW_instructionVar227 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDW")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                loadCC,
                SRRB,
                RB,
                SPCBASE,
                FPRT32,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1609:1, end:1609:2))"]
#[derive(Clone, Debug)]
struct FSTW_instructionVar228 {
    shortDispCmplt: TableshortDispCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    RB: TableRB,
    FPRT32: TableFPRT32,
    highlse5: Tablehighlse5,
}
impl FSTW_instructionVar228 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTW")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                storeCC,
                SRRB,
                SPCBASE,
                RB,
                FPRT32,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1615:1, end:1615:2))"]
#[derive(Clone, Debug)]
struct FSTW_instructionVar229 {
    shortDispCmplt: TableshortDispCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    RB: TableRB,
    FPRT32: TableFPRT32,
    highlse5: Tablehighlse5,
}
impl FSTW_instructionVar229 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTW")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                storeCC,
                SRRB,
                SPCBASE,
                RB,
                FPRT32,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1568:1, end:1568:2))"]
#[derive(Clone, Debug)]
struct FLDW_instructionVar230 {
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    FPRT32: TableFPRT32,
    highlse5: Tablehighlse5,
}
impl FLDW_instructionVar230 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDW")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                loadCC,
                SRRB,
                SPCBASE,
                FPRT32,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1604:1, end:1604:2))"]
#[derive(Clone, Debug)]
struct FSTW_instructionVar231 {
    shortDispCmplt: TableshortDispCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    FPRT32: TableFPRT32,
    highlse5: Tablehighlse5,
}
impl FSTW_instructionVar231 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTW")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                storeCC,
                SRRB,
                SPCBASE,
                FPRT32,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1458:1, end:1458:2))"]
#[derive(Clone, Debug)]
struct CLDW_instructionVar232 {
    RX: TableRX,
    SRRB: TableSRRB,
    RT: TableRT,
    SFU: TableSFU,
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    loadCC: TableloadCC,
}
impl CLDW_instructionVar232 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CLDW"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB,
                RT,
                SFU,
                indexedWordAccessCmplt,
                loadCC,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1459:1, end:1459:2))"]
#[derive(Clone, Debug)]
struct CLDD_instructionVar233 {
    RX: TableRX,
    SRRB: TableSRRB,
    RT: TableRT,
    SFU: TableSFU,
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    loadCC: TableloadCC,
}
impl CLDD_instructionVar233 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CLDD"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.indexedDoublewordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB,
                RT,
                SFU,
                indexedDoublewordAccessCmplt,
                loadCC,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1460:1, end:1460:2))"]
#[derive(Clone, Debug)]
struct CSTW_instructionVar234 {
    RX: TableRX,
    SRRB: TableSRRB,
    RT: TableRT,
    SFU: TableSFU,
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    storeCC: TablestoreCC,
}
impl CSTW_instructionVar234 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CSTW"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB,
                RT,
                SFU,
                indexedWordAccessCmplt,
                storeCC,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1461:1, end:1461:2))"]
#[derive(Clone, Debug)]
struct CSTD_instructionVar235 {
    RX: TableRX,
    SRRB: TableSRRB,
    RT: TableRT,
    SFU: TableSFU,
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    storeCC: TablestoreCC,
}
impl CSTD_instructionVar235 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CSTD"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.indexedDoublewordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB,
                RT,
                SFU,
                indexedDoublewordAccessCmplt,
                storeCC,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1463:1, end:1463:2))"]
#[derive(Clone, Debug)]
struct CLDW_instructionVar236 {
    SRRB: TableSRRB,
    RT: TableRT,
    SFU: TableSFU,
    highlse5: Tablehighlse5,
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
}
impl CLDW_instructionVar236 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CLDW"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SRRB,
                RT,
                SFU,
                highlse5,
                shortDispCmplt,
                loadCC,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1464:1, end:1464:2))"]
#[derive(Clone, Debug)]
struct CLDD_instructionVar237 {
    SRRB: TableSRRB,
    RT: TableRT,
    SFU: TableSFU,
    highlse5: Tablehighlse5,
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
}
impl CLDD_instructionVar237 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CLDD"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SRRB,
                RT,
                SFU,
                highlse5,
                shortDispCmplt,
                loadCC,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1465:1, end:1465:2))"]
#[derive(Clone, Debug)]
struct CSTW_instructionVar238 {
    SRRB: TableSRRB,
    RT: TableRT,
    SFU: TableSFU,
    highlse5: Tablehighlse5,
    shortDispCmplt: TableshortDispCmplt,
    storeCC: TablestoreCC,
}
impl CSTW_instructionVar238 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CSTW"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SRRB,
                RT,
                SFU,
                highlse5,
                shortDispCmplt,
                storeCC,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1466:1, end:1466:2))"]
#[derive(Clone, Debug)]
struct CSTD_instructionVar239 {
    SRRB: TableSRRB,
    RT: TableRT,
    SFU: TableSFU,
    highlse5: Tablehighlse5,
    shortDispCmplt: TableshortDispCmplt,
    storeCC: TablestoreCC,
}
impl CSTD_instructionVar239 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CSTD"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i128 {
            return None;
        }
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SRRB,
                RT,
                SFU,
                highlse5,
                shortDispCmplt,
                storeCC,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1797:1, end:1797:2))"]
#[derive(Clone, Debug)]
struct FMPYADD_instructionVar240 {
    fusedfmt: TokenField_fusedfmt,
    fpra: TokenField_fpra,
    fpta: TokenField_fpta,
    FPR264: TableFPR264,
    FPR164: TableFPR164,
    FPRT64: TableFPRT64,
}
impl FMPYADD_instructionVar240 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FMPYADD"),
            self.fusedfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            self.fpra.display(),
            DisplayElement::Literal(","),
            self.fpta.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldbit5().disassembly() != 0i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fusedfmt = token_parser.TokenFieldfusedfmt();
        let fpra = token_parser.TokenFieldfpra();
        let fpta = token_parser.TokenFieldfpta();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPR164,
                FPRT64,
                fusedfmt,
                fpra,
                fpta,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1803:1, end:1803:2))"]
#[derive(Clone, Debug)]
struct FMPYADD_instructionVar241 {
    fusedfmt: TokenField_fusedfmt,
    FUSEDR2: TableFUSEDR2,
    FUSEDR1: TableFUSEDR1,
    FUSEDRT: TableFUSEDRT,
    FUSEDRA: TableFUSEDRA,
    FUSEDTA: TableFUSEDTA,
}
impl FMPYADD_instructionVar241 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FMPYADD"),
            self.fusedfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FUSEDR2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDR1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDRT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDRA.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDTA.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldbit5().disassembly() != 1i128 {
            return None;
        }
        let FUSEDR2 = if let Some((len, table)) = TableFUSEDR2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FUSEDR1 = if let Some((len, table)) = TableFUSEDR1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FUSEDRT = if let Some((len, table)) = TableFUSEDRT::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FUSEDRA = if let Some((len, table)) = TableFUSEDRA::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FUSEDTA = if let Some((len, table)) = TableFUSEDTA::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fusedfmt = token_parser.TokenFieldfusedfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FUSEDR2,
                FUSEDR1,
                FUSEDRT,
                FUSEDRA,
                FUSEDTA,
                fusedfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1809:1, end:1809:2))"]
#[derive(Clone, Debug)]
struct FMPYSUB_instructionVar242 {
    fusedfmt: TokenField_fusedfmt,
    fpra: TokenField_fpra,
    fpta: TokenField_fpta,
    FPR264: TableFPR264,
    FPR164: TableFPR164,
    FPRT64: TableFPRT64,
}
impl FMPYSUB_instructionVar242 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FMPYSUB"),
            self.fusedfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            self.fpra.display(),
            DisplayElement::Literal(","),
            self.fpta.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 38i128 {
            return None;
        }
        if token_parser.TokenFieldbit5().disassembly() != 0i128 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fusedfmt = token_parser.TokenFieldfusedfmt();
        let fpra = token_parser.TokenFieldfpra();
        let fpta = token_parser.TokenFieldfpta();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPR164,
                FPRT64,
                fusedfmt,
                fpra,
                fpta,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1814:1, end:1814:2))"]
#[derive(Clone, Debug)]
struct FMPYSUB_instructionVar243 {
    fusedfmt: TokenField_fusedfmt,
    FUSEDR2: TableFUSEDR2,
    FUSEDR1: TableFUSEDR1,
    FUSEDRT: TableFUSEDRT,
    FUSEDRA: TableFUSEDRA,
    FUSEDTA: TableFUSEDTA,
}
impl FMPYSUB_instructionVar243 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FMPYSUB"),
            self.fusedfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FUSEDR2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDR1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDRT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDRA.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDTA.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 38i128 {
            return None;
        }
        if token_parser.TokenFieldbit5().disassembly() != 1i128 {
            return None;
        }
        let FUSEDR2 = if let Some((len, table)) = TableFUSEDR2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FUSEDR1 = if let Some((len, table)) = TableFUSEDR1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FUSEDRT = if let Some((len, table)) = TableFUSEDRT::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FUSEDRA = if let Some((len, table)) = TableFUSEDRA::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FUSEDTA = if let Some((len, table)) = TableFUSEDTA::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fusedfmt = token_parser.TokenFieldfusedfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FUSEDR2,
                FUSEDR1,
                FUSEDRT,
                FUSEDRA,
                FUSEDTA,
                fusedfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:12:1, end:12:2))"]
#[derive(Clone, Debug)]
struct LDW_instructionVar244 {
    OFF_BASE_14: TableOFF_BASE_14,
    R1dst: TableR1dst,
}
impl LDW_instructionVar244 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDW"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 18i128 {
            return None;
        }
        let OFF_BASE_14 = if let Some((len, table)) = TableOFF_BASE_14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE_14, R1dst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:17:1, end:17:2))"]
#[derive(Clone, Debug)]
struct LDH_instructionVar245 {
    OFF_BASE_14: TableOFF_BASE_14,
    R1dst: TableR1dst,
}
impl LDH_instructionVar245 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDH"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 17i128 {
            return None;
        }
        let OFF_BASE_14 = if let Some((len, table)) = TableOFF_BASE_14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE_14, R1dst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:22:1, end:22:2))"]
#[derive(Clone, Debug)]
struct LDB_instructionVar246 {
    OFF_BASE_14: TableOFF_BASE_14,
    R1dst: TableR1dst,
}
impl LDB_instructionVar246 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDB"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 16i128 {
            return None;
        }
        let OFF_BASE_14 = if let Some((len, table)) = TableOFF_BASE_14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE_14, R1dst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:27:1, end:27:2))"]
#[derive(Clone, Debug)]
struct STW_instructionVar247 {
    OFF_BASE_14: TableOFF_BASE_14,
    R1: TableR1,
}
impl STW_instructionVar247 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STW"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 26i128 {
            return None;
        }
        let OFF_BASE_14 = if let Some((len, table)) = TableOFF_BASE_14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE_14, R1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:32:1, end:32:2))"]
#[derive(Clone, Debug)]
struct STH_instructionVar248 {
    R1: TableR1,
    OFF_BASE_14: TableOFF_BASE_14,
}
impl STH_instructionVar248 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STH"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 25i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let OFF_BASE_14 = if let Some((len, table)) = TableOFF_BASE_14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, OFF_BASE_14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:36:1, end:36:2))"]
#[derive(Clone, Debug)]
struct STB_instructionVar249 {
    OFF_BASE_14: TableOFF_BASE_14,
    R1: TableR1,
}
impl STB_instructionVar249 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STB"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 24i128 {
            return None;
        }
        let OFF_BASE_14 = if let Some((len, table)) = TableOFF_BASE_14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE_14, R1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:41:1, end:41:2))"]
#[derive(Clone, Debug)]
struct LDW_instructionVar250 {
    OFF_BASE_14: TableOFF_BASE_14,
    R1dst: TableR1dst,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
    lse14: Tablelse14,
}
impl LDW_instructionVar250 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("LDW"),
            DisplayElement::Literal(",M"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 19i128 {
            return None;
        }
        let OFF_BASE_14 = if let Some((len, table)) = TableOFF_BASE_14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse14 = if let Some((len, table)) =
            Tablelse14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                OFF_BASE_14,
                R1dst,
                RB,
                SPCBASE,
                lse14,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:51:1, end:51:2))"]
#[derive(Clone, Debug)]
struct STW_instructionVar251 {
    OFF_BASE_14: TableOFF_BASE_14,
    R1: TableR1,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
    lse14: Tablelse14,
}
impl STW_instructionVar251 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("STW"),
            DisplayElement::Literal(",M"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 27i128 {
            return None;
        }
        let OFF_BASE_14 = if let Some((len, table)) = TableOFF_BASE_14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse14 = if let Some((len, table)) =
            Tablelse14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                OFF_BASE_14,
                R1,
                RB,
                SPCBASE,
                lse14,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:188:1, end:188:2))"]
#[derive(Clone, Debug)]
struct LDO_instructionVar252 {
    lse14: Tablelse14,
    RB: TableRB,
    R1dst: TableR1dst,
}
impl LDO_instructionVar252 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDO"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("),")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 13i128 {
            return None;
        }
        let lse14 = if let Some((len, table)) =
            Tablelse14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse14, RB, R1dst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:201:1, end:201:2))"]
#[derive(Clone, Debug)]
struct LDIL_instructionVar253 {
    R2: TableR2,
    lse21: Tablelse21,
}
impl LDIL_instructionVar253 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LDIL"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.lse21.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 8i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse21 = if let Some((len, table)) =
            Tablelse21::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse21 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:207:1, end:207:2))"]
#[derive(Clone, Debug)]
struct ADDIL_instructionVar254 {
    R2: TableR2,
    lse21: Tablelse21,
}
impl ADDIL_instructionVar254 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDIL"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.lse21.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::r1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 10i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse21 = if let Some((len, table)) =
            Tablelse21::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse21 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1447:1, end:1447:2))"]
#[derive(Clone, Debug)]
struct DIAG_instructionVar255 {
    im26: TokenField_im26,
}
impl DIAG_instructionVar255 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("DIAG"),
            DisplayElement::Literal(" "),
            self.im26.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 5i128 {
            return None;
        }
        let im26 = token_parser.TokenFieldim26();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { im26 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1456:1, end:1456:2))"]
#[derive(Clone, Debug)]
struct COPR_instructionVar256 {
    sopim17: TokenField_sopim17,
    im5: TokenField_im5,
    SFU: TableSFU,
    nullifyForSpecial: TablenullifyForSpecial,
}
impl COPR_instructionVar256 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_sop: i128 = 0;
        calc_sop = (u32::try_from(5i128)
            .ok()
            .map(|shl| self.sopim17.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            | self.im5.disassembly());
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("COPR"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Number(true, calc_sop),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForSpecial.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_sop: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i128 {
            return None;
        }
        calc_sop = (u32::try_from(5i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldsopim17()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldim5().disassembly());
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForSpecial = if let Some((len, table)) =
            TablenullifyForSpecial::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let im5 = token_parser.TokenFieldim5();
        let sopim17 = token_parser.TokenFieldsopim17();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SFU,
                nullifyForSpecial,
                im5,
                sopim17,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:433:1, end:433:2))"]
#[derive(Clone, Debug)]
struct instructionVar257 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar257 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:440:1, end:440:2))"]
#[derive(Clone, Debug)]
struct instructionVar258 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar258 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:463:1, end:463:2))"]
#[derive(Clone, Debug)]
struct instructionVar259 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar259 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:476:1, end:476:2))"]
#[derive(Clone, Debug)]
struct instructionVar260 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar260 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:487:1, end:487:2))"]
#[derive(Clone, Debug)]
struct instructionVar261 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar261 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:503:1, end:503:2))"]
#[derive(Clone, Debug)]
struct instructionVar262 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar262 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:515:1, end:515:2))"]
#[derive(Clone, Debug)]
struct instructionVar263 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar263 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 2i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:531:1, end:531:2))"]
#[derive(Clone, Debug)]
struct instructionVar264 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar264 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 2i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:542:1, end:542:2))"]
#[derive(Clone, Debug)]
struct instructionVar265 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar265 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 3i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:556:1, end:556:2))"]
#[derive(Clone, Debug)]
struct instructionVar266 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar266 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 3i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:571:1, end:571:2))"]
#[derive(Clone, Debug)]
struct instructionVar267 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar267 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 4i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:587:1, end:587:2))"]
#[derive(Clone, Debug)]
struct instructionVar268 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar268 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 4i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchIsReturn_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:595:1, end:595:2))"]
#[derive(Clone, Debug)]
struct instructionVar269 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar269 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 4i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchIsReturn_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:605:1, end:605:2))"]
#[derive(Clone, Debug)]
struct instructionVar270 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar270 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 5i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:618:1, end:618:2))"]
#[derive(Clone, Debug)]
struct instructionVar271 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar271 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 5i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:629:1, end:629:2))"]
#[derive(Clone, Debug)]
struct instructionVar272 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar272 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 6i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:646:1, end:646:2))"]
#[derive(Clone, Debug)]
struct instructionVar273 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar273 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 6i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:660:1, end:660:2))"]
#[derive(Clone, Debug)]
struct instructionVar274 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar274 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 7i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:675:1, end:675:2))"]
#[derive(Clone, Debug)]
struct instructionVar275 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar275 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 7i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:693:1, end:693:2))"]
#[derive(Clone, Debug)]
struct instructionVar276 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar276 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:707:1, end:707:2))"]
#[derive(Clone, Debug)]
struct instructionVar277 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar277 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:719:1, end:719:2))"]
#[derive(Clone, Debug)]
struct instructionVar278 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar278 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:735:1, end:735:2))"]
#[derive(Clone, Debug)]
struct instructionVar279 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar279 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:747:1, end:747:2))"]
#[derive(Clone, Debug)]
struct instructionVar280 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar280 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 2i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:763:1, end:763:2))"]
#[derive(Clone, Debug)]
struct instructionVar281 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar281 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 2i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:778:1, end:778:2))"]
#[derive(Clone, Debug)]
struct instructionVar282 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar282 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 3i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:795:1, end:795:2))"]
#[derive(Clone, Debug)]
struct instructionVar283 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar283 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 3i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:811:1, end:811:2))"]
#[derive(Clone, Debug)]
struct instructionVar284 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar284 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 4i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:827:1, end:827:2))"]
#[derive(Clone, Debug)]
struct instructionVar285 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar285 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 4i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:839:1, end:839:2))"]
#[derive(Clone, Debug)]
struct instructionVar286 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar286 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 5i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:855:1, end:855:2))"]
#[derive(Clone, Debug)]
struct instructionVar287 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar287 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 5i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:867:1, end:867:2))"]
#[derive(Clone, Debug)]
struct instructionVar288 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar288 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 6i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:885:1, end:885:2))"]
#[derive(Clone, Debug)]
struct instructionVar289 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar289 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 6i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:902:1, end:902:2))"]
#[derive(Clone, Debug)]
struct instructionVar290 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar290 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 7i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:919:1, end:919:2))"]
#[derive(Clone, Debug)]
struct instructionVar291 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar291 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_nullifyEnable_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchType_disassembly()
            .unwrap()
            != 7i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[derive(Clone, Debug)]
enum Tableinstruction {
    Var0(NOP_instructionVar0),
    Var1(COPR_0_0_instructionVar1),
    Var2(COPY_instructionVar2),
    Var3(SYNC_instructionVar3),
    Var4(SYNCDMA_instructionVar4),
    Var5(MTSM_instructionVar5),
    Var6(IITLBT_instructionVar6),
    Var7(SSM_instructionVar7),
    Var8(RSM_instructionVar8),
    Var9(FCNVXF_instructionVar9),
    Var10(FCNVXF_instructionVar10),
    Var11(FCNVXF_instructionVar11),
    Var12(FCNVXF_instructionVar12),
    Var13(LDWAX_instructionVar13),
    Var14(COPY_instructionVar14),
    Var15(IDTLBA_instructionVar15),
    Var16(IDTLBP_instructionVar16),
    Var17(PDC_instructionVar17),
    Var18(PDC_instructionVar18),
    Var19(LDSID_instructionVar19),
    Var20(PROBER_instructionVar20),
    Var21(PROBERI_instructionVar21),
    Var22(PROBEW_instructionVar22),
    Var23(PROBEWI_instructionVar23),
    Var24(LCI_instructionVar24),
    Var25(PDTLB_instructionVar25),
    Var26(PDTLB_instructionVar26),
    Var27(PITLB_instructionVar27),
    Var28(PITLB_instructionVar28),
    Var29(PDTLBE_instructionVar29),
    Var30(PDTLBE_instructionVar30),
    Var31(PITLBE_instructionVar31),
    Var32(PITLBE_instructionVar32),
    Var33(FDC_instructionVar33),
    Var34(FDC_instructionVar34),
    Var35(FDCE_instructionVar35),
    Var36(FDCE_instructionVar36),
    Var37(PMENB_instructionVar37),
    Var38(PMDIS_instructionVar38),
    Var39(LPA_instructionVar39),
    Var40(FLDD_instructionVar40),
    Var41(FLDD_instructionVar41),
    Var42(FLDD_instructionVar42),
    Var43(FLDD_instructionVar43),
    Var44(FLDD_instructionVar44),
    Var45(FLDD_instructionVar45),
    Var46(FSTD_instructionVar46),
    Var47(FSTD_instructionVar47),
    Var48(STBYS_instructionVar48),
    Var49(STBYS_instructionVar49),
    Var50(MTSAR_instructionVar50),
    Var51(RFI_instructionVar51),
    Var52(RFI_instructionVar52),
    Var53(MTSP_instructionVar53),
    Var54(MTCTL_instructionVar54),
    Var55(FCNV_instructionVar55),
    Var56(FCNV_instructionVar56),
    Var57(MFSP_instructionVar57),
    Var58(MFCTL_instructionVar58),
    Var59(MFIA_instructionVar59),
    Var60(IITLBA_instructionVar60),
    Var61(IITLBP_instructionVar61),
    Var62(SHRPW_instructionVar62),
    Var63(EXTRW_instructionVar63),
    Var64(EXTRW_instructionVar64),
    Var65(DEPW_instructionVar65),
    Var66(DEPWI_instructionVar66),
    Var67(DEPW_instructionVar67),
    Var68(DEPWI_instructionVar68),
    Var69(BREAK_instructionVar69),
    Var70(FIC_instructionVar70),
    Var71(FIC_instructionVar71),
    Var72(FICE_instructionVar72),
    Var73(FICE_instructionVar73),
    Var74(FLDD_instructionVar74),
    Var75(FSTD_instructionVar75),
    Var76(FCNVFX_instructionVar76),
    Var77(FCNVFX_instructionVar77),
    Var78(FCNVFXT_instructionVar78),
    Var79(FCNVFXT_instructionVar79),
    Var80(LDW_instructionVar80),
    Var81(LDH_instructionVar81),
    Var82(LDB_instructionVar82),
    Var83(LDCWX_instructionVar83),
    Var84(LDW_instructionVar84),
    Var85(LDH_instructionVar85),
    Var86(LDB_instructionVar86),
    Var87(STW_instructionVar87),
    Var88(STH_instructionVar88),
    Var89(STB_instructionVar89),
    Var90(LDWAS_instructionVar90),
    Var91(LDCWS_instructionVar91),
    Var92(STWAS_instructionVar92),
    Var93(B_instructionVar93),
    Var94(B_instructionVar94),
    Var95(LDI_instructionVar95),
    Var96(BV_instructionVar96),
    Var97(BV_instructionVar97),
    Var98(BV_instructionVar98),
    Var99(BV_instructionVar99),
    Var100(B_instructionVar100),
    Var101(B_instructionVar101),
    Var102(BLR_instructionVar102),
    Var103(BLR_instructionVar103),
    Var104(B_instructionVar104),
    Var105(B_instructionVar105),
    Var106(CMPBT_instructionVar106),
    Var107(CMPBT_instructionVar107),
    Var108(CMPBF_instructionVar108),
    Var109(CMPBF_instructionVar109),
    Var110(CMPIBT_instructionVar110),
    Var111(CMPIBT_instructionVar111),
    Var112(CMPIBF_instructionVar112),
    Var113(CMPIBF_instructionVar113),
    Var114(MOVB_instructionVar114),
    Var115(MOVB_instructionVar115),
    Var116(MOVIB_instructionVar116),
    Var117(MOVIB_instructionVar117),
    Var118(ADDBT_instructionVar118),
    Var119(ADDBT_instructionVar119),
    Var120(ADDBF_instructionVar120),
    Var121(ADDBF_instructionVar121),
    Var122(ADDIBT_instructionVar122),
    Var123(ADDIBT_instructionVar123),
    Var124(ADDIBF_instructionVar124),
    Var125(ADDIBF_instructionVar125),
    Var126(BB_instructionVar126),
    Var127(BB_instructionVar127),
    Var128(BB_instructionVar128),
    Var129(BB_instructionVar129),
    Var130(BE_instructionVar130),
    Var131(BE_instructionVar131),
    Var132(BE_instructionVar132),
    Var133(BE_instructionVar133),
    Var134(ADD_instructionVar134),
    Var135(ADD_instructionVar135),
    Var136(ADDO_instructionVar136),
    Var137(ADD_instructionVar137),
    Var138(ADD_instructionVar138),
    Var139(SH1ADD_instructionVar139),
    Var140(SH1ADDL_instructionVar140),
    Var141(SH1ADDO_instructionVar141),
    Var142(SH2ADD_instructionVar142),
    Var143(SH2ADDL_instructionVar143),
    Var144(SH2ADDO_instructionVar144),
    Var145(SH3ADD_instructionVar145),
    Var146(SH3ADDL_instructionVar146),
    Var147(SH3ADDO_instructionVar147),
    Var148(SUB_instructionVar148),
    Var149(SUB_instructionVar149),
    Var150(SUB_instructionVar150),
    Var151(SUB_instructionVar151),
    Var152(SUB_instructionVar152),
    Var153(SUB_instructionVar153),
    Var154(DS_instructionVar154),
    Var155(CMPCLR_instructionVar155),
    Var156(OR_instructionVar156),
    Var157(XOR_instructionVar157),
    Var158(AND_instructionVar158),
    Var159(ANDCM_instructionVar159),
    Var160(UXOR_instructionVar160),
    Var161(UADDCM_instructionVar161),
    Var162(UADDCMT_instructionVar162),
    Var163(FCPY_instructionVar163),
    Var164(FCPY_instructionVar164),
    Var165(FMPY_instructionVar165),
    Var166(FMPY_instructionVar166),
    Var167(FADD_instructionVar167),
    Var168(FADD_instructionVar168),
    Var169(FSUB_instructionVar169),
    Var170(FSUB_instructionVar170),
    Var171(FDIV_instructionVar171),
    Var172(FDIV_instructionVar172),
    Var173(FCMP_instructionVar173),
    Var174(FCMP_instructionVar174),
    Var175(SHRPW_instructionVar175),
    Var176(EXTRW_instructionVar176),
    Var177(EXTRW_instructionVar177),
    Var178(DEPW_instructionVar178),
    Var179(DEPWI_instructionVar179),
    Var180(DEPW_instructionVar180),
    Var181(DEPWI_instructionVar181),
    Var182(DCOR_instructionVar182),
    Var183(IDCOR_instructionVar183),
    Var184(FCMP_instructionVar184),
    Var185(FCMP_instructionVar185),
    Var186(ADDI_instructionVar186),
    Var187(ADDI_instructionVar187),
    Var188(ADDI_instructionVar188),
    Var189(ADDI_instructionVar189),
    Var190(SUBI_instructionVar190),
    Var191(SUBI_instructionVar191),
    Var192(CMPICLR_instructionVar192),
    Var193(FABS_instructionVar193),
    Var194(FABS_instructionVar194),
    Var195(FCPY_instructionVar195),
    Var196(FSQRT_instructionVar196),
    Var197(FSQRT_instructionVar197),
    Var198(FCNV_instructionVar198),
    Var199(FCNVXF_instructionVar199),
    Var200(FCNVFX_instructionVar200),
    Var201(FCNVFXT_instructionVar201),
    Var202(FMPY_instructionVar202),
    Var203(XMPYU_instructionVar203),
    Var204(FRND_instructionVar204),
    Var205(FRND_instructionVar205),
    Var206(FADD_instructionVar206),
    Var207(FSUB_instructionVar207),
    Var208(FDIV_instructionVar208),
    Var209(FTEST_instructionVar209),
    Var210(SPOP0_instructionVar210),
    Var211(SPOP1_instructionVar211),
    Var212(SPOP2_instructionVar212),
    Var213(SPOP3_instructionVar213),
    Var214(FLDW_instructionVar214),
    Var215(FLDW_instructionVar215),
    Var216(FLDW_instructionVar216),
    Var217(FLDW_instructionVar217),
    Var218(FSTW_instructionVar218),
    Var219(FSTW_instructionVar219),
    Var220(FSTW_instructionVar220),
    Var221(FSTW_instructionVar221),
    Var222(FSTD_instructionVar222),
    Var223(FSTD_instructionVar223),
    Var224(FSTD_instructionVar224),
    Var225(FSTD_instructionVar225),
    Var226(FLDW_instructionVar226),
    Var227(FLDW_instructionVar227),
    Var228(FSTW_instructionVar228),
    Var229(FSTW_instructionVar229),
    Var230(FLDW_instructionVar230),
    Var231(FSTW_instructionVar231),
    Var232(CLDW_instructionVar232),
    Var233(CLDD_instructionVar233),
    Var234(CSTW_instructionVar234),
    Var235(CSTD_instructionVar235),
    Var236(CLDW_instructionVar236),
    Var237(CLDD_instructionVar237),
    Var238(CSTW_instructionVar238),
    Var239(CSTD_instructionVar239),
    Var240(FMPYADD_instructionVar240),
    Var241(FMPYADD_instructionVar241),
    Var242(FMPYSUB_instructionVar242),
    Var243(FMPYSUB_instructionVar243),
    Var244(LDW_instructionVar244),
    Var245(LDH_instructionVar245),
    Var246(LDB_instructionVar246),
    Var247(STW_instructionVar247),
    Var248(STH_instructionVar248),
    Var249(STB_instructionVar249),
    Var250(LDW_instructionVar250),
    Var251(STW_instructionVar251),
    Var252(LDO_instructionVar252),
    Var253(LDIL_instructionVar253),
    Var254(ADDIL_instructionVar254),
    Var255(DIAG_instructionVar255),
    Var256(COPR_instructionVar256),
    Var257(instructionVar257),
    Var258(instructionVar258),
    Var259(instructionVar259),
    Var260(instructionVar260),
    Var261(instructionVar261),
    Var262(instructionVar262),
    Var263(instructionVar263),
    Var264(instructionVar264),
    Var265(instructionVar265),
    Var266(instructionVar266),
    Var267(instructionVar267),
    Var268(instructionVar268),
    Var269(instructionVar269),
    Var270(instructionVar270),
    Var271(instructionVar271),
    Var272(instructionVar272),
    Var273(instructionVar273),
    Var274(instructionVar274),
    Var275(instructionVar275),
    Var276(instructionVar276),
    Var277(instructionVar277),
    Var278(instructionVar278),
    Var279(instructionVar279),
    Var280(instructionVar280),
    Var281(instructionVar281),
    Var282(instructionVar282),
    Var283(instructionVar283),
    Var284(instructionVar284),
    Var285(instructionVar285),
    Var286(instructionVar286),
    Var287(instructionVar287),
    Var288(instructionVar288),
    Var289(instructionVar289),
    Var290(instructionVar290),
    Var291(instructionVar291),
}
impl Tableinstruction {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var18(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var19(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var20(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var21(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var22(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var23(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var24(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var25(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var26(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var27(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var28(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var29(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var30(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var31(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var32(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var33(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var34(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var35(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var36(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var37(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var38(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var39(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var40(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var41(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var42(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var43(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var44(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var45(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var46(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var47(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var48(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var49(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var50(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var51(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var52(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var53(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var54(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var55(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var56(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var57(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var58(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var59(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var60(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var61(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var62(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var63(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var64(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var65(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var66(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var67(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var68(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var69(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var70(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var71(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var72(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var73(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var74(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var75(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var76(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var77(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var78(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var79(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var80(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var81(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var82(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var83(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var84(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var85(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var86(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var87(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var88(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var89(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var90(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var91(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var92(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var93(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var94(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var95(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var96(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var97(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var98(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var99(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var100(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var101(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var102(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var103(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var104(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var105(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var106(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var107(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var108(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var109(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var110(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var111(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var112(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var113(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var114(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var115(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var116(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var117(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var118(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var119(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var120(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var121(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var122(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var123(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var124(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var125(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var126(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var127(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var128(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var129(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var130(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var131(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var132(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var133(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var134(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var135(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var136(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var137(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var138(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var139(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var140(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var141(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var142(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var143(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var144(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var145(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var146(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var147(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var148(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var149(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var150(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var151(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var152(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var153(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var154(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var155(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var156(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var157(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var158(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var159(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var160(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var161(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var162(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var163(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var164(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var165(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var166(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var167(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var168(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var169(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var170(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var171(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var172(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var173(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var174(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var175(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var176(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var177(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var178(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var179(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var180(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var181(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var182(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var183(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var184(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var185(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var186(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var187(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var188(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var189(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var190(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var191(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var192(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var193(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var194(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var195(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var196(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var197(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var198(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var199(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var200(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var201(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var202(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var203(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var204(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var205(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var206(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var207(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var208(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var209(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var210(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var211(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var212(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var213(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var214(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var215(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var216(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var217(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var218(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var219(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var220(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var221(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var222(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var223(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var224(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var225(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var226(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var227(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var228(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var229(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var230(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var231(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var232(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var233(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var234(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var235(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var236(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var237(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var238(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var239(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var240(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var241(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var242(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var243(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var244(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var245(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var246(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var247(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var248(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var249(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var250(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var251(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var252(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var253(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var254(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var255(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var256(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var257(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var258(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var259(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var260(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var261(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var262(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var263(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var264(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var265(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var266(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var267(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var268(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var269(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var270(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var271(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var272(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var273(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var274(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var275(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var276(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var277(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var278(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var279(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var280(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var281(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var282(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var283(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var284(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var285(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var286(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var287(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var288(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var289(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var290(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var291(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = NOP_instructionVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = COPR_0_0_instructionVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = COPY_instructionVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = SYNC_instructionVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = SYNCDMA_instructionVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = MTSM_instructionVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = IITLBT_instructionVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = SSM_instructionVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) = RSM_instructionVar8::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) = FCNVXF_instructionVar9::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) = FCNVXF_instructionVar10::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) = FCNVXF_instructionVar11::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) = FCNVXF_instructionVar12::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) = LDWAX_instructionVar13::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) = COPY_instructionVar14::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) = IDTLBA_instructionVar15::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) = IDTLBP_instructionVar16::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) = PDC_instructionVar17::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        if let Some((inst_len, parsed)) = PDC_instructionVar18::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var18(parsed)));
        }
        if let Some((inst_len, parsed)) = LDSID_instructionVar19::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var19(parsed)));
        }
        if let Some((inst_len, parsed)) = PROBER_instructionVar20::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var20(parsed)));
        }
        if let Some((inst_len, parsed)) = PROBERI_instructionVar21::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var21(parsed)));
        }
        if let Some((inst_len, parsed)) = PROBEW_instructionVar22::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var22(parsed)));
        }
        if let Some((inst_len, parsed)) = PROBEWI_instructionVar23::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var23(parsed)));
        }
        if let Some((inst_len, parsed)) = LCI_instructionVar24::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var24(parsed)));
        }
        if let Some((inst_len, parsed)) = PDTLB_instructionVar25::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var25(parsed)));
        }
        if let Some((inst_len, parsed)) = PDTLB_instructionVar26::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var26(parsed)));
        }
        if let Some((inst_len, parsed)) = PITLB_instructionVar27::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var27(parsed)));
        }
        if let Some((inst_len, parsed)) = PITLB_instructionVar28::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var28(parsed)));
        }
        if let Some((inst_len, parsed)) = PDTLBE_instructionVar29::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var29(parsed)));
        }
        if let Some((inst_len, parsed)) = PDTLBE_instructionVar30::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var30(parsed)));
        }
        if let Some((inst_len, parsed)) = PITLBE_instructionVar31::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var31(parsed)));
        }
        if let Some((inst_len, parsed)) = PITLBE_instructionVar32::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var32(parsed)));
        }
        if let Some((inst_len, parsed)) = FDC_instructionVar33::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var33(parsed)));
        }
        if let Some((inst_len, parsed)) = FDC_instructionVar34::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var34(parsed)));
        }
        if let Some((inst_len, parsed)) = FDCE_instructionVar35::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var35(parsed)));
        }
        if let Some((inst_len, parsed)) = FDCE_instructionVar36::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var36(parsed)));
        }
        if let Some((inst_len, parsed)) = PMENB_instructionVar37::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var37(parsed)));
        }
        if let Some((inst_len, parsed)) = PMDIS_instructionVar38::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var38(parsed)));
        }
        if let Some((inst_len, parsed)) = LPA_instructionVar39::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var39(parsed)));
        }
        if let Some((inst_len, parsed)) = FLDD_instructionVar40::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var40(parsed)));
        }
        if let Some((inst_len, parsed)) = FLDD_instructionVar41::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var41(parsed)));
        }
        if let Some((inst_len, parsed)) = FLDD_instructionVar42::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var42(parsed)));
        }
        if let Some((inst_len, parsed)) = FLDD_instructionVar43::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var43(parsed)));
        }
        if let Some((inst_len, parsed)) = FLDD_instructionVar44::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var44(parsed)));
        }
        if let Some((inst_len, parsed)) = FLDD_instructionVar45::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var45(parsed)));
        }
        if let Some((inst_len, parsed)) = FSTD_instructionVar46::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var46(parsed)));
        }
        if let Some((inst_len, parsed)) = FSTD_instructionVar47::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var47(parsed)));
        }
        if let Some((inst_len, parsed)) = STBYS_instructionVar48::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var48(parsed)));
        }
        if let Some((inst_len, parsed)) = STBYS_instructionVar49::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var49(parsed)));
        }
        if let Some((inst_len, parsed)) = MTSAR_instructionVar50::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var50(parsed)));
        }
        if let Some((inst_len, parsed)) = RFI_instructionVar51::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var51(parsed)));
        }
        if let Some((inst_len, parsed)) = RFI_instructionVar52::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var52(parsed)));
        }
        if let Some((inst_len, parsed)) = MTSP_instructionVar53::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var53(parsed)));
        }
        if let Some((inst_len, parsed)) = MTCTL_instructionVar54::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var54(parsed)));
        }
        if let Some((inst_len, parsed)) = FCNV_instructionVar55::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var55(parsed)));
        }
        if let Some((inst_len, parsed)) = FCNV_instructionVar56::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var56(parsed)));
        }
        if let Some((inst_len, parsed)) = MFSP_instructionVar57::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var57(parsed)));
        }
        if let Some((inst_len, parsed)) = MFCTL_instructionVar58::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var58(parsed)));
        }
        if let Some((inst_len, parsed)) = MFIA_instructionVar59::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var59(parsed)));
        }
        if let Some((inst_len, parsed)) = IITLBA_instructionVar60::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var60(parsed)));
        }
        if let Some((inst_len, parsed)) = IITLBP_instructionVar61::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var61(parsed)));
        }
        if let Some((inst_len, parsed)) = SHRPW_instructionVar62::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var62(parsed)));
        }
        if let Some((inst_len, parsed)) = EXTRW_instructionVar63::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var63(parsed)));
        }
        if let Some((inst_len, parsed)) = EXTRW_instructionVar64::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var64(parsed)));
        }
        if let Some((inst_len, parsed)) = DEPW_instructionVar65::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var65(parsed)));
        }
        if let Some((inst_len, parsed)) = DEPWI_instructionVar66::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var66(parsed)));
        }
        if let Some((inst_len, parsed)) = DEPW_instructionVar67::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var67(parsed)));
        }
        if let Some((inst_len, parsed)) = DEPWI_instructionVar68::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var68(parsed)));
        }
        if let Some((inst_len, parsed)) = BREAK_instructionVar69::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var69(parsed)));
        }
        if let Some((inst_len, parsed)) = FIC_instructionVar70::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var70(parsed)));
        }
        if let Some((inst_len, parsed)) = FIC_instructionVar71::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var71(parsed)));
        }
        if let Some((inst_len, parsed)) = FICE_instructionVar72::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var72(parsed)));
        }
        if let Some((inst_len, parsed)) = FICE_instructionVar73::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var73(parsed)));
        }
        if let Some((inst_len, parsed)) = FLDD_instructionVar74::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var74(parsed)));
        }
        if let Some((inst_len, parsed)) = FSTD_instructionVar75::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var75(parsed)));
        }
        if let Some((inst_len, parsed)) = FCNVFX_instructionVar76::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var76(parsed)));
        }
        if let Some((inst_len, parsed)) = FCNVFX_instructionVar77::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var77(parsed)));
        }
        if let Some((inst_len, parsed)) = FCNVFXT_instructionVar78::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var78(parsed)));
        }
        if let Some((inst_len, parsed)) = FCNVFXT_instructionVar79::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var79(parsed)));
        }
        if let Some((inst_len, parsed)) = LDW_instructionVar80::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var80(parsed)));
        }
        if let Some((inst_len, parsed)) = LDH_instructionVar81::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var81(parsed)));
        }
        if let Some((inst_len, parsed)) = LDB_instructionVar82::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var82(parsed)));
        }
        if let Some((inst_len, parsed)) = LDCWX_instructionVar83::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var83(parsed)));
        }
        if let Some((inst_len, parsed)) = LDW_instructionVar84::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var84(parsed)));
        }
        if let Some((inst_len, parsed)) = LDH_instructionVar85::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var85(parsed)));
        }
        if let Some((inst_len, parsed)) = LDB_instructionVar86::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var86(parsed)));
        }
        if let Some((inst_len, parsed)) = STW_instructionVar87::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var87(parsed)));
        }
        if let Some((inst_len, parsed)) = STH_instructionVar88::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var88(parsed)));
        }
        if let Some((inst_len, parsed)) = STB_instructionVar89::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var89(parsed)));
        }
        if let Some((inst_len, parsed)) = LDWAS_instructionVar90::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var90(parsed)));
        }
        if let Some((inst_len, parsed)) = LDCWS_instructionVar91::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var91(parsed)));
        }
        if let Some((inst_len, parsed)) = STWAS_instructionVar92::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var92(parsed)));
        }
        if let Some((inst_len, parsed)) = B_instructionVar93::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var93(parsed)));
        }
        if let Some((inst_len, parsed)) = B_instructionVar94::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var94(parsed)));
        }
        if let Some((inst_len, parsed)) = LDI_instructionVar95::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var95(parsed)));
        }
        if let Some((inst_len, parsed)) = BV_instructionVar96::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var96(parsed)));
        }
        if let Some((inst_len, parsed)) = BV_instructionVar97::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var97(parsed)));
        }
        if let Some((inst_len, parsed)) = BV_instructionVar98::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var98(parsed)));
        }
        if let Some((inst_len, parsed)) = BV_instructionVar99::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var99(parsed)));
        }
        if let Some((inst_len, parsed)) = B_instructionVar100::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var100(parsed)));
        }
        if let Some((inst_len, parsed)) = B_instructionVar101::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var101(parsed)));
        }
        if let Some((inst_len, parsed)) = BLR_instructionVar102::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var102(parsed)));
        }
        if let Some((inst_len, parsed)) = BLR_instructionVar103::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var103(parsed)));
        }
        if let Some((inst_len, parsed)) = B_instructionVar104::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var104(parsed)));
        }
        if let Some((inst_len, parsed)) = B_instructionVar105::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var105(parsed)));
        }
        if let Some((inst_len, parsed)) = CMPBT_instructionVar106::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var106(parsed)));
        }
        if let Some((inst_len, parsed)) = CMPBT_instructionVar107::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var107(parsed)));
        }
        if let Some((inst_len, parsed)) = CMPBF_instructionVar108::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var108(parsed)));
        }
        if let Some((inst_len, parsed)) = CMPBF_instructionVar109::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var109(parsed)));
        }
        if let Some((inst_len, parsed)) = CMPIBT_instructionVar110::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var110(parsed)));
        }
        if let Some((inst_len, parsed)) = CMPIBT_instructionVar111::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var111(parsed)));
        }
        if let Some((inst_len, parsed)) = CMPIBF_instructionVar112::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var112(parsed)));
        }
        if let Some((inst_len, parsed)) = CMPIBF_instructionVar113::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var113(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVB_instructionVar114::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var114(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVB_instructionVar115::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var115(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVIB_instructionVar116::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var116(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVIB_instructionVar117::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var117(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDBT_instructionVar118::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var118(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDBT_instructionVar119::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var119(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDBF_instructionVar120::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var120(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDBF_instructionVar121::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var121(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDIBT_instructionVar122::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var122(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDIBT_instructionVar123::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var123(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDIBF_instructionVar124::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var124(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDIBF_instructionVar125::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var125(parsed)));
        }
        if let Some((inst_len, parsed)) = BB_instructionVar126::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var126(parsed)));
        }
        if let Some((inst_len, parsed)) = BB_instructionVar127::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var127(parsed)));
        }
        if let Some((inst_len, parsed)) = BB_instructionVar128::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var128(parsed)));
        }
        if let Some((inst_len, parsed)) = BB_instructionVar129::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var129(parsed)));
        }
        if let Some((inst_len, parsed)) = BE_instructionVar130::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var130(parsed)));
        }
        if let Some((inst_len, parsed)) = BE_instructionVar131::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var131(parsed)));
        }
        if let Some((inst_len, parsed)) = BE_instructionVar132::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var132(parsed)));
        }
        if let Some((inst_len, parsed)) = BE_instructionVar133::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var133(parsed)));
        }
        if let Some((inst_len, parsed)) = ADD_instructionVar134::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var134(parsed)));
        }
        if let Some((inst_len, parsed)) = ADD_instructionVar135::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var135(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDO_instructionVar136::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var136(parsed)));
        }
        if let Some((inst_len, parsed)) = ADD_instructionVar137::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var137(parsed)));
        }
        if let Some((inst_len, parsed)) = ADD_instructionVar138::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var138(parsed)));
        }
        if let Some((inst_len, parsed)) = SH1ADD_instructionVar139::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var139(parsed)));
        }
        if let Some((inst_len, parsed)) = SH1ADDL_instructionVar140::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var140(parsed)));
        }
        if let Some((inst_len, parsed)) = SH1ADDO_instructionVar141::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var141(parsed)));
        }
        if let Some((inst_len, parsed)) = SH2ADD_instructionVar142::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var142(parsed)));
        }
        if let Some((inst_len, parsed)) = SH2ADDL_instructionVar143::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var143(parsed)));
        }
        if let Some((inst_len, parsed)) = SH2ADDO_instructionVar144::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var144(parsed)));
        }
        if let Some((inst_len, parsed)) = SH3ADD_instructionVar145::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var145(parsed)));
        }
        if let Some((inst_len, parsed)) = SH3ADDL_instructionVar146::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var146(parsed)));
        }
        if let Some((inst_len, parsed)) = SH3ADDO_instructionVar147::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var147(parsed)));
        }
        if let Some((inst_len, parsed)) = SUB_instructionVar148::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var148(parsed)));
        }
        if let Some((inst_len, parsed)) = SUB_instructionVar149::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var149(parsed)));
        }
        if let Some((inst_len, parsed)) = SUB_instructionVar150::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var150(parsed)));
        }
        if let Some((inst_len, parsed)) = SUB_instructionVar151::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var151(parsed)));
        }
        if let Some((inst_len, parsed)) = SUB_instructionVar152::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var152(parsed)));
        }
        if let Some((inst_len, parsed)) = SUB_instructionVar153::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var153(parsed)));
        }
        if let Some((inst_len, parsed)) = DS_instructionVar154::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var154(parsed)));
        }
        if let Some((inst_len, parsed)) = CMPCLR_instructionVar155::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var155(parsed)));
        }
        if let Some((inst_len, parsed)) = OR_instructionVar156::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var156(parsed)));
        }
        if let Some((inst_len, parsed)) = XOR_instructionVar157::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var157(parsed)));
        }
        if let Some((inst_len, parsed)) = AND_instructionVar158::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var158(parsed)));
        }
        if let Some((inst_len, parsed)) = ANDCM_instructionVar159::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var159(parsed)));
        }
        if let Some((inst_len, parsed)) = UXOR_instructionVar160::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var160(parsed)));
        }
        if let Some((inst_len, parsed)) = UADDCM_instructionVar161::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var161(parsed)));
        }
        if let Some((inst_len, parsed)) = UADDCMT_instructionVar162::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var162(parsed)));
        }
        if let Some((inst_len, parsed)) = FCPY_instructionVar163::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var163(parsed)));
        }
        if let Some((inst_len, parsed)) = FCPY_instructionVar164::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var164(parsed)));
        }
        if let Some((inst_len, parsed)) = FMPY_instructionVar165::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var165(parsed)));
        }
        if let Some((inst_len, parsed)) = FMPY_instructionVar166::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var166(parsed)));
        }
        if let Some((inst_len, parsed)) = FADD_instructionVar167::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var167(parsed)));
        }
        if let Some((inst_len, parsed)) = FADD_instructionVar168::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var168(parsed)));
        }
        if let Some((inst_len, parsed)) = FSUB_instructionVar169::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var169(parsed)));
        }
        if let Some((inst_len, parsed)) = FSUB_instructionVar170::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var170(parsed)));
        }
        if let Some((inst_len, parsed)) = FDIV_instructionVar171::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var171(parsed)));
        }
        if let Some((inst_len, parsed)) = FDIV_instructionVar172::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var172(parsed)));
        }
        if let Some((inst_len, parsed)) = FCMP_instructionVar173::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var173(parsed)));
        }
        if let Some((inst_len, parsed)) = FCMP_instructionVar174::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var174(parsed)));
        }
        if let Some((inst_len, parsed)) = SHRPW_instructionVar175::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var175(parsed)));
        }
        if let Some((inst_len, parsed)) = EXTRW_instructionVar176::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var176(parsed)));
        }
        if let Some((inst_len, parsed)) = EXTRW_instructionVar177::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var177(parsed)));
        }
        if let Some((inst_len, parsed)) = DEPW_instructionVar178::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var178(parsed)));
        }
        if let Some((inst_len, parsed)) = DEPWI_instructionVar179::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var179(parsed)));
        }
        if let Some((inst_len, parsed)) = DEPW_instructionVar180::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var180(parsed)));
        }
        if let Some((inst_len, parsed)) = DEPWI_instructionVar181::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var181(parsed)));
        }
        if let Some((inst_len, parsed)) = DCOR_instructionVar182::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var182(parsed)));
        }
        if let Some((inst_len, parsed)) = IDCOR_instructionVar183::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var183(parsed)));
        }
        if let Some((inst_len, parsed)) = FCMP_instructionVar184::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var184(parsed)));
        }
        if let Some((inst_len, parsed)) = FCMP_instructionVar185::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var185(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDI_instructionVar186::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var186(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDI_instructionVar187::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var187(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDI_instructionVar188::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var188(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDI_instructionVar189::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var189(parsed)));
        }
        if let Some((inst_len, parsed)) = SUBI_instructionVar190::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var190(parsed)));
        }
        if let Some((inst_len, parsed)) = SUBI_instructionVar191::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var191(parsed)));
        }
        if let Some((inst_len, parsed)) = CMPICLR_instructionVar192::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var192(parsed)));
        }
        if let Some((inst_len, parsed)) = FABS_instructionVar193::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var193(parsed)));
        }
        if let Some((inst_len, parsed)) = FABS_instructionVar194::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var194(parsed)));
        }
        if let Some((inst_len, parsed)) = FCPY_instructionVar195::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var195(parsed)));
        }
        if let Some((inst_len, parsed)) = FSQRT_instructionVar196::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var196(parsed)));
        }
        if let Some((inst_len, parsed)) = FSQRT_instructionVar197::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var197(parsed)));
        }
        if let Some((inst_len, parsed)) = FCNV_instructionVar198::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var198(parsed)));
        }
        if let Some((inst_len, parsed)) = FCNVXF_instructionVar199::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var199(parsed)));
        }
        if let Some((inst_len, parsed)) = FCNVFX_instructionVar200::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var200(parsed)));
        }
        if let Some((inst_len, parsed)) = FCNVFXT_instructionVar201::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var201(parsed)));
        }
        if let Some((inst_len, parsed)) = FMPY_instructionVar202::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var202(parsed)));
        }
        if let Some((inst_len, parsed)) = XMPYU_instructionVar203::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var203(parsed)));
        }
        if let Some((inst_len, parsed)) = FRND_instructionVar204::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var204(parsed)));
        }
        if let Some((inst_len, parsed)) = FRND_instructionVar205::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var205(parsed)));
        }
        if let Some((inst_len, parsed)) = FADD_instructionVar206::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var206(parsed)));
        }
        if let Some((inst_len, parsed)) = FSUB_instructionVar207::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var207(parsed)));
        }
        if let Some((inst_len, parsed)) = FDIV_instructionVar208::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var208(parsed)));
        }
        if let Some((inst_len, parsed)) = FTEST_instructionVar209::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var209(parsed)));
        }
        if let Some((inst_len, parsed)) = SPOP0_instructionVar210::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var210(parsed)));
        }
        if let Some((inst_len, parsed)) = SPOP1_instructionVar211::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var211(parsed)));
        }
        if let Some((inst_len, parsed)) = SPOP2_instructionVar212::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var212(parsed)));
        }
        if let Some((inst_len, parsed)) = SPOP3_instructionVar213::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var213(parsed)));
        }
        if let Some((inst_len, parsed)) = FLDW_instructionVar214::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var214(parsed)));
        }
        if let Some((inst_len, parsed)) = FLDW_instructionVar215::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var215(parsed)));
        }
        if let Some((inst_len, parsed)) = FLDW_instructionVar216::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var216(parsed)));
        }
        if let Some((inst_len, parsed)) = FLDW_instructionVar217::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var217(parsed)));
        }
        if let Some((inst_len, parsed)) = FSTW_instructionVar218::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var218(parsed)));
        }
        if let Some((inst_len, parsed)) = FSTW_instructionVar219::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var219(parsed)));
        }
        if let Some((inst_len, parsed)) = FSTW_instructionVar220::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var220(parsed)));
        }
        if let Some((inst_len, parsed)) = FSTW_instructionVar221::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var221(parsed)));
        }
        if let Some((inst_len, parsed)) = FSTD_instructionVar222::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var222(parsed)));
        }
        if let Some((inst_len, parsed)) = FSTD_instructionVar223::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var223(parsed)));
        }
        if let Some((inst_len, parsed)) = FSTD_instructionVar224::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var224(parsed)));
        }
        if let Some((inst_len, parsed)) = FSTD_instructionVar225::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var225(parsed)));
        }
        if let Some((inst_len, parsed)) = FLDW_instructionVar226::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var226(parsed)));
        }
        if let Some((inst_len, parsed)) = FLDW_instructionVar227::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var227(parsed)));
        }
        if let Some((inst_len, parsed)) = FSTW_instructionVar228::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var228(parsed)));
        }
        if let Some((inst_len, parsed)) = FSTW_instructionVar229::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var229(parsed)));
        }
        if let Some((inst_len, parsed)) = FLDW_instructionVar230::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var230(parsed)));
        }
        if let Some((inst_len, parsed)) = FSTW_instructionVar231::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var231(parsed)));
        }
        if let Some((inst_len, parsed)) = CLDW_instructionVar232::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var232(parsed)));
        }
        if let Some((inst_len, parsed)) = CLDD_instructionVar233::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var233(parsed)));
        }
        if let Some((inst_len, parsed)) = CSTW_instructionVar234::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var234(parsed)));
        }
        if let Some((inst_len, parsed)) = CSTD_instructionVar235::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var235(parsed)));
        }
        if let Some((inst_len, parsed)) = CLDW_instructionVar236::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var236(parsed)));
        }
        if let Some((inst_len, parsed)) = CLDD_instructionVar237::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var237(parsed)));
        }
        if let Some((inst_len, parsed)) = CSTW_instructionVar238::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var238(parsed)));
        }
        if let Some((inst_len, parsed)) = CSTD_instructionVar239::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var239(parsed)));
        }
        if let Some((inst_len, parsed)) = FMPYADD_instructionVar240::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var240(parsed)));
        }
        if let Some((inst_len, parsed)) = FMPYADD_instructionVar241::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var241(parsed)));
        }
        if let Some((inst_len, parsed)) = FMPYSUB_instructionVar242::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var242(parsed)));
        }
        if let Some((inst_len, parsed)) = FMPYSUB_instructionVar243::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var243(parsed)));
        }
        if let Some((inst_len, parsed)) = LDW_instructionVar244::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var244(parsed)));
        }
        if let Some((inst_len, parsed)) = LDH_instructionVar245::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var245(parsed)));
        }
        if let Some((inst_len, parsed)) = LDB_instructionVar246::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var246(parsed)));
        }
        if let Some((inst_len, parsed)) = STW_instructionVar247::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var247(parsed)));
        }
        if let Some((inst_len, parsed)) = STH_instructionVar248::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var248(parsed)));
        }
        if let Some((inst_len, parsed)) = STB_instructionVar249::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var249(parsed)));
        }
        if let Some((inst_len, parsed)) = LDW_instructionVar250::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var250(parsed)));
        }
        if let Some((inst_len, parsed)) = STW_instructionVar251::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var251(parsed)));
        }
        if let Some((inst_len, parsed)) = LDO_instructionVar252::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var252(parsed)));
        }
        if let Some((inst_len, parsed)) = LDIL_instructionVar253::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var253(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDIL_instructionVar254::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var254(parsed)));
        }
        if let Some((inst_len, parsed)) = DIAG_instructionVar255::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var255(parsed)));
        }
        if let Some((inst_len, parsed)) = COPR_instructionVar256::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var256(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar257::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var257(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar258::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var258(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar259::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var259(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar260::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var260(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar261::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var261(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar262::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var262(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar263::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var263(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar264::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var264(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar265::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var265(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar266::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var266(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar267::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var267(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar268::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var268(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar269::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var269(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar270::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var270(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar271::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var271(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar272::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var272(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar273::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var273(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar274::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var274(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar275::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var275(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar276::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var276(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar277::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var277(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar278::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var278(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar279::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var279(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar280::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var280(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar281::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var281(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar282::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var282(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar283::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var283(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar284::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var284(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar285::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var285(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar286::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var286(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar287::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var287(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar288::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var288(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar289::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var289(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar290::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var290(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar291::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var291(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:458:1, end:458:14))"]
#[derive(Clone, Debug)]
struct immediateDestVar0 {}
impl immediateDestVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableimmediateDest {
    Var0(immediateDestVar0),
}
impl TableimmediateDest {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = immediateDestVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:942:1, end:942:3))"]
#[derive(Clone, Debug)]
struct R1Var0 {
    reg1: TokenField_reg1,
}
impl R1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.reg1.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldreg1().disassembly() != 0i128 {
            return None;
        }
        let reg1 = token_parser.TokenFieldreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:943:1, end:943:3))"]
#[derive(Clone, Debug)]
struct R1Var1 {
    reg1: TokenField_reg1,
}
impl R1Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.reg1.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let reg1 = token_parser.TokenFieldreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg1 }))
    }
}
#[derive(Clone, Debug)]
enum TableR1 {
    Var0(R1Var0),
    Var1(R1Var1),
}
impl TableR1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            R1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            R1Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:944:1, end:944:6))"]
#[derive(Clone, Debug)]
struct R1dstVar0 {
    reg1: TokenField_reg1,
}
impl R1dstVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.reg1.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let reg1 = token_parser.TokenFieldreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg1 }))
    }
}
#[derive(Clone, Debug)]
enum TableR1dst {
    Var0(R1dstVar0),
}
impl TableR1dst {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            R1dstVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:946:1, end:946:3))"]
#[derive(Clone, Debug)]
struct R2Var0 {
    reg2: TokenField_reg2,
}
impl R2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.reg2.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldreg2().disassembly() != 0i128 {
            return None;
        }
        let reg2 = token_parser.TokenFieldreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:947:1, end:947:3))"]
#[derive(Clone, Debug)]
struct R2Var1 {
    reg2: TokenField_reg2,
}
impl R2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.reg2.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let reg2 = token_parser.TokenFieldreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg2 }))
    }
}
#[derive(Clone, Debug)]
enum TableR2 {
    Var0(R2Var0),
    Var1(R2Var1),
}
impl TableR2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            R2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            R2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:948:1, end:948:6))"]
#[derive(Clone, Debug)]
struct R2dstVar0 {
    reg2: TokenField_reg2,
}
impl R2dstVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.reg2.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let reg2 = token_parser.TokenFieldreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg2 }))
    }
}
#[derive(Clone, Debug)]
enum TableR2dst {
    Var0(R2dstVar0),
}
impl TableR2dst {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            R2dstVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:950:1, end:950:3))"]
#[derive(Clone, Debug)]
struct RTVar0 {
    t: TokenField_t,
}
impl RTVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.t.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let t = token_parser.TokenFieldt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { t }))
    }
}
#[derive(Clone, Debug)]
enum TableRT {
    Var0(RTVar0),
}
impl TableRT {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            RTVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:952:1, end:952:3))"]
#[derive(Clone, Debug)]
struct RBVar0 {
    b: TokenField_b,
}
impl RBVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.b.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldb().disassembly() != 0i128 {
            return None;
        }
        let b = token_parser.TokenFieldb();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { b }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:953:1, end:953:3))"]
#[derive(Clone, Debug)]
struct RBVar1 {
    b: TokenField_b,
}
impl RBVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.b.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let b = token_parser.TokenFieldb();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { b }))
    }
}
#[derive(Clone, Debug)]
enum TableRB {
    Var0(RBVar0),
    Var1(RBVar1),
}
impl TableRB {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            RBVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            RBVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:955:1, end:955:3))"]
#[derive(Clone, Debug)]
struct RXVar0 {}
impl RXVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldx().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:956:1, end:956:3))"]
#[derive(Clone, Debug)]
struct RXVar1 {
    x: TokenField_x,
}
impl RXVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.x.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let x = token_parser.TokenFieldx();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { x }))
    }
}
#[derive(Clone, Debug)]
enum TableRX {
    Var0(RXVar0),
    Var1(RXVar1),
}
impl TableRX {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            RXVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            RXVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:958:1, end:958:3))"]
#[derive(Clone, Debug)]
struct RRVar0 {
    r: TokenField_r,
}
impl RRVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.r.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldr().disassembly() != 0i128 {
            return None;
        }
        let r = token_parser.TokenFieldr();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:959:1, end:959:3))"]
#[derive(Clone, Debug)]
struct RRVar1 {
    r: TokenField_r,
}
impl RRVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.r.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let r = token_parser.TokenFieldr();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r }))
    }
}
#[derive(Clone, Debug)]
enum TableRR {
    Var0(RRVar0),
    Var1(RRVar1),
}
impl TableRR {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            RRVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            RRVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:961:1, end:961:4))"]
#[derive(Clone, Debug)]
struct SARVar0 {}
impl SARVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("SAR")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSAR {
    Var0(SARVar0),
}
impl TableSAR {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            SARVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:962:1, end:962:4))"]
#[derive(Clone, Debug)]
struct SR0Var0 {}
impl SR0Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr0)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSR0 {
    Var0(SR0Var0),
}
impl TableSR0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            SR0Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:963:1, end:963:4))"]
#[derive(Clone, Debug)]
struct R31Var0 {}
impl R31Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r31)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableR31 {
    Var0(R31Var0),
}
impl TableR31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            R31Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:966:1, end:966:7))"]
#[derive(Clone, Debug)]
struct FPR164Var0 {
    freg1: TokenField_freg1,
}
impl FPR164Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.freg1.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[derive(Clone, Debug)]
enum TableFPR164 {
    Var0(FPR164Var0),
}
impl TableFPR164 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            FPR164Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:967:1, end:967:7))"]
#[derive(Clone, Debug)]
struct FPR264Var0 {
    freg2: TokenField_freg2,
}
impl FPR264Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.freg2.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[derive(Clone, Debug)]
enum TableFPR264 {
    Var0(FPR264Var0),
}
impl TableFPR264 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            FPR264Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:968:1, end:968:7))"]
#[derive(Clone, Debug)]
struct FPRT64Var0 {
    fpt: TokenField_fpt,
}
impl FPRT64Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.fpt.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[derive(Clone, Debug)]
enum TableFPRT64 {
    Var0(FPRT64Var0),
}
impl TableFPRT64 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            FPRT64Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:971:1, end:971:8))"]
#[derive(Clone, Debug)]
struct FUSEDR1Var0 {
    fusedr1: TokenField_fusedr1,
}
impl FUSEDR1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.fusedr1.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let fusedr1 = token_parser.TokenFieldfusedr1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fusedr1 }))
    }
}
#[derive(Clone, Debug)]
enum TableFUSEDR1 {
    Var0(FUSEDR1Var0),
}
impl TableFUSEDR1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            FUSEDR1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:972:1, end:972:8))"]
#[derive(Clone, Debug)]
struct FUSEDR2Var0 {
    fusedr2: TokenField_fusedr2,
}
impl FUSEDR2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.fusedr2.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let fusedr2 = token_parser.TokenFieldfusedr2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fusedr2 }))
    }
}
#[derive(Clone, Debug)]
enum TableFUSEDR2 {
    Var0(FUSEDR2Var0),
}
impl TableFUSEDR2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            FUSEDR2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:973:1, end:973:8))"]
#[derive(Clone, Debug)]
struct FUSEDRAVar0 {
    fusedra: TokenField_fusedra,
}
impl FUSEDRAVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.fusedra.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let fusedra = token_parser.TokenFieldfusedra();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fusedra }))
    }
}
#[derive(Clone, Debug)]
enum TableFUSEDRA {
    Var0(FUSEDRAVar0),
}
impl TableFUSEDRA {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            FUSEDRAVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:974:1, end:974:8))"]
#[derive(Clone, Debug)]
struct FUSEDTAVar0 {
    fusedta: TokenField_fusedta,
}
impl FUSEDTAVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.fusedta.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let fusedta = token_parser.TokenFieldfusedta();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fusedta }))
    }
}
#[derive(Clone, Debug)]
enum TableFUSEDTA {
    Var0(FUSEDTAVar0),
}
impl TableFUSEDTA {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            FUSEDTAVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:975:1, end:975:8))"]
#[derive(Clone, Debug)]
struct FUSEDRTVar0 {
    fusedrt: TokenField_fusedrt,
}
impl FUSEDRTVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.fusedrt.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let fusedrt = token_parser.TokenFieldfusedrt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fusedrt }))
    }
}
#[derive(Clone, Debug)]
enum TableFUSEDRT {
    Var0(FUSEDRTVar0),
}
impl TableFUSEDRT {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            FUSEDRTVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:978:1, end:978:7))"]
#[derive(Clone, Debug)]
struct FPR132Var0 {
    freg1: TokenField_freg1,
}
impl FPR132Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 0i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:979:1, end:979:7))"]
#[derive(Clone, Debug)]
struct FPR132Var1 {
    freg1: TokenField_freg1,
}
impl FPR132Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 1i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:980:1, end:980:7))"]
#[derive(Clone, Debug)]
struct FPR132Var2 {
    freg1: TokenField_freg1,
}
impl FPR132Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 2i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:981:1, end:981:7))"]
#[derive(Clone, Debug)]
struct FPR132Var3 {
    freg1: TokenField_freg1,
}
impl FPR132Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 3i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:982:1, end:982:7))"]
#[derive(Clone, Debug)]
struct FPR132Var4 {
    freg1: TokenField_freg1,
}
impl FPR132Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 4i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:983:1, end:983:7))"]
#[derive(Clone, Debug)]
struct FPR132Var5 {
    freg1: TokenField_freg1,
}
impl FPR132Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 5i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:984:1, end:984:7))"]
#[derive(Clone, Debug)]
struct FPR132Var6 {
    freg1: TokenField_freg1,
}
impl FPR132Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 6i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:985:1, end:985:7))"]
#[derive(Clone, Debug)]
struct FPR132Var7 {
    freg1: TokenField_freg1,
}
impl FPR132Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 7i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:986:1, end:986:7))"]
#[derive(Clone, Debug)]
struct FPR132Var8 {
    freg1: TokenField_freg1,
}
impl FPR132Var8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 8i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:987:1, end:987:7))"]
#[derive(Clone, Debug)]
struct FPR132Var9 {
    freg1: TokenField_freg1,
}
impl FPR132Var9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 9i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:988:1, end:988:7))"]
#[derive(Clone, Debug)]
struct FPR132Var10 {
    freg1: TokenField_freg1,
}
impl FPR132Var10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 10i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:989:1, end:989:7))"]
#[derive(Clone, Debug)]
struct FPR132Var11 {
    freg1: TokenField_freg1,
}
impl FPR132Var11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 11i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:990:1, end:990:7))"]
#[derive(Clone, Debug)]
struct FPR132Var12 {
    freg1: TokenField_freg1,
}
impl FPR132Var12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 12i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:991:1, end:991:7))"]
#[derive(Clone, Debug)]
struct FPR132Var13 {
    freg1: TokenField_freg1,
}
impl FPR132Var13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 13i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:992:1, end:992:7))"]
#[derive(Clone, Debug)]
struct FPR132Var14 {
    freg1: TokenField_freg1,
}
impl FPR132Var14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 14i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:993:1, end:993:7))"]
#[derive(Clone, Debug)]
struct FPR132Var15 {
    freg1: TokenField_freg1,
}
impl FPR132Var15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 15i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:994:1, end:994:7))"]
#[derive(Clone, Debug)]
struct FPR132Var16 {
    freg1: TokenField_freg1,
}
impl FPR132Var16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 16i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:995:1, end:995:7))"]
#[derive(Clone, Debug)]
struct FPR132Var17 {
    freg1: TokenField_freg1,
}
impl FPR132Var17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 17i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:996:1, end:996:7))"]
#[derive(Clone, Debug)]
struct FPR132Var18 {
    freg1: TokenField_freg1,
}
impl FPR132Var18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 18i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:997:1, end:997:7))"]
#[derive(Clone, Debug)]
struct FPR132Var19 {
    freg1: TokenField_freg1,
}
impl FPR132Var19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 19i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:998:1, end:998:7))"]
#[derive(Clone, Debug)]
struct FPR132Var20 {
    freg1: TokenField_freg1,
}
impl FPR132Var20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 20i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:999:1, end:999:7))"]
#[derive(Clone, Debug)]
struct FPR132Var21 {
    freg1: TokenField_freg1,
}
impl FPR132Var21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 21i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1000:1, end:1000:7))"]
#[derive(Clone, Debug)]
struct FPR132Var22 {
    freg1: TokenField_freg1,
}
impl FPR132Var22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 22i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1001:1, end:1001:7))"]
#[derive(Clone, Debug)]
struct FPR132Var23 {
    freg1: TokenField_freg1,
}
impl FPR132Var23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 23i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1002:1, end:1002:7))"]
#[derive(Clone, Debug)]
struct FPR132Var24 {
    freg1: TokenField_freg1,
}
impl FPR132Var24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 24i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1003:1, end:1003:7))"]
#[derive(Clone, Debug)]
struct FPR132Var25 {
    freg1: TokenField_freg1,
}
impl FPR132Var25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 25i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1004:1, end:1004:7))"]
#[derive(Clone, Debug)]
struct FPR132Var26 {
    freg1: TokenField_freg1,
}
impl FPR132Var26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 26i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1005:1, end:1005:7))"]
#[derive(Clone, Debug)]
struct FPR132Var27 {
    freg1: TokenField_freg1,
}
impl FPR132Var27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 27i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1006:1, end:1006:7))"]
#[derive(Clone, Debug)]
struct FPR132Var28 {
    freg1: TokenField_freg1,
}
impl FPR132Var28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 28i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1007:1, end:1007:7))"]
#[derive(Clone, Debug)]
struct FPR132Var29 {
    freg1: TokenField_freg1,
}
impl FPR132Var29 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 29i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1008:1, end:1008:7))"]
#[derive(Clone, Debug)]
struct FPR132Var30 {
    freg1: TokenField_freg1,
}
impl FPR132Var30 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 30i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1009:1, end:1009:7))"]
#[derive(Clone, Debug)]
struct FPR132Var31 {
    freg1: TokenField_freg1,
}
impl FPR132Var31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 31i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1010:1, end:1010:7))"]
#[derive(Clone, Debug)]
struct FPR132Var32 {
    freg1: TokenField_freg1,
}
impl FPR132Var32 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 0i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1011:1, end:1011:7))"]
#[derive(Clone, Debug)]
struct FPR132Var33 {
    freg1: TokenField_freg1,
}
impl FPR132Var33 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 1i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1012:1, end:1012:7))"]
#[derive(Clone, Debug)]
struct FPR132Var34 {
    freg1: TokenField_freg1,
}
impl FPR132Var34 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 2i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1013:1, end:1013:7))"]
#[derive(Clone, Debug)]
struct FPR132Var35 {
    freg1: TokenField_freg1,
}
impl FPR132Var35 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 3i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1014:1, end:1014:7))"]
#[derive(Clone, Debug)]
struct FPR132Var36 {
    freg1: TokenField_freg1,
}
impl FPR132Var36 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 4i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1015:1, end:1015:7))"]
#[derive(Clone, Debug)]
struct FPR132Var37 {
    freg1: TokenField_freg1,
}
impl FPR132Var37 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 5i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1016:1, end:1016:7))"]
#[derive(Clone, Debug)]
struct FPR132Var38 {
    freg1: TokenField_freg1,
}
impl FPR132Var38 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 6i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1017:1, end:1017:7))"]
#[derive(Clone, Debug)]
struct FPR132Var39 {
    freg1: TokenField_freg1,
}
impl FPR132Var39 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 7i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1018:1, end:1018:7))"]
#[derive(Clone, Debug)]
struct FPR132Var40 {
    freg1: TokenField_freg1,
}
impl FPR132Var40 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 8i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1019:1, end:1019:7))"]
#[derive(Clone, Debug)]
struct FPR132Var41 {
    freg1: TokenField_freg1,
}
impl FPR132Var41 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 9i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1020:1, end:1020:7))"]
#[derive(Clone, Debug)]
struct FPR132Var42 {
    freg1: TokenField_freg1,
}
impl FPR132Var42 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 10i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1021:1, end:1021:7))"]
#[derive(Clone, Debug)]
struct FPR132Var43 {
    freg1: TokenField_freg1,
}
impl FPR132Var43 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 11i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1022:1, end:1022:7))"]
#[derive(Clone, Debug)]
struct FPR132Var44 {
    freg1: TokenField_freg1,
}
impl FPR132Var44 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 12i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1023:1, end:1023:7))"]
#[derive(Clone, Debug)]
struct FPR132Var45 {
    freg1: TokenField_freg1,
}
impl FPR132Var45 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 13i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1024:1, end:1024:7))"]
#[derive(Clone, Debug)]
struct FPR132Var46 {
    freg1: TokenField_freg1,
}
impl FPR132Var46 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 14i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1025:1, end:1025:7))"]
#[derive(Clone, Debug)]
struct FPR132Var47 {
    freg1: TokenField_freg1,
}
impl FPR132Var47 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 15i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1026:1, end:1026:7))"]
#[derive(Clone, Debug)]
struct FPR132Var48 {
    freg1: TokenField_freg1,
}
impl FPR132Var48 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 16i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1027:1, end:1027:7))"]
#[derive(Clone, Debug)]
struct FPR132Var49 {
    freg1: TokenField_freg1,
}
impl FPR132Var49 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 17i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1028:1, end:1028:7))"]
#[derive(Clone, Debug)]
struct FPR132Var50 {
    freg1: TokenField_freg1,
}
impl FPR132Var50 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 18i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1029:1, end:1029:7))"]
#[derive(Clone, Debug)]
struct FPR132Var51 {
    freg1: TokenField_freg1,
}
impl FPR132Var51 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 19i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1030:1, end:1030:7))"]
#[derive(Clone, Debug)]
struct FPR132Var52 {
    freg1: TokenField_freg1,
}
impl FPR132Var52 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 20i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1031:1, end:1031:7))"]
#[derive(Clone, Debug)]
struct FPR132Var53 {
    freg1: TokenField_freg1,
}
impl FPR132Var53 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 21i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1032:1, end:1032:7))"]
#[derive(Clone, Debug)]
struct FPR132Var54 {
    freg1: TokenField_freg1,
}
impl FPR132Var54 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 22i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1033:1, end:1033:7))"]
#[derive(Clone, Debug)]
struct FPR132Var55 {
    freg1: TokenField_freg1,
}
impl FPR132Var55 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 23i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1034:1, end:1034:7))"]
#[derive(Clone, Debug)]
struct FPR132Var56 {
    freg1: TokenField_freg1,
}
impl FPR132Var56 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 24i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1035:1, end:1035:7))"]
#[derive(Clone, Debug)]
struct FPR132Var57 {
    freg1: TokenField_freg1,
}
impl FPR132Var57 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 25i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1036:1, end:1036:7))"]
#[derive(Clone, Debug)]
struct FPR132Var58 {
    freg1: TokenField_freg1,
}
impl FPR132Var58 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 26i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1037:1, end:1037:7))"]
#[derive(Clone, Debug)]
struct FPR132Var59 {
    freg1: TokenField_freg1,
}
impl FPR132Var59 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 27i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1038:1, end:1038:7))"]
#[derive(Clone, Debug)]
struct FPR132Var60 {
    freg1: TokenField_freg1,
}
impl FPR132Var60 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 28i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1039:1, end:1039:7))"]
#[derive(Clone, Debug)]
struct FPR132Var61 {
    freg1: TokenField_freg1,
}
impl FPR132Var61 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 29i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1040:1, end:1040:7))"]
#[derive(Clone, Debug)]
struct FPR132Var62 {
    freg1: TokenField_freg1,
}
impl FPR132Var62 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 30i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1041:1, end:1041:7))"]
#[derive(Clone, Debug)]
struct FPR132Var63 {
    freg1: TokenField_freg1,
}
impl FPR132Var63 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 31i128 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[derive(Clone, Debug)]
enum TableFPR132 {
    Var0(FPR132Var0),
    Var1(FPR132Var1),
    Var2(FPR132Var2),
    Var3(FPR132Var3),
    Var4(FPR132Var4),
    Var5(FPR132Var5),
    Var6(FPR132Var6),
    Var7(FPR132Var7),
    Var8(FPR132Var8),
    Var9(FPR132Var9),
    Var10(FPR132Var10),
    Var11(FPR132Var11),
    Var12(FPR132Var12),
    Var13(FPR132Var13),
    Var14(FPR132Var14),
    Var15(FPR132Var15),
    Var16(FPR132Var16),
    Var17(FPR132Var17),
    Var18(FPR132Var18),
    Var19(FPR132Var19),
    Var20(FPR132Var20),
    Var21(FPR132Var21),
    Var22(FPR132Var22),
    Var23(FPR132Var23),
    Var24(FPR132Var24),
    Var25(FPR132Var25),
    Var26(FPR132Var26),
    Var27(FPR132Var27),
    Var28(FPR132Var28),
    Var29(FPR132Var29),
    Var30(FPR132Var30),
    Var31(FPR132Var31),
    Var32(FPR132Var32),
    Var33(FPR132Var33),
    Var34(FPR132Var34),
    Var35(FPR132Var35),
    Var36(FPR132Var36),
    Var37(FPR132Var37),
    Var38(FPR132Var38),
    Var39(FPR132Var39),
    Var40(FPR132Var40),
    Var41(FPR132Var41),
    Var42(FPR132Var42),
    Var43(FPR132Var43),
    Var44(FPR132Var44),
    Var45(FPR132Var45),
    Var46(FPR132Var46),
    Var47(FPR132Var47),
    Var48(FPR132Var48),
    Var49(FPR132Var49),
    Var50(FPR132Var50),
    Var51(FPR132Var51),
    Var52(FPR132Var52),
    Var53(FPR132Var53),
    Var54(FPR132Var54),
    Var55(FPR132Var55),
    Var56(FPR132Var56),
    Var57(FPR132Var57),
    Var58(FPR132Var58),
    Var59(FPR132Var59),
    Var60(FPR132Var60),
    Var61(FPR132Var61),
    Var62(FPR132Var62),
    Var63(FPR132Var63),
}
impl TableFPR132 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var18(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var19(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var20(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var21(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var22(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var23(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var24(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var25(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var26(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var27(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var28(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var29(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var30(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var31(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var32(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var33(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var34(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var35(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var36(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var37(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var38(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var39(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var40(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var41(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var42(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var43(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var44(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var45(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var46(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var47(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var48(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var49(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var50(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var51(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var52(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var53(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var54(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var55(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var56(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var57(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var58(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var59(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var60(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var61(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var62(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var63(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            FPR132Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var12::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var13::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var14::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var15::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var16::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var17::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var18::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var18(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var19::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var19(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var20::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var20(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var21::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var21(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var22::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var22(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var23::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var23(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var24::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var24(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var25::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var25(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var26::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var26(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var27::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var27(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var28::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var28(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var29::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var29(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var30::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var30(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var31::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var31(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var32::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var32(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var33::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var33(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var34::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var34(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var35::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var35(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var36::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var36(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var37::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var37(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var38::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var38(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var39::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var39(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var40::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var40(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var41::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var41(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var42::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var42(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var43::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var43(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var44::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var44(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var45::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var45(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var46::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var46(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var47::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var47(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var48::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var48(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var49::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var49(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var50::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var50(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var51::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var51(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var52::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var52(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var53::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var53(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var54::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var54(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var55::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var55(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var56::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var56(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var57::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var57(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var58::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var58(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var59::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var59(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var60::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var60(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var61::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var61(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var62::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var62(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var63::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var63(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1043:1, end:1043:7))"]
#[derive(Clone, Debug)]
struct FPR232Var0 {
    freg2: TokenField_freg2,
}
impl FPR232Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 0i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1044:1, end:1044:7))"]
#[derive(Clone, Debug)]
struct FPR232Var1 {
    freg2: TokenField_freg2,
}
impl FPR232Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 1i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1045:1, end:1045:7))"]
#[derive(Clone, Debug)]
struct FPR232Var2 {
    freg2: TokenField_freg2,
}
impl FPR232Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 2i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1046:1, end:1046:7))"]
#[derive(Clone, Debug)]
struct FPR232Var3 {
    freg2: TokenField_freg2,
}
impl FPR232Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 3i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1047:1, end:1047:7))"]
#[derive(Clone, Debug)]
struct FPR232Var4 {
    freg2: TokenField_freg2,
}
impl FPR232Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 4i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1048:1, end:1048:7))"]
#[derive(Clone, Debug)]
struct FPR232Var5 {
    freg2: TokenField_freg2,
}
impl FPR232Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 5i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1049:1, end:1049:7))"]
#[derive(Clone, Debug)]
struct FPR232Var6 {
    freg2: TokenField_freg2,
}
impl FPR232Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 6i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1050:1, end:1050:7))"]
#[derive(Clone, Debug)]
struct FPR232Var7 {
    freg2: TokenField_freg2,
}
impl FPR232Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 7i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1051:1, end:1051:7))"]
#[derive(Clone, Debug)]
struct FPR232Var8 {
    freg2: TokenField_freg2,
}
impl FPR232Var8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 8i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1052:1, end:1052:7))"]
#[derive(Clone, Debug)]
struct FPR232Var9 {
    freg2: TokenField_freg2,
}
impl FPR232Var9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 9i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1053:1, end:1053:7))"]
#[derive(Clone, Debug)]
struct FPR232Var10 {
    freg2: TokenField_freg2,
}
impl FPR232Var10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 10i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1054:1, end:1054:7))"]
#[derive(Clone, Debug)]
struct FPR232Var11 {
    freg2: TokenField_freg2,
}
impl FPR232Var11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 11i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1055:1, end:1055:7))"]
#[derive(Clone, Debug)]
struct FPR232Var12 {
    freg2: TokenField_freg2,
}
impl FPR232Var12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 12i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1056:1, end:1056:7))"]
#[derive(Clone, Debug)]
struct FPR232Var13 {
    freg2: TokenField_freg2,
}
impl FPR232Var13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 13i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1057:1, end:1057:7))"]
#[derive(Clone, Debug)]
struct FPR232Var14 {
    freg2: TokenField_freg2,
}
impl FPR232Var14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 14i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1058:1, end:1058:7))"]
#[derive(Clone, Debug)]
struct FPR232Var15 {
    freg2: TokenField_freg2,
}
impl FPR232Var15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 15i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1059:1, end:1059:7))"]
#[derive(Clone, Debug)]
struct FPR232Var16 {
    freg2: TokenField_freg2,
}
impl FPR232Var16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 16i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1060:1, end:1060:7))"]
#[derive(Clone, Debug)]
struct FPR232Var17 {
    freg2: TokenField_freg2,
}
impl FPR232Var17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 17i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1061:1, end:1061:7))"]
#[derive(Clone, Debug)]
struct FPR232Var18 {
    freg2: TokenField_freg2,
}
impl FPR232Var18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 18i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1062:1, end:1062:7))"]
#[derive(Clone, Debug)]
struct FPR232Var19 {
    freg2: TokenField_freg2,
}
impl FPR232Var19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 19i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1063:1, end:1063:7))"]
#[derive(Clone, Debug)]
struct FPR232Var20 {
    freg2: TokenField_freg2,
}
impl FPR232Var20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 20i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1064:1, end:1064:7))"]
#[derive(Clone, Debug)]
struct FPR232Var21 {
    freg2: TokenField_freg2,
}
impl FPR232Var21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 21i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1065:1, end:1065:7))"]
#[derive(Clone, Debug)]
struct FPR232Var22 {
    freg2: TokenField_freg2,
}
impl FPR232Var22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 22i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1066:1, end:1066:7))"]
#[derive(Clone, Debug)]
struct FPR232Var23 {
    freg2: TokenField_freg2,
}
impl FPR232Var23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 23i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1067:1, end:1067:7))"]
#[derive(Clone, Debug)]
struct FPR232Var24 {
    freg2: TokenField_freg2,
}
impl FPR232Var24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 24i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1068:1, end:1068:7))"]
#[derive(Clone, Debug)]
struct FPR232Var25 {
    freg2: TokenField_freg2,
}
impl FPR232Var25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 25i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1069:1, end:1069:7))"]
#[derive(Clone, Debug)]
struct FPR232Var26 {
    freg2: TokenField_freg2,
}
impl FPR232Var26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 26i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1070:1, end:1070:7))"]
#[derive(Clone, Debug)]
struct FPR232Var27 {
    freg2: TokenField_freg2,
}
impl FPR232Var27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 27i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1071:1, end:1071:7))"]
#[derive(Clone, Debug)]
struct FPR232Var28 {
    freg2: TokenField_freg2,
}
impl FPR232Var28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 28i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1072:1, end:1072:7))"]
#[derive(Clone, Debug)]
struct FPR232Var29 {
    freg2: TokenField_freg2,
}
impl FPR232Var29 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 29i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1073:1, end:1073:7))"]
#[derive(Clone, Debug)]
struct FPR232Var30 {
    freg2: TokenField_freg2,
}
impl FPR232Var30 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 30i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1074:1, end:1074:7))"]
#[derive(Clone, Debug)]
struct FPR232Var31 {
    freg2: TokenField_freg2,
}
impl FPR232Var31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 31i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1076:1, end:1076:7))"]
#[derive(Clone, Debug)]
struct FPR232Var32 {
    freg2: TokenField_freg2,
}
impl FPR232Var32 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 0i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1077:1, end:1077:7))"]
#[derive(Clone, Debug)]
struct FPR232Var33 {
    freg2: TokenField_freg2,
}
impl FPR232Var33 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 1i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1078:1, end:1078:7))"]
#[derive(Clone, Debug)]
struct FPR232Var34 {
    freg2: TokenField_freg2,
}
impl FPR232Var34 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 2i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1079:1, end:1079:7))"]
#[derive(Clone, Debug)]
struct FPR232Var35 {
    freg2: TokenField_freg2,
}
impl FPR232Var35 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 3i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1080:1, end:1080:7))"]
#[derive(Clone, Debug)]
struct FPR232Var36 {
    freg2: TokenField_freg2,
}
impl FPR232Var36 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 4i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1081:1, end:1081:7))"]
#[derive(Clone, Debug)]
struct FPR232Var37 {
    freg2: TokenField_freg2,
}
impl FPR232Var37 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 5i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1082:1, end:1082:7))"]
#[derive(Clone, Debug)]
struct FPR232Var38 {
    freg2: TokenField_freg2,
}
impl FPR232Var38 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 6i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1083:1, end:1083:7))"]
#[derive(Clone, Debug)]
struct FPR232Var39 {
    freg2: TokenField_freg2,
}
impl FPR232Var39 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 7i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1084:1, end:1084:7))"]
#[derive(Clone, Debug)]
struct FPR232Var40 {
    freg2: TokenField_freg2,
}
impl FPR232Var40 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 8i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1085:1, end:1085:7))"]
#[derive(Clone, Debug)]
struct FPR232Var41 {
    freg2: TokenField_freg2,
}
impl FPR232Var41 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 9i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1086:1, end:1086:7))"]
#[derive(Clone, Debug)]
struct FPR232Var42 {
    freg2: TokenField_freg2,
}
impl FPR232Var42 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 10i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1087:1, end:1087:7))"]
#[derive(Clone, Debug)]
struct FPR232Var43 {
    freg2: TokenField_freg2,
}
impl FPR232Var43 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 11i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1088:1, end:1088:7))"]
#[derive(Clone, Debug)]
struct FPR232Var44 {
    freg2: TokenField_freg2,
}
impl FPR232Var44 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 12i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1089:1, end:1089:7))"]
#[derive(Clone, Debug)]
struct FPR232Var45 {
    freg2: TokenField_freg2,
}
impl FPR232Var45 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 13i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1090:1, end:1090:7))"]
#[derive(Clone, Debug)]
struct FPR232Var46 {
    freg2: TokenField_freg2,
}
impl FPR232Var46 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 14i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1091:1, end:1091:7))"]
#[derive(Clone, Debug)]
struct FPR232Var47 {
    freg2: TokenField_freg2,
}
impl FPR232Var47 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 15i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1092:1, end:1092:7))"]
#[derive(Clone, Debug)]
struct FPR232Var48 {
    freg2: TokenField_freg2,
}
impl FPR232Var48 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 16i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1093:1, end:1093:7))"]
#[derive(Clone, Debug)]
struct FPR232Var49 {
    freg2: TokenField_freg2,
}
impl FPR232Var49 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 17i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1094:1, end:1094:7))"]
#[derive(Clone, Debug)]
struct FPR232Var50 {
    freg2: TokenField_freg2,
}
impl FPR232Var50 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 18i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1095:1, end:1095:7))"]
#[derive(Clone, Debug)]
struct FPR232Var51 {
    freg2: TokenField_freg2,
}
impl FPR232Var51 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 19i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1096:1, end:1096:7))"]
#[derive(Clone, Debug)]
struct FPR232Var52 {
    freg2: TokenField_freg2,
}
impl FPR232Var52 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 20i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1097:1, end:1097:7))"]
#[derive(Clone, Debug)]
struct FPR232Var53 {
    freg2: TokenField_freg2,
}
impl FPR232Var53 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 21i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1098:1, end:1098:7))"]
#[derive(Clone, Debug)]
struct FPR232Var54 {
    freg2: TokenField_freg2,
}
impl FPR232Var54 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 22i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1099:1, end:1099:7))"]
#[derive(Clone, Debug)]
struct FPR232Var55 {
    freg2: TokenField_freg2,
}
impl FPR232Var55 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 23i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1100:1, end:1100:7))"]
#[derive(Clone, Debug)]
struct FPR232Var56 {
    freg2: TokenField_freg2,
}
impl FPR232Var56 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 24i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1101:1, end:1101:7))"]
#[derive(Clone, Debug)]
struct FPR232Var57 {
    freg2: TokenField_freg2,
}
impl FPR232Var57 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 25i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1102:1, end:1102:7))"]
#[derive(Clone, Debug)]
struct FPR232Var58 {
    freg2: TokenField_freg2,
}
impl FPR232Var58 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 26i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1103:1, end:1103:7))"]
#[derive(Clone, Debug)]
struct FPR232Var59 {
    freg2: TokenField_freg2,
}
impl FPR232Var59 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 27i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1104:1, end:1104:7))"]
#[derive(Clone, Debug)]
struct FPR232Var60 {
    freg2: TokenField_freg2,
}
impl FPR232Var60 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 28i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1105:1, end:1105:7))"]
#[derive(Clone, Debug)]
struct FPR232Var61 {
    freg2: TokenField_freg2,
}
impl FPR232Var61 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 29i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1106:1, end:1106:7))"]
#[derive(Clone, Debug)]
struct FPR232Var62 {
    freg2: TokenField_freg2,
}
impl FPR232Var62 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 30i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1107:1, end:1107:7))"]
#[derive(Clone, Debug)]
struct FPR232Var63 {
    freg2: TokenField_freg2,
}
impl FPR232Var63 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 31i128 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[derive(Clone, Debug)]
enum TableFPR232 {
    Var0(FPR232Var0),
    Var1(FPR232Var1),
    Var2(FPR232Var2),
    Var3(FPR232Var3),
    Var4(FPR232Var4),
    Var5(FPR232Var5),
    Var6(FPR232Var6),
    Var7(FPR232Var7),
    Var8(FPR232Var8),
    Var9(FPR232Var9),
    Var10(FPR232Var10),
    Var11(FPR232Var11),
    Var12(FPR232Var12),
    Var13(FPR232Var13),
    Var14(FPR232Var14),
    Var15(FPR232Var15),
    Var16(FPR232Var16),
    Var17(FPR232Var17),
    Var18(FPR232Var18),
    Var19(FPR232Var19),
    Var20(FPR232Var20),
    Var21(FPR232Var21),
    Var22(FPR232Var22),
    Var23(FPR232Var23),
    Var24(FPR232Var24),
    Var25(FPR232Var25),
    Var26(FPR232Var26),
    Var27(FPR232Var27),
    Var28(FPR232Var28),
    Var29(FPR232Var29),
    Var30(FPR232Var30),
    Var31(FPR232Var31),
    Var32(FPR232Var32),
    Var33(FPR232Var33),
    Var34(FPR232Var34),
    Var35(FPR232Var35),
    Var36(FPR232Var36),
    Var37(FPR232Var37),
    Var38(FPR232Var38),
    Var39(FPR232Var39),
    Var40(FPR232Var40),
    Var41(FPR232Var41),
    Var42(FPR232Var42),
    Var43(FPR232Var43),
    Var44(FPR232Var44),
    Var45(FPR232Var45),
    Var46(FPR232Var46),
    Var47(FPR232Var47),
    Var48(FPR232Var48),
    Var49(FPR232Var49),
    Var50(FPR232Var50),
    Var51(FPR232Var51),
    Var52(FPR232Var52),
    Var53(FPR232Var53),
    Var54(FPR232Var54),
    Var55(FPR232Var55),
    Var56(FPR232Var56),
    Var57(FPR232Var57),
    Var58(FPR232Var58),
    Var59(FPR232Var59),
    Var60(FPR232Var60),
    Var61(FPR232Var61),
    Var62(FPR232Var62),
    Var63(FPR232Var63),
}
impl TableFPR232 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var18(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var19(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var20(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var21(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var22(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var23(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var24(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var25(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var26(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var27(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var28(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var29(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var30(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var31(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var32(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var33(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var34(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var35(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var36(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var37(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var38(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var39(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var40(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var41(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var42(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var43(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var44(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var45(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var46(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var47(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var48(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var49(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var50(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var51(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var52(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var53(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var54(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var55(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var56(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var57(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var58(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var59(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var60(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var61(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var62(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var63(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            FPR232Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var12::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var13::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var14::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var15::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var16::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var17::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var18::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var18(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var19::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var19(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var20::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var20(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var21::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var21(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var22::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var22(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var23::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var23(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var24::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var24(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var25::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var25(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var26::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var26(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var27::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var27(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var28::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var28(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var29::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var29(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var30::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var30(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var31::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var31(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var32::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var32(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var33::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var33(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var34::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var34(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var35::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var35(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var36::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var36(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var37::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var37(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var38::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var38(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var39::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var39(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var40::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var40(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var41::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var41(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var42::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var42(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var43::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var43(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var44::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var44(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var45::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var45(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var46::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var46(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var47::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var47(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var48::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var48(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var49::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var49(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var50::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var50(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var51::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var51(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var52::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var52(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var53::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var53(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var54::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var54(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var55::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var55(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var56::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var56(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var57::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var57(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var58::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var58(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var59::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var59(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var60::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var60(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var61::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var61(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var62::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var62(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var63::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var63(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1109:1, end:1109:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var0 {
    fpt: TokenField_fpt,
}
impl FPRT32Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 0i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1110:1, end:1110:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var1 {
    fpt: TokenField_fpt,
}
impl FPRT32Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 1i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1111:1, end:1111:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var2 {
    fpt: TokenField_fpt,
}
impl FPRT32Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 2i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1112:1, end:1112:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var3 {
    fpt: TokenField_fpt,
}
impl FPRT32Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 3i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1113:1, end:1113:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var4 {
    fpt: TokenField_fpt,
}
impl FPRT32Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 4i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1114:1, end:1114:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var5 {
    fpt: TokenField_fpt,
}
impl FPRT32Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 5i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1115:1, end:1115:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var6 {
    fpt: TokenField_fpt,
}
impl FPRT32Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 6i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1116:1, end:1116:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var7 {
    fpt: TokenField_fpt,
}
impl FPRT32Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 7i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1117:1, end:1117:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var8 {
    fpt: TokenField_fpt,
}
impl FPRT32Var8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 8i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1118:1, end:1118:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var9 {
    fpt: TokenField_fpt,
}
impl FPRT32Var9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 9i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1119:1, end:1119:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var10 {
    fpt: TokenField_fpt,
}
impl FPRT32Var10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 10i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1120:1, end:1120:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var11 {
    fpt: TokenField_fpt,
}
impl FPRT32Var11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 11i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1121:1, end:1121:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var12 {
    fpt: TokenField_fpt,
}
impl FPRT32Var12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 12i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1122:1, end:1122:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var13 {
    fpt: TokenField_fpt,
}
impl FPRT32Var13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 13i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1123:1, end:1123:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var14 {
    fpt: TokenField_fpt,
}
impl FPRT32Var14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 14i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1124:1, end:1124:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var15 {
    fpt: TokenField_fpt,
}
impl FPRT32Var15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 15i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1125:1, end:1125:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var16 {
    fpt: TokenField_fpt,
}
impl FPRT32Var16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 16i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1126:1, end:1126:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var17 {
    fpt: TokenField_fpt,
}
impl FPRT32Var17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 17i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1127:1, end:1127:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var18 {
    fpt: TokenField_fpt,
}
impl FPRT32Var18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 18i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1128:1, end:1128:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var19 {
    fpt: TokenField_fpt,
}
impl FPRT32Var19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 19i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1129:1, end:1129:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var20 {
    fpt: TokenField_fpt,
}
impl FPRT32Var20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 20i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1130:1, end:1130:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var21 {
    fpt: TokenField_fpt,
}
impl FPRT32Var21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 21i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1131:1, end:1131:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var22 {
    fpt: TokenField_fpt,
}
impl FPRT32Var22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 22i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1132:1, end:1132:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var23 {
    fpt: TokenField_fpt,
}
impl FPRT32Var23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 23i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1133:1, end:1133:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var24 {
    fpt: TokenField_fpt,
}
impl FPRT32Var24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 24i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1134:1, end:1134:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var25 {
    fpt: TokenField_fpt,
}
impl FPRT32Var25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 25i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1135:1, end:1135:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var26 {
    fpt: TokenField_fpt,
}
impl FPRT32Var26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 26i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1136:1, end:1136:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var27 {
    fpt: TokenField_fpt,
}
impl FPRT32Var27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 27i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1137:1, end:1137:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var28 {
    fpt: TokenField_fpt,
}
impl FPRT32Var28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 28i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1138:1, end:1138:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var29 {
    fpt: TokenField_fpt,
}
impl FPRT32Var29 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 29i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1139:1, end:1139:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var30 {
    fpt: TokenField_fpt,
}
impl FPRT32Var30 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 30i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1140:1, end:1140:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var31 {
    fpt: TokenField_fpt,
}
impl FPRT32Var31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 31i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1143:1, end:1143:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var32 {
    fpt: TokenField_fpt,
}
impl FPRT32Var32 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 0i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1144:1, end:1144:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var33 {
    fpt: TokenField_fpt,
}
impl FPRT32Var33 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 1i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1145:1, end:1145:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var34 {
    fpt: TokenField_fpt,
}
impl FPRT32Var34 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 2i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1146:1, end:1146:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var35 {
    fpt: TokenField_fpt,
}
impl FPRT32Var35 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 3i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1147:1, end:1147:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var36 {
    fpt: TokenField_fpt,
}
impl FPRT32Var36 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 4i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1148:1, end:1148:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var37 {
    fpt: TokenField_fpt,
}
impl FPRT32Var37 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 5i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1149:1, end:1149:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var38 {
    fpt: TokenField_fpt,
}
impl FPRT32Var38 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 6i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1150:1, end:1150:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var39 {
    fpt: TokenField_fpt,
}
impl FPRT32Var39 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 7i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1151:1, end:1151:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var40 {
    fpt: TokenField_fpt,
}
impl FPRT32Var40 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 8i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1152:1, end:1152:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var41 {
    fpt: TokenField_fpt,
}
impl FPRT32Var41 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 9i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1153:1, end:1153:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var42 {
    fpt: TokenField_fpt,
}
impl FPRT32Var42 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 10i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1154:1, end:1154:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var43 {
    fpt: TokenField_fpt,
}
impl FPRT32Var43 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 11i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1155:1, end:1155:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var44 {
    fpt: TokenField_fpt,
}
impl FPRT32Var44 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 12i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1156:1, end:1156:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var45 {
    fpt: TokenField_fpt,
}
impl FPRT32Var45 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 13i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1157:1, end:1157:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var46 {
    fpt: TokenField_fpt,
}
impl FPRT32Var46 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 14i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1158:1, end:1158:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var47 {
    fpt: TokenField_fpt,
}
impl FPRT32Var47 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 15i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1159:1, end:1159:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var48 {
    fpt: TokenField_fpt,
}
impl FPRT32Var48 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 16i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1160:1, end:1160:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var49 {
    fpt: TokenField_fpt,
}
impl FPRT32Var49 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 17i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1161:1, end:1161:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var50 {
    fpt: TokenField_fpt,
}
impl FPRT32Var50 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 18i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1162:1, end:1162:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var51 {
    fpt: TokenField_fpt,
}
impl FPRT32Var51 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 19i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1163:1, end:1163:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var52 {
    fpt: TokenField_fpt,
}
impl FPRT32Var52 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 20i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1164:1, end:1164:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var53 {
    fpt: TokenField_fpt,
}
impl FPRT32Var53 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 21i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1165:1, end:1165:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var54 {
    fpt: TokenField_fpt,
}
impl FPRT32Var54 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 22i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1166:1, end:1166:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var55 {
    fpt: TokenField_fpt,
}
impl FPRT32Var55 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 23i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1167:1, end:1167:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var56 {
    fpt: TokenField_fpt,
}
impl FPRT32Var56 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 24i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1168:1, end:1168:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var57 {
    fpt: TokenField_fpt,
}
impl FPRT32Var57 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 25i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1169:1, end:1169:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var58 {
    fpt: TokenField_fpt,
}
impl FPRT32Var58 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 26i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1170:1, end:1170:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var59 {
    fpt: TokenField_fpt,
}
impl FPRT32Var59 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 27i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1171:1, end:1171:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var60 {
    fpt: TokenField_fpt,
}
impl FPRT32Var60 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 28i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1172:1, end:1172:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var61 {
    fpt: TokenField_fpt,
}
impl FPRT32Var61 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 29i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1173:1, end:1173:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var62 {
    fpt: TokenField_fpt,
}
impl FPRT32Var62 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 30i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1174:1, end:1174:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var63 {
    fpt: TokenField_fpt,
}
impl FPRT32Var63 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 31i128 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[derive(Clone, Debug)]
enum TableFPRT32 {
    Var0(FPRT32Var0),
    Var1(FPRT32Var1),
    Var2(FPRT32Var2),
    Var3(FPRT32Var3),
    Var4(FPRT32Var4),
    Var5(FPRT32Var5),
    Var6(FPRT32Var6),
    Var7(FPRT32Var7),
    Var8(FPRT32Var8),
    Var9(FPRT32Var9),
    Var10(FPRT32Var10),
    Var11(FPRT32Var11),
    Var12(FPRT32Var12),
    Var13(FPRT32Var13),
    Var14(FPRT32Var14),
    Var15(FPRT32Var15),
    Var16(FPRT32Var16),
    Var17(FPRT32Var17),
    Var18(FPRT32Var18),
    Var19(FPRT32Var19),
    Var20(FPRT32Var20),
    Var21(FPRT32Var21),
    Var22(FPRT32Var22),
    Var23(FPRT32Var23),
    Var24(FPRT32Var24),
    Var25(FPRT32Var25),
    Var26(FPRT32Var26),
    Var27(FPRT32Var27),
    Var28(FPRT32Var28),
    Var29(FPRT32Var29),
    Var30(FPRT32Var30),
    Var31(FPRT32Var31),
    Var32(FPRT32Var32),
    Var33(FPRT32Var33),
    Var34(FPRT32Var34),
    Var35(FPRT32Var35),
    Var36(FPRT32Var36),
    Var37(FPRT32Var37),
    Var38(FPRT32Var38),
    Var39(FPRT32Var39),
    Var40(FPRT32Var40),
    Var41(FPRT32Var41),
    Var42(FPRT32Var42),
    Var43(FPRT32Var43),
    Var44(FPRT32Var44),
    Var45(FPRT32Var45),
    Var46(FPRT32Var46),
    Var47(FPRT32Var47),
    Var48(FPRT32Var48),
    Var49(FPRT32Var49),
    Var50(FPRT32Var50),
    Var51(FPRT32Var51),
    Var52(FPRT32Var52),
    Var53(FPRT32Var53),
    Var54(FPRT32Var54),
    Var55(FPRT32Var55),
    Var56(FPRT32Var56),
    Var57(FPRT32Var57),
    Var58(FPRT32Var58),
    Var59(FPRT32Var59),
    Var60(FPRT32Var60),
    Var61(FPRT32Var61),
    Var62(FPRT32Var62),
    Var63(FPRT32Var63),
}
impl TableFPRT32 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var18(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var19(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var20(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var21(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var22(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var23(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var24(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var25(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var26(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var27(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var28(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var29(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var30(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var31(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var32(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var33(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var34(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var35(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var36(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var37(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var38(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var39(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var40(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var41(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var42(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var43(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var44(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var45(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var46(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var47(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var48(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var49(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var50(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var51(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var52(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var53(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var54(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var55(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var56(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var57(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var58(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var59(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var60(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var61(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var62(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var63(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            FPRT32Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var12::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var13::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var14::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var15::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var16::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var17::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var18::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var18(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var19::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var19(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var20::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var20(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var21::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var21(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var22::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var22(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var23::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var23(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var24::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var24(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var25::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var25(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var26::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var26(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var27::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var27(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var28::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var28(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var29::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var29(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var30::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var30(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var31::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var31(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var32::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var32(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var33::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var33(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var34::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var34(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var35::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var35(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var36::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var36(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var37::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var37(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var38::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var38(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var39::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var39(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var40::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var40(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var41::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var41(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var42::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var42(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var43::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var43(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var44::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var44(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var45::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var45(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var46::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var46(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var47::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var47(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var48::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var48(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var49::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var49(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var50::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var50(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var51::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var51(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var52::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var52(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var53::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var53(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var54::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var54(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var55::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var55(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var56::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var56(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var57::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var57(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var58::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var58(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var59::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var59(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var60::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var60(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var61::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var61(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var62::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var62(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var63::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var63(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1177:1, end:1177:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar0 {}
impl fpcmpVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",FALSE?")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1178:1, end:1178:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar1 {}
impl fpcmpVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",false")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1179:1, end:1179:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar2 {}
impl fpcmpVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",?")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1180:1, end:1180:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar3 {}
impl fpcmpVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!<=>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 3i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1181:1, end:1181:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar4 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 4i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1182:1, end:1182:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar5 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",=T")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 5i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1183:1, end:1183:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar6 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",?=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 6i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1184:1, end:1184:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar7 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!<>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 7i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1185:1, end:1185:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar8 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!?>=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 8i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1186:1, end:1186:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar9 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",<")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 9i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1187:1, end:1187:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar10 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",?<")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 10i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1188:1, end:1188:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar11 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!>=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 11i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1189:1, end:1189:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar12 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!?>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 12i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1190:1, end:1190:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar13 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",<=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 13i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1191:1, end:1191:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar14 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",?<=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 14i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1192:1, end:1192:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar15 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",!>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 15i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1193:1, end:1193:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar16 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!?<=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 16i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1194:1, end:1194:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar17 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 17i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1195:1, end:1195:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar18 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",?>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 18i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1196:1, end:1196:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar19 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!<=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 19i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1197:1, end:1197:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar20 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!?<")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 20i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1198:1, end:1198:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar21 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",>=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 21i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1199:1, end:1199:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar22 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",?>=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 22i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1200:1, end:1200:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar23 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!<;")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 23i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1201:1, end:1201:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar24 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!?=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 24i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1202:1, end:1202:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar25 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",<>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 25i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1203:1, end:1203:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar26 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",!=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 26i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1204:1, end:1204:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar27 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!=T")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 27i128 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1205:1, end:1205:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar28 {}
impl fpcmpVar28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",!?")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 28i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1206:1, end:1206:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar29 {}
impl fpcmpVar29 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",<=>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 29i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1207:1, end:1207:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar30 {}
impl fpcmpVar30 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",TRUE?")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 30i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1208:1, end:1208:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar31 {}
impl fpcmpVar31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",TRUE")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 31i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablefpcmp {
    Var0(fpcmpVar0),
    Var1(fpcmpVar1),
    Var2(fpcmpVar2),
    Var3(fpcmpVar3),
    Var4(fpcmpVar4),
    Var5(fpcmpVar5),
    Var6(fpcmpVar6),
    Var7(fpcmpVar7),
    Var8(fpcmpVar8),
    Var9(fpcmpVar9),
    Var10(fpcmpVar10),
    Var11(fpcmpVar11),
    Var12(fpcmpVar12),
    Var13(fpcmpVar13),
    Var14(fpcmpVar14),
    Var15(fpcmpVar15),
    Var16(fpcmpVar16),
    Var17(fpcmpVar17),
    Var18(fpcmpVar18),
    Var19(fpcmpVar19),
    Var20(fpcmpVar20),
    Var21(fpcmpVar21),
    Var22(fpcmpVar22),
    Var23(fpcmpVar23),
    Var24(fpcmpVar24),
    Var25(fpcmpVar25),
    Var26(fpcmpVar26),
    Var27(fpcmpVar27),
    Var28(fpcmpVar28),
    Var29(fpcmpVar29),
    Var30(fpcmpVar30),
    Var31(fpcmpVar31),
}
impl Tablefpcmp {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var18(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var19(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var20(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var21(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var22(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var23(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var24(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var25(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var26(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var27(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var28(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var29(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var30(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var31(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            fpcmpVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar12::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar13::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar14::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar15::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar16::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar17::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar18::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var18(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar19::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var19(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar20::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var20(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar21::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var21(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar22::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var22(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar23::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var23(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar24::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var24(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar25::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var25(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar26::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var26(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar27::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var27(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar28::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var28(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar29::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var29(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar30::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var30(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar31::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var31(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1210:1, end:1210:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var0 {}
impl fpcmp64Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",FALSE?")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1211:1, end:1211:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var1 {}
impl fpcmp64Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",false")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1212:1, end:1212:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var2 {}
impl fpcmp64Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",?")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1213:1, end:1213:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var3 {}
impl fpcmp64Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!<=>;")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 3i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1214:1, end:1214:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var4 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 4i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1215:1, end:1215:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var5 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",=T")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 5i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1216:1, end:1216:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var6 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",?=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 6i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1217:1, end:1217:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var7 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!<>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 7i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1218:1, end:1218:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var8 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!?>=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 8i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1219:1, end:1219:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var9 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",<")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 9i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1220:1, end:1220:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var10 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",?<")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 10i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1221:1, end:1221:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var11 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!>=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 11i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1222:1, end:1222:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var12 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!?>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 12i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1223:1, end:1223:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var13 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",<=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 13i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1224:1, end:1224:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var14 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",?<=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 14i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1225:1, end:1225:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var15 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",!>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 15i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1226:1, end:1226:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var16 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!?<=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 16i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1227:1, end:1227:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var17 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 17i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1228:1, end:1228:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var18 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",?>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 18i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1229:1, end:1229:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var19 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!<=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 19i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1230:1, end:1230:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var20 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!?<")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 20i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1231:1, end:1231:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var21 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",>=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 21i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1232:1, end:1232:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var22 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",?>=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 22i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1233:1, end:1233:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var23 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",!<")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 23i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1234:1, end:1234:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var24 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!?=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 24i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1235:1, end:1235:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var25 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",<>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 25i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1236:1, end:1236:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var26 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",!=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 26i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1237:1, end:1237:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var27 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!=T")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 27i128 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1238:1, end:1238:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var28 {}
impl fpcmp64Var28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",!?")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 28i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1239:1, end:1239:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var29 {}
impl fpcmp64Var29 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",<=>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 29i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1240:1, end:1240:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var30 {}
impl fpcmp64Var30 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",TRUE?")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 30i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1241:1, end:1241:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var31 {}
impl fpcmp64Var31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",TRUE")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 31i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablefpcmp64 {
    Var0(fpcmp64Var0),
    Var1(fpcmp64Var1),
    Var2(fpcmp64Var2),
    Var3(fpcmp64Var3),
    Var4(fpcmp64Var4),
    Var5(fpcmp64Var5),
    Var6(fpcmp64Var6),
    Var7(fpcmp64Var7),
    Var8(fpcmp64Var8),
    Var9(fpcmp64Var9),
    Var10(fpcmp64Var10),
    Var11(fpcmp64Var11),
    Var12(fpcmp64Var12),
    Var13(fpcmp64Var13),
    Var14(fpcmp64Var14),
    Var15(fpcmp64Var15),
    Var16(fpcmp64Var16),
    Var17(fpcmp64Var17),
    Var18(fpcmp64Var18),
    Var19(fpcmp64Var19),
    Var20(fpcmp64Var20),
    Var21(fpcmp64Var21),
    Var22(fpcmp64Var22),
    Var23(fpcmp64Var23),
    Var24(fpcmp64Var24),
    Var25(fpcmp64Var25),
    Var26(fpcmp64Var26),
    Var27(fpcmp64Var27),
    Var28(fpcmp64Var28),
    Var29(fpcmp64Var29),
    Var30(fpcmp64Var30),
    Var31(fpcmp64Var31),
}
impl Tablefpcmp64 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var18(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var19(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var20(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var21(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var22(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var23(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var24(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var25(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var26(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var27(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var28(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var29(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var30(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var31(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            fpcmp64Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var12::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var13::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var14::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var15::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var16::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var17::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var18::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var18(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var19::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var19(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var20::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var20(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var21::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var21(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var22::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var22(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var23::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var23(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var24::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var24(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var25::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var25(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var26::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var26(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var27::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var27(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var28::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var28(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var29::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var29(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var30::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var30(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var31::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var31(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1247:1, end:1247:3))"]
#[derive(Clone, Debug)]
struct SRVar0 {}
impl SRVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("srN")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFields().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1248:1, end:1248:3))"]
#[derive(Clone, Debug)]
struct SRVar1 {}
impl SRVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr1)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFields().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1249:1, end:1249:3))"]
#[derive(Clone, Debug)]
struct SRVar2 {}
impl SRVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr2)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFields().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1250:1, end:1250:3))"]
#[derive(Clone, Debug)]
struct SRVar3 {}
impl SRVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr3)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFields().disassembly() != 3i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSR {
    Var0(SRVar0),
    Var1(SRVar1),
    Var2(SRVar2),
    Var3(SRVar3),
}
impl TableSR {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            SRVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SRVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SRVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SRVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1252:1, end:1252:7))"]
#[derive(Clone, Debug)]
struct SR3bitVar0 {}
impl SR3bitVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr0)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsrbit2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsrbit1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsrbit0().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1253:1, end:1253:7))"]
#[derive(Clone, Debug)]
struct SR3bitVar1 {}
impl SR3bitVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr1)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsrbit2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsrbit1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsrbit0().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1254:1, end:1254:7))"]
#[derive(Clone, Debug)]
struct SR3bitVar2 {}
impl SR3bitVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr2)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsrbit2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsrbit1().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsrbit0().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1255:1, end:1255:7))"]
#[derive(Clone, Debug)]
struct SR3bitVar3 {}
impl SR3bitVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr3)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsrbit2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsrbit1().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsrbit0().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1256:1, end:1256:7))"]
#[derive(Clone, Debug)]
struct SR3bitVar4 {}
impl SR3bitVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr4)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsrbit2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsrbit1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsrbit0().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1257:1, end:1257:7))"]
#[derive(Clone, Debug)]
struct SR3bitVar5 {}
impl SR3bitVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr5)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsrbit2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsrbit1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsrbit0().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1258:1, end:1258:7))"]
#[derive(Clone, Debug)]
struct SR3bitVar6 {}
impl SR3bitVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr6)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsrbit2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsrbit1().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsrbit0().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1259:1, end:1259:7))"]
#[derive(Clone, Debug)]
struct SR3bitVar7 {}
impl SR3bitVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr7)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsrbit2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsrbit1().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsrbit0().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSR3bit {
    Var0(SR3bitVar0),
    Var1(SR3bitVar1),
    Var2(SR3bitVar2),
    Var3(SR3bitVar3),
    Var4(SR3bitVar4),
    Var5(SR3bitVar5),
    Var6(SR3bitVar6),
    Var7(SR3bitVar7),
}
impl TableSR3bit {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            SR3bitVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SR3bitVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SR3bitVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SR3bitVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SR3bitVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SR3bitVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SR3bitVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SR3bitVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1264:1, end:1264:5))"]
#[derive(Clone, Debug)]
struct SRRBVar0 {
    RB: TableRB,
}
impl SRRBVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFields().disassembly() != 0i128 {
            return None;
        }
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1266:1, end:1266:5))"]
#[derive(Clone, Debug)]
struct SRRBVar1 {
    SR: TableSR,
    RB: TableRB,
}
impl SRRBVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.SR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let SR = if let Some((len, table)) =
            TableSR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SR, RB }))
    }
}
#[derive(Clone, Debug)]
enum TableSRRB {
    Var0(SRRBVar0),
    Var1(SRRBVar1),
}
impl TableSRRB {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            SRRBVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SRRBVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1269:1, end:1269:9))"]
#[derive(Clone, Debug)]
struct SRRB3bitVar0 {
    SR3bit: TableSR3bit,
    RB: TableRB,
}
impl SRRB3bitVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.SR3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SR3bit, RB }))
    }
}
#[derive(Clone, Debug)]
enum TableSRRB3bit {
    Var0(SRRB3bitVar0),
}
impl TableSRRB3bit {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            SRRB3bitVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1274:1, end:1274:6))"]
#[derive(Clone, Debug)]
struct SRVALVar0 {
    SR: TableSR,
    RB: TableRB,
}
impl SRVALVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.SR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFields().disassembly() != 0i128 {
            return None;
        }
        let SR = if let Some((len, table)) =
            TableSR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SR, RB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1281:1, end:1281:6))"]
#[derive(Clone, Debug)]
struct SRVALVar1 {}
impl SRVALVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr1)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFields().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1282:1, end:1282:6))"]
#[derive(Clone, Debug)]
struct SRVALVar2 {}
impl SRVALVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr2)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFields().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1283:1, end:1283:6))"]
#[derive(Clone, Debug)]
struct SRVALVar3 {}
impl SRVALVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr3)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFields().disassembly() != 3i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSRVAL {
    Var0(SRVALVar0),
    Var1(SRVALVar1),
    Var2(SRVALVar2),
    Var3(SRVALVar3),
}
impl TableSRVAL {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            SRVALVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SRVALVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SRVALVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SRVALVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1286:1, end:1286:8))"]
#[derive(Clone, Debug)]
struct SPCBASEVar0 {
    SRVAL: TableSRVAL,
    RB: TableRB,
}
impl SPCBASEVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let SRVAL = if let Some((len, table)) =
            TableSRVAL::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SRVAL, RB }))
    }
}
#[derive(Clone, Debug)]
enum TableSPCBASE {
    Var0(SPCBASEVar0),
}
impl TableSPCBASE {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            SPCBASEVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1298:1, end:1298:15))"]
#[derive(Clone, Debug)]
struct displacement2WVar0 {
    w: TokenField_w,
    w2: TokenField_w2,
}
impl displacement2WVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_target: i128 = 0;
        calc_target = 1i128
            .wrapping_sub(self.w.disassembly().wrapping_mul(2i128))
            .wrapping_mul(
                (u32::try_from(10i128)
                    .ok()
                    .map(|shl| (self.w2.disassembly() & 1i128).checked_shl(shl))
                    .flatten()
                    .unwrap_or(0)
                    | (u32::try_from(1i128)
                        .ok()
                        .map(|shr| self.w2.disassembly().checked_shr(shr))
                        .flatten()
                        .unwrap_or(0)
                        & 1023i128)),
            );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_target)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_target: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_target = 1i128
            .wrapping_sub(
                token_parser.TokenFieldw().disassembly().wrapping_mul(2i128),
            )
            .wrapping_mul(
                (u32::try_from(10i128)
                    .ok()
                    .map(|shl| {
                        (token_parser.TokenFieldw2().disassembly() & 1i128)
                            .checked_shl(shl)
                    })
                    .flatten()
                    .unwrap_or(0)
                    | (u32::try_from(1i128)
                        .ok()
                        .map(|shr| {
                            token_parser
                                .TokenFieldw2()
                                .disassembly()
                                .checked_shr(shr)
                        })
                        .flatten()
                        .unwrap_or(0)
                        & 1023i128)),
            );
        let w = token_parser.TokenFieldw();
        let w2 = token_parser.TokenFieldw2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { w, w2 }))
    }
}
#[derive(Clone, Debug)]
enum Tabledisplacement2W {
    Var0(displacement2WVar0),
}
impl Tabledisplacement2W {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = displacement2WVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1304:1, end:1304:15))"]
#[derive(Clone, Debug)]
struct branchTarget2WVar0 {
    w: TokenField_w,
    w2_2: TokenField_w2_2,
    w2less2: TokenField_w2less2,
}
impl branchTarget2WVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_target: i128 = 0;
        calc_target = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                4i128.wrapping_mul(
                    ((u32::try_from(11i128)
                        .ok()
                        .map(|shl| {
                            (-1i128)
                                .wrapping_mul(self.w.disassembly())
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0)
                        | u32::try_from(10i128)
                            .ok()
                            .map(|shl| self.w2_2.disassembly().checked_shl(shl))
                            .flatten()
                            .unwrap_or(0))
                        | self.w2less2.disassembly()),
                ),
            );
        global_set.set_branchImmDest(
            Some(inst_next),
            context.register().read_branchImmDest_disassembly().unwrap(),
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_target)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_target: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_target = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                4i128.wrapping_mul(
                    ((u32::try_from(11i128)
                        .ok()
                        .map(|shl| {
                            (-1i128)
                                .wrapping_mul(
                                    token_parser.TokenFieldw().disassembly(),
                                )
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0)
                        | u32::try_from(10i128)
                            .ok()
                            .map(|shl| {
                                token_parser
                                    .TokenFieldw2_2()
                                    .disassembly()
                                    .checked_shl(shl)
                            })
                            .flatten()
                            .unwrap_or(0))
                        | token_parser.TokenFieldw2less2().disassembly()),
                ),
            );
        let tmp = context_instance
            .register()
            .read_branchImmDest_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_temp32_disassembly(tmp)
            .unwrap();
        let tmp = calc_target;
        context_instance
            .register_mut()
            .write_branchImmDest_disassembly(tmp)
            .unwrap();
        let w = token_parser.TokenFieldw();
        let w2less2 = token_parser.TokenFieldw2less2();
        let w2_2 = token_parser.TokenFieldw2_2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { w, w2less2, w2_2 }))
    }
}
#[derive(Clone, Debug)]
enum TablebranchTarget2W {
    Var0(branchTarget2WVar0),
}
impl TablebranchTarget2W {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = branchTarget2WVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1322:1, end:1322:15))"]
#[derive(Clone, Debug)]
struct displacement3WVar0 {
    w: TokenField_w,
    w1: TokenField_w1,
    w2_2: TokenField_w2_2,
    w2less2: TokenField_w2less2,
}
impl displacement3WVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_target: i128 = 0;
        calc_target = 4i128.wrapping_mul(
            (((u32::try_from(16i128)
                .ok()
                .map(|shl| {
                    (-1i128).wrapping_mul(self.w.disassembly()).checked_shl(shl)
                })
                .flatten()
                .unwrap_or(0)
                | u32::try_from(11i128)
                    .ok()
                    .map(|shl| self.w1.disassembly().checked_shl(shl))
                    .flatten()
                    .unwrap_or(0))
                | u32::try_from(10i128)
                    .ok()
                    .map(|shl| self.w2_2.disassembly().checked_shl(shl))
                    .flatten()
                    .unwrap_or(0))
                | self.w2less2.disassembly()),
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_target)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_target: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_target = 4i128.wrapping_mul(
            (((u32::try_from(16i128)
                .ok()
                .map(|shl| {
                    (-1i128)
                        .wrapping_mul(token_parser.TokenFieldw().disassembly())
                        .checked_shl(shl)
                })
                .flatten()
                .unwrap_or(0)
                | u32::try_from(11i128)
                    .ok()
                    .map(|shl| {
                        token_parser
                            .TokenFieldw1()
                            .disassembly()
                            .checked_shl(shl)
                    })
                    .flatten()
                    .unwrap_or(0))
                | u32::try_from(10i128)
                    .ok()
                    .map(|shl| {
                        token_parser
                            .TokenFieldw2_2()
                            .disassembly()
                            .checked_shl(shl)
                    })
                    .flatten()
                    .unwrap_or(0))
                | token_parser.TokenFieldw2less2().disassembly()),
        );
        let w = token_parser.TokenFieldw();
        let w1 = token_parser.TokenFieldw1();
        let w2less2 = token_parser.TokenFieldw2less2();
        let w2_2 = token_parser.TokenFieldw2_2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                w,
                w1,
                w2less2,
                w2_2,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum Tabledisplacement3W {
    Var0(displacement3WVar0),
}
impl Tabledisplacement3W {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = displacement3WVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1332:1, end:1332:15))"]
#[derive(Clone, Debug)]
struct branchTarget3WVar0 {
    w: TokenField_w,
    w1: TokenField_w1,
    w2_2: TokenField_w2_2,
    w2less2: TokenField_w2less2,
}
impl branchTarget3WVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_target: i128 = 0;
        calc_target = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                4i128.wrapping_mul(
                    (((u32::try_from(16i128)
                        .ok()
                        .map(|shl| {
                            (-1i128)
                                .wrapping_mul(self.w.disassembly())
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0)
                        | u32::try_from(11i128)
                            .ok()
                            .map(|shl| self.w1.disassembly().checked_shl(shl))
                            .flatten()
                            .unwrap_or(0))
                        | u32::try_from(10i128)
                            .ok()
                            .map(|shl| self.w2_2.disassembly().checked_shl(shl))
                            .flatten()
                            .unwrap_or(0))
                        | self.w2less2.disassembly()),
                ),
            );
        global_set.set_branchImmDest(
            Some(inst_next),
            context.register().read_branchImmDest_disassembly().unwrap(),
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_target)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_target: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_target = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                4i128.wrapping_mul(
                    (((u32::try_from(16i128)
                        .ok()
                        .map(|shl| {
                            (-1i128)
                                .wrapping_mul(
                                    token_parser.TokenFieldw().disassembly(),
                                )
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0)
                        | u32::try_from(11i128)
                            .ok()
                            .map(|shl| {
                                token_parser
                                    .TokenFieldw1()
                                    .disassembly()
                                    .checked_shl(shl)
                            })
                            .flatten()
                            .unwrap_or(0))
                        | u32::try_from(10i128)
                            .ok()
                            .map(|shl| {
                                token_parser
                                    .TokenFieldw2_2()
                                    .disassembly()
                                    .checked_shl(shl)
                            })
                            .flatten()
                            .unwrap_or(0))
                        | token_parser.TokenFieldw2less2().disassembly()),
                ),
            );
        let tmp = context_instance
            .register()
            .read_branchImmDest_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_temp32_disassembly(tmp)
            .unwrap();
        let tmp = calc_target;
        context_instance
            .register_mut()
            .write_branchImmDest_disassembly(tmp)
            .unwrap();
        let w = token_parser.TokenFieldw();
        let w1 = token_parser.TokenFieldw1();
        let w2less2 = token_parser.TokenFieldw2less2();
        let w2_2 = token_parser.TokenFieldw2_2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                w,
                w1,
                w2less2,
                w2_2,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TablebranchTarget3W {
    Var0(branchTarget3WVar0),
}
impl TablebranchTarget3W {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = branchTarget3WVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1349:1, end:1349:24))"]
#[derive(Clone, Debug)]
struct IPRelativeIndexedTargetVar0 {
    RX: TableRX,
}
impl IPRelativeIndexedTargetVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX }))
    }
}
#[derive(Clone, Debug)]
enum TableIPRelativeIndexedTarget {
    Var0(IPRelativeIndexedTargetVar0),
}
impl TableIPRelativeIndexedTarget {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = IPRelativeIndexedTargetVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1357:1, end:1357:14))"]
#[derive(Clone, Debug)]
struct IndexedTargetVar0 {
    RX: TableRX,
    RB: TableRB,
}
impl IndexedTargetVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, RB }))
    }
}
#[derive(Clone, Debug)]
enum TableIndexedTarget {
    Var0(IndexedTargetVar0),
}
impl TableIndexedTarget {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = IndexedTargetVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1365:1, end:1365:13))"]
#[derive(Clone, Debug)]
struct ReturnTargetVar0 {
    RB: TableRB,
}
impl ReturnTargetVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RB }))
    }
}
#[derive(Clone, Debug)]
enum TableReturnTarget {
    Var0(ReturnTargetVar0),
}
impl TableReturnTarget {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = ReturnTargetVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1372:1, end:1372:15))"]
#[derive(Clone, Debug)]
struct externalTargetVar0 {
    RB: TableRB,
    displacement3W: Tabledisplacement3W,
    SRRB3bit: TableSRRB3bit,
}
impl externalTargetVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.displacement3W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement3W = if let Some((len, table)) =
            Tabledisplacement3W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) = TableSRRB3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                displacement3W,
                SRRB3bit,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TableexternalTarget {
    Var0(externalTargetVar0),
}
impl TableexternalTarget {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = externalTargetVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1383:1, end:1383:7))"]
#[derive(Clone, Debug)]
struct shiftCVar0 {
    cp: TokenField_cp,
}
impl shiftCVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_shift: i128 = 0;
        calc_shift = 31i128.wrapping_sub(self.cp.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_shift)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_shift: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_shift =
            31i128.wrapping_sub(token_parser.TokenFieldcp().disassembly());
        let cp = token_parser.TokenFieldcp();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cp }))
    }
}
#[derive(Clone, Debug)]
enum TableshiftC {
    Var0(shiftCVar0),
}
impl TableshiftC {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            shiftCVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1384:1, end:1384:10))"]
#[derive(Clone, Debug)]
struct shiftCLenVar0 {
    im5: TokenField_im5,
}
impl shiftCLenVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_shift: i128 = 0;
        calc_shift = 32i128.wrapping_sub(self.im5.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_shift)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_shift: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_shift =
            32i128.wrapping_sub(token_parser.TokenFieldim5().disassembly());
        let im5 = token_parser.TokenFieldim5();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { im5 }))
    }
}
#[derive(Clone, Debug)]
enum TableshiftCLen {
    Var0(shiftCLenVar0),
}
impl TableshiftCLen {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            shiftCLenVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1388:1, end:1388:6))"]
#[derive(Clone, Debug)]
struct lse14Var0 {
    bit0: TokenField_bit0,
    im14less0: TokenField_im14less0,
}
impl lse14Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_off: i128 = 0;
        calc_off = (u32::try_from(13i128)
            .ok()
            .map(|shl| {
                (-1i128)
                    .wrapping_mul(self.bit0.disassembly())
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | self.im14less0.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_off)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_off: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_off = (u32::try_from(13i128)
            .ok()
            .map(|shl| {
                (-1i128)
                    .wrapping_mul(token_parser.TokenFieldbit0().disassembly())
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldim14less0().disassembly());
        let im14less0 = token_parser.TokenFieldim14less0();
        let bit0 = token_parser.TokenFieldbit0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { im14less0, bit0 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelse14 {
    Var0(lse14Var0),
}
impl Tablelse14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            lse14Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1392:1, end:1392:5))"]
#[derive(Clone, Debug)]
struct lse5Var0 {
    bit0: TokenField_bit0,
    im5less0: TokenField_im5less0,
}
impl lse5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_off: i128 = 0;
        calc_off = (u32::try_from(4i128)
            .ok()
            .map(|shl| {
                (-1i128)
                    .wrapping_mul(self.bit0.disassembly())
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | self.im5less0.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_off)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_off: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_off = (u32::try_from(4i128)
            .ok()
            .map(|shl| {
                (-1i128)
                    .wrapping_mul(token_parser.TokenFieldbit0().disassembly())
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldim5less0().disassembly());
        let im5less0 = token_parser.TokenFieldim5less0();
        let bit0 = token_parser.TokenFieldbit0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { im5less0, bit0 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelse5 {
    Var0(lse5Var0),
}
impl Tablelse5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            lse5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1395:1, end:1395:9))"]
#[derive(Clone, Debug)]
struct highlse5Var0 {
    bit16: TokenField_bit16,
    highIm5less16: TokenField_highIm5less16,
}
impl highlse5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_off: i128 = 0;
        calc_off = (u32::try_from(4i128)
            .ok()
            .map(|shl| {
                (-1i128)
                    .wrapping_mul(self.bit16.disassembly())
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | self.highIm5less16.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_off)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_off: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_off = (u32::try_from(4i128)
            .ok()
            .map(|shl| {
                (-1i128)
                    .wrapping_mul(token_parser.TokenFieldbit16().disassembly())
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldhighIm5less16().disassembly());
        let highIm5less16 = token_parser.TokenFieldhighIm5less16();
        let bit16 = token_parser.TokenFieldbit16();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                highIm5less16,
                bit16,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum Tablehighlse5 {
    Var0(highlse5Var0),
}
impl Tablehighlse5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            highlse5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1398:1, end:1398:6))"]
#[derive(Clone, Debug)]
struct lse21Var0 {
    bit0: TokenField_bit0,
    im21_1_12: TokenField_im21_1_12,
    im21_14_16: TokenField_im21_14_16,
    im21_16_21: TokenField_im21_16_21,
    im21_12_14: TokenField_im21_12_14,
}
impl lse21Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_off: i128 = 0;
        calc_off = u32::try_from(11i128)
            .ok()
            .map(|shl| {
                ((((u32::try_from(20i128)
                    .ok()
                    .map(|shl| {
                        (-1i128)
                            .wrapping_mul(self.bit0.disassembly())
                            .checked_shl(shl)
                    })
                    .flatten()
                    .unwrap_or(0)
                    | u32::try_from(9i128)
                        .ok()
                        .map(|shl| {
                            self.im21_1_12.disassembly().checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(7i128)
                        .ok()
                        .map(|shl| {
                            self.im21_14_16.disassembly().checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(2i128)
                        .ok()
                        .map(|shl| {
                            self.im21_16_21.disassembly().checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0))
                    | self.im21_12_14.disassembly())
                .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_off)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_off: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_off = u32::try_from(11i128)
            .ok()
            .map(|shl| {
                ((((u32::try_from(20i128)
                    .ok()
                    .map(|shl| {
                        (-1i128)
                            .wrapping_mul(
                                token_parser.TokenFieldbit0().disassembly(),
                            )
                            .checked_shl(shl)
                    })
                    .flatten()
                    .unwrap_or(0)
                    | u32::try_from(9i128)
                        .ok()
                        .map(|shl| {
                            token_parser
                                .TokenFieldim21_1_12()
                                .disassembly()
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(7i128)
                        .ok()
                        .map(|shl| {
                            token_parser
                                .TokenFieldim21_14_16()
                                .disassembly()
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(2i128)
                        .ok()
                        .map(|shl| {
                            token_parser
                                .TokenFieldim21_16_21()
                                .disassembly()
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0))
                    | token_parser.TokenFieldim21_12_14().disassembly())
                .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0);
        let im21less0 = token_parser.TokenFieldim21less0();
        let bit0 = token_parser.TokenFieldbit0();
        let im21_1_12 = token_parser.TokenFieldim21_1_12();
        let im21_12_14 = token_parser.TokenFieldim21_12_14();
        let im21_14_16 = token_parser.TokenFieldim21_14_16();
        let im21_16_21 = token_parser.TokenFieldim21_16_21();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bit0,
                im21_1_12,
                im21_12_14,
                im21_14_16,
                im21_16_21,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum Tablelse21 {
    Var0(lse21Var0),
}
impl Tablelse21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            lse21Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1414:1, end:1414:6))"]
#[derive(Clone, Debug)]
struct lse11Var0 {
    bit0: TokenField_bit0,
    im11less0: TokenField_im11less0,
}
impl lse11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_immed: i128 = 0;
        calc_immed = (u32::try_from(10i128)
            .ok()
            .map(|shl| {
                (-1i128)
                    .wrapping_mul(self.bit0.disassembly())
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | self.im11less0.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_immed)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_immed: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_immed = (u32::try_from(10i128)
            .ok()
            .map(|shl| {
                (-1i128)
                    .wrapping_mul(token_parser.TokenFieldbit0().disassembly())
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldim11less0().disassembly());
        let tmp = calc_immed;
        context_instance
            .register_mut()
            .write_temp32_disassembly(tmp)
            .unwrap();
        let im11less0 = token_parser.TokenFieldim11less0();
        let bit0 = token_parser.TokenFieldbit0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { im11less0, bit0 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelse11 {
    Var0(lse11Var0),
}
impl Tablelse11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            lse11Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1419:1, end:1419:12))"]
#[derive(Clone, Debug)]
struct OFF_BASE_14Var0 {
    lse14: Tablelse14,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
}
impl OFF_BASE_14Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.lse14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let lse14 = if let Some((len, table)) =
            Tablelse14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                lse14,
                SRRB,
                SPCBASE,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TableOFF_BASE_14 {
    Var0(OFF_BASE_14Var0),
}
impl TableOFF_BASE_14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = OFF_BASE_14Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1426:1, end:1426:10))"]
#[derive(Clone, Debug)]
struct ShiftCondVar0 {}
impl ShiftCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1427:1, end:1427:10))"]
#[derive(Clone, Debug)]
struct ShiftCondVar1 {
    RT: TableRT,
}
impl ShiftCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 1i128 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1428:1, end:1428:10))"]
#[derive(Clone, Debug)]
struct ShiftCondVar2 {
    RT: TableRT,
}
impl ShiftCondVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i128 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1429:1, end:1429:10))"]
#[derive(Clone, Debug)]
struct ShiftCondVar3 {
    RT: TableRT,
}
impl ShiftCondVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 3i128 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1430:1, end:1430:10))"]
#[derive(Clone, Debug)]
struct ShiftCondVar4 {}
impl ShiftCondVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1431:1, end:1431:10))"]
#[derive(Clone, Debug)]
struct ShiftCondVar5 {
    RT: TableRT,
}
impl ShiftCondVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 5i128 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1432:1, end:1432:10))"]
#[derive(Clone, Debug)]
struct ShiftCondVar6 {
    RT: TableRT,
}
impl ShiftCondVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i128 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1433:1, end:1433:10))"]
#[derive(Clone, Debug)]
struct ShiftCondVar7 {
    RT: TableRT,
}
impl ShiftCondVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 7i128 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[derive(Clone, Debug)]
enum TableShiftCond {
    Var0(ShiftCondVar0),
    Var1(ShiftCondVar1),
    Var2(ShiftCondVar2),
    Var3(ShiftCondVar3),
    Var4(ShiftCondVar4),
    Var5(ShiftCondVar5),
    Var6(ShiftCondVar6),
    Var7(ShiftCondVar7),
}
impl TableShiftCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ShiftCondVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ShiftCondVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ShiftCondVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ShiftCondVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ShiftCondVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ShiftCondVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ShiftCondVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ShiftCondVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1435:1, end:1435:17))"]
#[derive(Clone, Debug)]
struct ShiftCondNullifyVar0 {}
impl ShiftCondNullifyVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1436:1, end:1436:17))"]
#[derive(Clone, Debug)]
struct ShiftCondNullifyVar1 {
    ShiftCond: TableShiftCond,
}
impl ShiftCondNullifyVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_nullifyEnable(
            Some(inst_next),
            context.register().read_nullifyEnable_disassembly().unwrap(),
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_nullifyEnable_disassembly(tmp)
            .unwrap();
        let ShiftCond = if let Some((len, table)) = TableShiftCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ShiftCond }))
    }
}
#[derive(Clone, Debug)]
enum TableShiftCondNullify {
    Var0(ShiftCondNullifyVar0),
    Var1(ShiftCondNullifyVar1),
}
impl TableShiftCondNullify {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = ShiftCondNullifyVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = ShiftCondNullifyVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1442:1, end:1442:8))"]
#[derive(Clone, Debug)]
struct DepCondVar0 {}
impl DepCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1443:1, end:1443:8))"]
#[derive(Clone, Debug)]
struct DepCondVar1 {}
impl DepCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1444:1, end:1444:8))"]
#[derive(Clone, Debug)]
struct DepCondVar2 {}
impl DepCondVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1445:1, end:1445:8))"]
#[derive(Clone, Debug)]
struct DepCondVar3 {}
impl DepCondVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 3i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1446:1, end:1446:8))"]
#[derive(Clone, Debug)]
struct DepCondVar4 {}
impl DepCondVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1447:1, end:1447:8))"]
#[derive(Clone, Debug)]
struct DepCondVar5 {}
impl DepCondVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 5i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1448:1, end:1448:8))"]
#[derive(Clone, Debug)]
struct DepCondVar6 {}
impl DepCondVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1449:1, end:1449:8))"]
#[derive(Clone, Debug)]
struct DepCondVar7 {}
impl DepCondVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 7i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableDepCond {
    Var0(DepCondVar0),
    Var1(DepCondVar1),
    Var2(DepCondVar2),
    Var3(DepCondVar3),
    Var4(DepCondVar4),
    Var5(DepCondVar5),
    Var6(DepCondVar6),
    Var7(DepCondVar7),
}
impl TableDepCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            DepCondVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            DepCondVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            DepCondVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            DepCondVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            DepCondVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            DepCondVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            DepCondVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            DepCondVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1451:1, end:1451:15))"]
#[derive(Clone, Debug)]
struct DepCondNullifyVar0 {}
impl DepCondNullifyVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1452:1, end:1452:15))"]
#[derive(Clone, Debug)]
struct DepCondNullifyVar1 {
    DepCond: TableDepCond,
}
impl DepCondNullifyVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_nullifyEnable(
            Some(inst_next),
            context.register().read_nullifyEnable_disassembly().unwrap(),
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_nullifyEnable_disassembly(tmp)
            .unwrap();
        let DepCond = if let Some((len, table)) = TableDepCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { DepCond }))
    }
}
#[derive(Clone, Debug)]
enum TableDepCondNullify {
    Var0(DepCondNullifyVar0),
    Var1(DepCondNullifyVar1),
}
impl TableDepCondNullify {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = DepCondNullifyVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = DepCondNullifyVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1458:1, end:1458:9))"]
#[derive(Clone, Debug)]
struct ExtrCondVar0 {}
impl ExtrCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1459:1, end:1459:9))"]
#[derive(Clone, Debug)]
struct ExtrCondVar1 {}
impl ExtrCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1460:1, end:1460:9))"]
#[derive(Clone, Debug)]
struct ExtrCondVar2 {}
impl ExtrCondVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1461:1, end:1461:9))"]
#[derive(Clone, Debug)]
struct ExtrCondVar3 {}
impl ExtrCondVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 3i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1462:1, end:1462:9))"]
#[derive(Clone, Debug)]
struct ExtrCondVar4 {}
impl ExtrCondVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1463:1, end:1463:9))"]
#[derive(Clone, Debug)]
struct ExtrCondVar5 {}
impl ExtrCondVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 5i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1464:1, end:1464:9))"]
#[derive(Clone, Debug)]
struct ExtrCondVar6 {}
impl ExtrCondVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1465:1, end:1465:9))"]
#[derive(Clone, Debug)]
struct ExtrCondVar7 {}
impl ExtrCondVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 7i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableExtrCond {
    Var0(ExtrCondVar0),
    Var1(ExtrCondVar1),
    Var2(ExtrCondVar2),
    Var3(ExtrCondVar3),
    Var4(ExtrCondVar4),
    Var5(ExtrCondVar5),
    Var6(ExtrCondVar6),
    Var7(ExtrCondVar7),
}
impl TableExtrCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ExtrCondVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ExtrCondVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ExtrCondVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ExtrCondVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ExtrCondVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ExtrCondVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ExtrCondVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ExtrCondVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1467:1, end:1467:16))"]
#[derive(Clone, Debug)]
struct ExtrCondNullifyVar0 {}
impl ExtrCondNullifyVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1468:1, end:1468:16))"]
#[derive(Clone, Debug)]
struct ExtrCondNullifyVar1 {
    ExtrCond: TableExtrCond,
}
impl ExtrCondNullifyVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_nullifyEnable(
            Some(inst_next),
            context.register().read_nullifyEnable_disassembly().unwrap(),
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_nullifyEnable_disassembly(tmp)
            .unwrap();
        let ExtrCond = if let Some((len, table)) = TableExtrCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ExtrCond }))
    }
}
#[derive(Clone, Debug)]
enum TableExtrCondNullify {
    Var0(ExtrCondNullifyVar0),
    Var1(ExtrCondNullifyVar1),
}
impl TableExtrCondNullify {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = ExtrCondNullifyVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = ExtrCondNullifyVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1475:1, end:1475:8))"]
#[derive(Clone, Debug)]
struct BVBCondVar0 {
    R1: TableR1,
}
impl BVBCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1476:1, end:1476:8))"]
#[derive(Clone, Debug)]
struct BVBCondVar1 {
    R1: TableR1,
}
impl BVBCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1 }))
    }
}
#[derive(Clone, Debug)]
enum TableBVBCond {
    Var0(BVBCondVar0),
    Var1(BVBCondVar1),
}
impl TableBVBCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            BVBCondVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            BVBCondVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1478:1, end:1478:7))"]
#[derive(Clone, Debug)]
struct BBCondVar0 {
    R1: TableR1,
}
impl BBCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let bboffset = token_parser.TokenFieldbboffset();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1479:1, end:1479:7))"]
#[derive(Clone, Debug)]
struct BBCondVar1 {
    R1: TableR1,
}
impl BBCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let bboffset = token_parser.TokenFieldbboffset();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1 }))
    }
}
#[derive(Clone, Debug)]
enum TableBBCond {
    Var0(BBCondVar0),
    Var1(BBCondVar1),
}
impl TableBBCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            BBCondVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            BBCondVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1484:1, end:1484:12))"]
#[derive(Clone, Debug)]
struct RegUnitCondVar0 {}
impl RegUnitCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1485:1, end:1485:12))"]
#[derive(Clone, Debug)]
struct RegUnitCondVar1 {
    RT: TableRT,
}
impl RegUnitCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i128 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1486:1, end:1486:12))"]
#[derive(Clone, Debug)]
struct RegUnitCondVar2 {
    RT: TableRT,
}
impl RegUnitCondVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 3i128 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1487:1, end:1487:12))"]
#[derive(Clone, Debug)]
struct RegUnitCondVar3 {}
impl RegUnitCondVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1488:1, end:1488:12))"]
#[derive(Clone, Debug)]
struct RegUnitCondVar4 {}
impl RegUnitCondVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1489:1, end:1489:12))"]
#[derive(Clone, Debug)]
struct RegUnitCondVar5 {}
impl RegUnitCondVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 7i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableRegUnitCond {
    Var0(RegUnitCondVar0),
    Var1(RegUnitCondVar1),
    Var2(RegUnitCondVar2),
    Var3(RegUnitCondVar3),
    Var4(RegUnitCondVar4),
    Var5(RegUnitCondVar5),
}
impl TableRegUnitCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = RegUnitCondVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = RegUnitCondVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = RegUnitCondVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = RegUnitCondVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = RegUnitCondVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = RegUnitCondVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1491:1, end:1491:9))"]
#[derive(Clone, Debug)]
struct UnitCondVar0 {
    RegUnitCond: TableRegUnitCond,
}
impl UnitCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 0i128 {
            return None;
        }
        let RegUnitCond = if let Some((len, table)) = TableRegUnitCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegUnitCond }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1492:1, end:1492:9))"]
#[derive(Clone, Debug)]
struct UnitCondVar1 {
    RegUnitCond: TableRegUnitCond,
}
impl UnitCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 1i128 {
            return None;
        }
        let RegUnitCond = if let Some((len, table)) = TableRegUnitCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegUnitCond }))
    }
}
#[derive(Clone, Debug)]
enum TableUnitCond {
    Var0(UnitCondVar0),
    Var1(UnitCondVar1),
}
impl TableUnitCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            UnitCondVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            UnitCondVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1494:1, end:1494:16))"]
#[derive(Clone, Debug)]
struct UnitCondNullifyVar0 {}
impl UnitCondNullifyVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfv().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1495:1, end:1495:16))"]
#[derive(Clone, Debug)]
struct UnitCondNullifyVar1 {
    UnitCond: TableUnitCond,
}
impl UnitCondNullifyVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_nullifyEnable(
            Some(inst_next),
            context.register().read_nullifyEnable_disassembly().unwrap(),
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_nullifyEnable_disassembly(tmp)
            .unwrap();
        let UnitCond = if let Some((len, table)) = TableUnitCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { UnitCond }))
    }
}
#[derive(Clone, Debug)]
enum TableUnitCondNullify {
    Var0(UnitCondNullifyVar0),
    Var1(UnitCondNullifyVar1),
}
impl TableUnitCondNullify {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = UnitCondNullifyVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = UnitCondNullifyVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1500:1, end:1500:12))"]
#[derive(Clone, Debug)]
struct UnitCondSymVar0 {
    RegUnitCondSym: TokenField_RegUnitCondSym,
}
impl UnitCondSymVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.RegUnitCondSym.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 0i128 {
            return None;
        }
        let RegUnitCondSym = token_parser.TokenFieldRegUnitCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegUnitCondSym }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1501:1, end:1501:12))"]
#[derive(Clone, Debug)]
struct UnitCondSymVar1 {
    InvUnitCondSym: TokenField_InvUnitCondSym,
}
impl UnitCondSymVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.InvUnitCondSym.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 1i128 {
            return None;
        }
        let InvUnitCondSym = token_parser.TokenFieldInvUnitCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { InvUnitCondSym }))
    }
}
#[derive(Clone, Debug)]
enum TableUnitCondSym {
    Var0(UnitCondSymVar0),
    Var1(UnitCondSymVar1),
}
impl TableUnitCondSym {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = UnitCondSymVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = UnitCondSymVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1506:1, end:1506:11))"]
#[derive(Clone, Debug)]
struct RegAddCondVar0 {}
impl RegAddCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1507:1, end:1507:11))"]
#[derive(Clone, Debug)]
struct RegAddCondVar1 {
    R1: TableR1,
    R2: TableR2,
}
impl RegAddCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 1i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1508:1, end:1508:11))"]
#[derive(Clone, Debug)]
struct RegAddCondVar2 {
    R1: TableR1,
    R2: TableR2,
}
impl RegAddCondVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1509:1, end:1509:11))"]
#[derive(Clone, Debug)]
struct RegAddCondVar3 {
    R1: TableR1,
    R2: TableR2,
}
impl RegAddCondVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 3i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1510:1, end:1510:11))"]
#[derive(Clone, Debug)]
struct RegAddCondVar4 {
    R1: TableR1,
    R2: TableR2,
}
impl RegAddCondVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 4i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1511:1, end:1511:11))"]
#[derive(Clone, Debug)]
struct RegAddCondVar5 {
    R1: TableR1,
    R2: TableR2,
}
impl RegAddCondVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 5i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1512:1, end:1512:11))"]
#[derive(Clone, Debug)]
struct RegAddCondVar6 {
    R1: TableR1,
    R2: TableR2,
}
impl RegAddCondVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1513:1, end:1513:11))"]
#[derive(Clone, Debug)]
struct RegAddCondVar7 {
    R1: TableR1,
    R2: TableR2,
}
impl RegAddCondVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 7i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[derive(Clone, Debug)]
enum TableRegAddCond {
    Var0(RegAddCondVar0),
    Var1(RegAddCondVar1),
    Var2(RegAddCondVar2),
    Var3(RegAddCondVar3),
    Var4(RegAddCondVar4),
    Var5(RegAddCondVar5),
    Var6(RegAddCondVar6),
    Var7(RegAddCondVar7),
}
impl TableRegAddCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = RegAddCondVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1515:1, end:1515:8))"]
#[derive(Clone, Debug)]
struct AddCondVar0 {
    RegAddCond: TableRegAddCond,
}
impl AddCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 0i128 {
            return None;
        }
        let RegAddCond = if let Some((len, table)) = TableRegAddCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegAddCond }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1516:1, end:1516:8))"]
#[derive(Clone, Debug)]
struct AddCondVar1 {
    RegAddCond: TableRegAddCond,
}
impl AddCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 1i128 {
            return None;
        }
        let RegAddCond = if let Some((len, table)) = TableRegAddCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegAddCond }))
    }
}
#[derive(Clone, Debug)]
enum TableAddCond {
    Var0(AddCondVar0),
    Var1(AddCondVar1),
}
impl TableAddCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            AddCondVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            AddCondVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1518:1, end:1518:15))"]
#[derive(Clone, Debug)]
struct AddCondNullifyVar0 {}
impl AddCondNullifyVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfv().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1519:1, end:1519:15))"]
#[derive(Clone, Debug)]
struct AddCondNullifyVar1 {
    AddCond: TableAddCond,
}
impl AddCondNullifyVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_nullifyEnable(
            Some(inst_next),
            context.register().read_nullifyEnable_disassembly().unwrap(),
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_nullifyEnable_disassembly(tmp)
            .unwrap();
        let AddCond = if let Some((len, table)) = TableAddCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AddCond }))
    }
}
#[derive(Clone, Debug)]
enum TableAddCondNullify {
    Var0(AddCondNullifyVar0),
    Var1(AddCondNullifyVar1),
}
impl TableAddCondNullify {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = AddCondNullifyVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = AddCondNullifyVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1524:1, end:1524:11))"]
#[derive(Clone, Debug)]
struct AddCondSymVar0 {
    RegAddCondSym: TokenField_RegAddCondSym,
}
impl AddCondSymVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.RegAddCondSym.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 0i128 {
            return None;
        }
        let RegAddCondSym = token_parser.TokenFieldRegAddCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegAddCondSym }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1525:1, end:1525:11))"]
#[derive(Clone, Debug)]
struct AddCondSymVar1 {
    InvAddCondSym: TokenField_InvAddCondSym,
}
impl AddCondSymVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.InvAddCondSym.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 1i128 {
            return None;
        }
        let InvAddCondSym = token_parser.TokenFieldInvAddCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { InvAddCondSym }))
    }
}
#[derive(Clone, Debug)]
enum TableAddCondSym {
    Var0(AddCondSymVar0),
    Var1(AddCondSymVar1),
}
impl TableAddCondSym {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = AddCondSymVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = AddCondSymVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1527:1, end:1527:12))"]
#[derive(Clone, Debug)]
struct RegAddCondIVar0 {}
impl RegAddCondIVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1528:1, end:1528:12))"]
#[derive(Clone, Debug)]
struct RegAddCondIVar1 {
    highlse5: Tablehighlse5,
    R2: TableR2,
}
impl RegAddCondIVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 1i128 {
            return None;
        }
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { highlse5, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1529:1, end:1529:12))"]
#[derive(Clone, Debug)]
struct RegAddCondIVar2 {
    highlse5: Tablehighlse5,
    R2: TableR2,
}
impl RegAddCondIVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i128 {
            return None;
        }
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { highlse5, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1530:1, end:1530:12))"]
#[derive(Clone, Debug)]
struct RegAddCondIVar3 {
    highlse5: Tablehighlse5,
    R2: TableR2,
}
impl RegAddCondIVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 3i128 {
            return None;
        }
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { highlse5, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1531:1, end:1531:12))"]
#[derive(Clone, Debug)]
struct RegAddCondIVar4 {
    highlse5: Tablehighlse5,
    R2: TableR2,
}
impl RegAddCondIVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 4i128 {
            return None;
        }
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { highlse5, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1532:1, end:1532:12))"]
#[derive(Clone, Debug)]
struct RegAddCondIVar5 {
    highlse5: Tablehighlse5,
    R2: TableR2,
}
impl RegAddCondIVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 5i128 {
            return None;
        }
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { highlse5, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1533:1, end:1533:12))"]
#[derive(Clone, Debug)]
struct RegAddCondIVar6 {
    highlse5: Tablehighlse5,
    R2: TableR2,
}
impl RegAddCondIVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i128 {
            return None;
        }
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { highlse5, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1534:1, end:1534:12))"]
#[derive(Clone, Debug)]
struct RegAddCondIVar7 {
    highlse5: Tablehighlse5,
    R2: TableR2,
}
impl RegAddCondIVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 7i128 {
            return None;
        }
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { highlse5, R2 }))
    }
}
#[derive(Clone, Debug)]
enum TableRegAddCondI {
    Var0(RegAddCondIVar0),
    Var1(RegAddCondIVar1),
    Var2(RegAddCondIVar2),
    Var3(RegAddCondIVar3),
    Var4(RegAddCondIVar4),
    Var5(RegAddCondIVar5),
    Var6(RegAddCondIVar6),
    Var7(RegAddCondIVar7),
}
impl TableRegAddCondI {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = RegAddCondIVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondIVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondIVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondIVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondIVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondIVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondIVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondIVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1544:1, end:1544:14))"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var0 {}
impl RegAddCondI11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1546:1, end:1546:14))"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var1 {
    lse11: Tablelse11,
    R2: TableR2,
}
impl RegAddCondI11Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 1i128 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse11, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1550:1, end:1550:14))"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var2 {
    lse11: Tablelse11,
    R2: TableR2,
}
impl RegAddCondI11Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i128 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse11, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1554:1, end:1554:14))"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var3 {
    lse11: Tablelse11,
    R2: TableR2,
}
impl RegAddCondI11Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 3i128 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse11, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1558:1, end:1558:14))"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var4 {
    lse11: Tablelse11,
    R2: TableR2,
}
impl RegAddCondI11Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 4i128 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse11, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1562:1, end:1562:14))"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var5 {
    lse11: Tablelse11,
    R2: TableR2,
}
impl RegAddCondI11Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 5i128 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse11, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1567:1, end:1567:14))"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var6 {
    lse11: Tablelse11,
    R2: TableR2,
}
impl RegAddCondI11Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i128 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse11, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1571:1, end:1571:14))"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var7 {
    lse11: Tablelse11,
    R2: TableR2,
}
impl RegAddCondI11Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 7i128 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse11, R2 }))
    }
}
#[derive(Clone, Debug)]
enum TableRegAddCondI11 {
    Var0(RegAddCondI11Var0),
    Var1(RegAddCondI11Var1),
    Var2(RegAddCondI11Var2),
    Var3(RegAddCondI11Var3),
    Var4(RegAddCondI11Var4),
    Var5(RegAddCondI11Var5),
    Var6(RegAddCondI11Var6),
    Var7(RegAddCondI11Var7),
}
impl TableRegAddCondI11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = RegAddCondI11Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondI11Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondI11Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondI11Var3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondI11Var4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondI11Var5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondI11Var6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondI11Var7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1575:1, end:1575:11))"]
#[derive(Clone, Debug)]
struct AddCondI11Var0 {
    RegAddCondI11: TableRegAddCondI11,
}
impl AddCondI11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 0i128 {
            return None;
        }
        let RegAddCondI11 = if let Some((len, table)) =
            TableRegAddCondI11::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegAddCondI11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1576:1, end:1576:11))"]
#[derive(Clone, Debug)]
struct AddCondI11Var1 {
    RegAddCondI11: TableRegAddCondI11,
}
impl AddCondI11Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 1i128 {
            return None;
        }
        let RegAddCondI11 = if let Some((len, table)) =
            TableRegAddCondI11::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegAddCondI11 }))
    }
}
#[derive(Clone, Debug)]
enum TableAddCondI11 {
    Var0(AddCondI11Var0),
    Var1(AddCondI11Var1),
}
impl TableAddCondI11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = AddCondI11Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = AddCondI11Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1578:1, end:1578:18))"]
#[derive(Clone, Debug)]
struct AddCondI11NullifyVar0 {}
impl AddCondI11NullifyVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfv().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1579:1, end:1579:18))"]
#[derive(Clone, Debug)]
struct AddCondI11NullifyVar1 {
    AddCondI11: TableAddCondI11,
}
impl AddCondI11NullifyVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_nullifyEnable(
            Some(inst_next),
            context.register().read_nullifyEnable_disassembly().unwrap(),
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_nullifyEnable_disassembly(tmp)
            .unwrap();
        let AddCondI11 = if let Some((len, table)) = TableAddCondI11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AddCondI11 }))
    }
}
#[derive(Clone, Debug)]
enum TableAddCondI11Nullify {
    Var0(AddCondI11NullifyVar0),
    Var1(AddCondI11NullifyVar1),
}
impl TableAddCondI11Nullify {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = AddCondI11NullifyVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = AddCondI11NullifyVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1587:1, end:1587:10))"]
#[derive(Clone, Debug)]
struct RegCSCondVar0 {
    R1: TableR1,
    R2: TableR2,
}
impl RegCSCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1588:1, end:1588:10))"]
#[derive(Clone, Debug)]
struct RegCSCondVar1 {
    R1: TableR1,
    R2: TableR2,
}
impl RegCSCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 1i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1589:1, end:1589:10))"]
#[derive(Clone, Debug)]
struct RegCSCondVar2 {
    R1: TableR1,
    R2: TableR2,
}
impl RegCSCondVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1590:1, end:1590:10))"]
#[derive(Clone, Debug)]
struct RegCSCondVar3 {
    R1: TableR1,
    R2: TableR2,
}
impl RegCSCondVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 3i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1591:1, end:1591:10))"]
#[derive(Clone, Debug)]
struct RegCSCondVar4 {
    R1: TableR1,
    R2: TableR2,
}
impl RegCSCondVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 4i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1592:1, end:1592:10))"]
#[derive(Clone, Debug)]
struct RegCSCondVar5 {
    R1: TableR1,
    R2: TableR2,
}
impl RegCSCondVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 5i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1593:1, end:1593:10))"]
#[derive(Clone, Debug)]
struct RegCSCondVar6 {
    R1: TableR1,
    R2: TableR2,
}
impl RegCSCondVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1594:1, end:1594:10))"]
#[derive(Clone, Debug)]
struct RegCSCondVar7 {
    R1: TableR1,
    R2: TableR2,
}
impl RegCSCondVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 7i128 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[derive(Clone, Debug)]
enum TableRegCSCond {
    Var0(RegCSCondVar0),
    Var1(RegCSCondVar1),
    Var2(RegCSCondVar2),
    Var3(RegCSCondVar3),
    Var4(RegCSCondVar4),
    Var5(RegCSCondVar5),
    Var6(RegCSCondVar6),
    Var7(RegCSCondVar7),
}
impl TableRegCSCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            RegCSCondVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            RegCSCondVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            RegCSCondVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            RegCSCondVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            RegCSCondVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            RegCSCondVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            RegCSCondVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            RegCSCondVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1596:1, end:1596:7))"]
#[derive(Clone, Debug)]
struct CSCondVar0 {
    RegCSCond: TableRegCSCond,
}
impl CSCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 0i128 {
            return None;
        }
        let RegCSCond = if let Some((len, table)) = TableRegCSCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegCSCond }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1597:1, end:1597:7))"]
#[derive(Clone, Debug)]
struct CSCondVar1 {
    RegCSCond: TableRegCSCond,
}
impl CSCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 1i128 {
            return None;
        }
        let RegCSCond = if let Some((len, table)) = TableRegCSCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegCSCond }))
    }
}
#[derive(Clone, Debug)]
enum TableCSCond {
    Var0(CSCondVar0),
    Var1(CSCondVar1),
}
impl TableCSCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            CSCondVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CSCondVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1599:1, end:1599:14))"]
#[derive(Clone, Debug)]
struct CSCondNullifyVar0 {}
impl CSCondNullifyVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfv().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1600:1, end:1600:14))"]
#[derive(Clone, Debug)]
struct CSCondNullifyVar1 {
    CSCond: TableCSCond,
}
impl CSCondNullifyVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_nullifyEnable(
            Some(inst_next),
            context.register().read_nullifyEnable_disassembly().unwrap(),
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_nullifyEnable_disassembly(tmp)
            .unwrap();
        let CSCond = if let Some((len, table)) = TableCSCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CSCond }))
    }
}
#[derive(Clone, Debug)]
enum TableCSCondNullify {
    Var0(CSCondNullifyVar0),
    Var1(CSCondNullifyVar1),
}
impl TableCSCondNullify {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = CSCondNullifyVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = CSCondNullifyVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1605:1, end:1605:10))"]
#[derive(Clone, Debug)]
struct CSCondSymVar0 {
    RegCSCondSym: TokenField_RegCSCondSym,
}
impl CSCondSymVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.RegCSCondSym.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 0i128 {
            return None;
        }
        let RegCSCondSym = token_parser.TokenFieldRegCSCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegCSCondSym }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1606:1, end:1606:10))"]
#[derive(Clone, Debug)]
struct CSCondSymVar1 {
    InvCSCondSym: TokenField_InvCSCondSym,
}
impl CSCondSymVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.InvCSCondSym.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 1i128 {
            return None;
        }
        let InvCSCondSym = token_parser.TokenFieldInvCSCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { InvCSCondSym }))
    }
}
#[derive(Clone, Debug)]
enum TableCSCondSym {
    Var0(CSCondSymVar0),
    Var1(CSCondSymVar1),
}
impl TableCSCondSym {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            CSCondSymVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CSCondSymVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1610:1, end:1610:11))"]
#[derive(Clone, Debug)]
struct RegCSCondIVar0 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegCSCondIVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1611:1, end:1611:11))"]
#[derive(Clone, Debug)]
struct RegCSCondIVar1 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegCSCondIVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 1i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1612:1, end:1612:11))"]
#[derive(Clone, Debug)]
struct RegCSCondIVar2 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegCSCondIVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1613:1, end:1613:11))"]
#[derive(Clone, Debug)]
struct RegCSCondIVar3 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegCSCondIVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 3i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1614:1, end:1614:11))"]
#[derive(Clone, Debug)]
struct RegCSCondIVar4 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegCSCondIVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 4i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1615:1, end:1615:11))"]
#[derive(Clone, Debug)]
struct RegCSCondIVar5 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegCSCondIVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 5i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1616:1, end:1616:11))"]
#[derive(Clone, Debug)]
struct RegCSCondIVar6 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegCSCondIVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1617:1, end:1617:11))"]
#[derive(Clone, Debug)]
struct RegCSCondIVar7 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegCSCondIVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 7i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[derive(Clone, Debug)]
enum TableRegCSCondI {
    Var0(RegCSCondIVar0),
    Var1(RegCSCondIVar1),
    Var2(RegCSCondIVar2),
    Var3(RegCSCondIVar3),
    Var4(RegCSCondIVar4),
    Var5(RegCSCondIVar5),
    Var6(RegCSCondIVar6),
    Var7(RegCSCondIVar7),
}
impl TableRegCSCondI {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = RegCSCondIVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondIVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondIVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondIVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondIVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondIVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondIVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondIVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1620:1, end:1620:13))"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var0 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegCSCondI11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1621:1, end:1621:13))"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var1 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegCSCondI11Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 1i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1622:1, end:1622:13))"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var2 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegCSCondI11Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1623:1, end:1623:13))"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var3 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegCSCondI11Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 3i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1624:1, end:1624:13))"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var4 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegCSCondI11Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 4i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1625:1, end:1625:13))"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var5 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegCSCondI11Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 5i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1626:1, end:1626:13))"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var6 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegCSCondI11Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1627:1, end:1627:13))"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var7 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegCSCondI11Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 7i128 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[derive(Clone, Debug)]
enum TableRegCSCondI11 {
    Var0(RegCSCondI11Var0),
    Var1(RegCSCondI11Var1),
    Var2(RegCSCondI11Var2),
    Var3(RegCSCondI11Var3),
    Var4(RegCSCondI11Var4),
    Var5(RegCSCondI11Var5),
    Var6(RegCSCondI11Var6),
    Var7(RegCSCondI11Var7),
}
impl TableRegCSCondI11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = RegCSCondI11Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondI11Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondI11Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondI11Var3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondI11Var4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondI11Var5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondI11Var6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondI11Var7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1629:1, end:1629:10))"]
#[derive(Clone, Debug)]
struct CSCondI11Var0 {
    RegCSCondI11: TableRegCSCondI11,
}
impl CSCondI11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 0i128 {
            return None;
        }
        let RegCSCondI11 = if let Some((len, table)) = TableRegCSCondI11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegCSCondI11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1630:1, end:1630:10))"]
#[derive(Clone, Debug)]
struct CSCondI11Var1 {
    RegCSCondI11: TableRegCSCondI11,
}
impl CSCondI11Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 1i128 {
            return None;
        }
        let RegCSCondI11 = if let Some((len, table)) = TableRegCSCondI11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegCSCondI11 }))
    }
}
#[derive(Clone, Debug)]
enum TableCSCondI11 {
    Var0(CSCondI11Var0),
    Var1(CSCondI11Var1),
}
impl TableCSCondI11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            CSCondI11Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CSCondI11Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1632:1, end:1632:17))"]
#[derive(Clone, Debug)]
struct CSCondI11NullifyVar0 {}
impl CSCondI11NullifyVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfv().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1633:1, end:1633:17))"]
#[derive(Clone, Debug)]
struct CSCondI11NullifyVar1 {
    CSCondI11: TableCSCondI11,
}
impl CSCondI11NullifyVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_nullifyEnable(
            Some(inst_next),
            context.register().read_nullifyEnable_disassembly().unwrap(),
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_nullifyEnable_disassembly(tmp)
            .unwrap();
        let CSCondI11 = if let Some((len, table)) = TableCSCondI11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CSCondI11 }))
    }
}
#[derive(Clone, Debug)]
enum TableCSCondI11Nullify {
    Var0(CSCondI11NullifyVar0),
    Var1(CSCondI11NullifyVar1),
}
impl TableCSCondI11Nullify {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = CSCondI11NullifyVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = CSCondI11NullifyVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1641:1, end:1641:13))"]
#[derive(Clone, Debug)]
struct RegLogicCondVar0 {}
impl RegLogicCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1642:1, end:1642:13))"]
#[derive(Clone, Debug)]
struct RegLogicCondVar1 {
    RT: TableRT,
}
impl RegLogicCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 1i128 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1643:1, end:1643:13))"]
#[derive(Clone, Debug)]
struct RegLogicCondVar2 {
    RT: TableRT,
}
impl RegLogicCondVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i128 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1644:1, end:1644:13))"]
#[derive(Clone, Debug)]
struct RegLogicCondVar3 {
    RT: TableRT,
}
impl RegLogicCondVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 3i128 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1645:1, end:1645:13))"]
#[derive(Clone, Debug)]
struct RegLogicCondVar4 {
    RT: TableRT,
}
impl RegLogicCondVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 7i128 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[derive(Clone, Debug)]
enum TableRegLogicCond {
    Var0(RegLogicCondVar0),
    Var1(RegLogicCondVar1),
    Var2(RegLogicCondVar2),
    Var3(RegLogicCondVar3),
    Var4(RegLogicCondVar4),
}
impl TableRegLogicCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = RegLogicCondVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = RegLogicCondVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = RegLogicCondVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = RegLogicCondVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = RegLogicCondVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1647:1, end:1647:10))"]
#[derive(Clone, Debug)]
struct LogicCondVar0 {
    RegLogicCond: TableRegLogicCond,
}
impl LogicCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 0i128 {
            return None;
        }
        let RegLogicCond = if let Some((len, table)) = TableRegLogicCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegLogicCond }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1648:1, end:1648:10))"]
#[derive(Clone, Debug)]
struct LogicCondVar1 {
    RegLogicCond: TableRegLogicCond,
}
impl LogicCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 1i128 {
            return None;
        }
        let RegLogicCond = if let Some((len, table)) = TableRegLogicCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegLogicCond }))
    }
}
#[derive(Clone, Debug)]
enum TableLogicCond {
    Var0(LogicCondVar0),
    Var1(LogicCondVar1),
}
impl TableLogicCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LogicCondVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LogicCondVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1650:1, end:1650:13))"]
#[derive(Clone, Debug)]
struct LogicCondSymVar0 {
    RegLogicCondSym: TokenField_RegLogicCondSym,
}
impl LogicCondSymVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.RegLogicCondSym.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 0i128 {
            return None;
        }
        let RegLogicCondSym = token_parser.TokenFieldRegLogicCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegLogicCondSym }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1651:1, end:1651:13))"]
#[derive(Clone, Debug)]
struct LogicCondSymVar1 {
    InvLogicCondSym: TokenField_InvLogicCondSym,
}
impl LogicCondSymVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.InvLogicCondSym.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 1i128 {
            return None;
        }
        let InvLogicCondSym = token_parser.TokenFieldInvLogicCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { InvLogicCondSym }))
    }
}
#[derive(Clone, Debug)]
enum TableLogicCondSym {
    Var0(LogicCondSymVar0),
    Var1(LogicCondSymVar1),
}
impl TableLogicCondSym {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = LogicCondSymVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = LogicCondSymVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1653:1, end:1653:17))"]
#[derive(Clone, Debug)]
struct LogicCondNullifyVar0 {}
impl LogicCondNullifyVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldfv().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1654:1, end:1654:17))"]
#[derive(Clone, Debug)]
struct LogicCondNullifyVar1 {
    LogicCond: TableLogicCond,
}
impl LogicCondNullifyVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_nullifyEnable(
            Some(inst_next),
            context.register().read_nullifyEnable_disassembly().unwrap(),
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_nullifyEnable_disassembly(tmp)
            .unwrap();
        let LogicCond = if let Some((len, table)) = TableLogicCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LogicCond }))
    }
}
#[derive(Clone, Debug)]
enum TableLogicCondNullify {
    Var0(LogicCondNullifyVar0),
    Var1(LogicCondNullifyVar1),
}
impl TableLogicCondNullify {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = LogicCondNullifyVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = LogicCondNullifyVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1665:1, end:1665:23))"]
#[derive(Clone, Debug)]
struct indexedByteAccessCmpltVar0 {
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl indexedByteAccessCmpltVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, SPCBASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1666:1, end:1666:23))"]
#[derive(Clone, Debug)]
struct indexedByteAccessCmpltVar1 {
    RX: TableRX,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
}
impl indexedByteAccessCmpltVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",M")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, RB, SPCBASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1667:1, end:1667:23))"]
#[derive(Clone, Debug)]
struct indexedByteAccessCmpltVar2 {
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl indexedByteAccessCmpltVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",S")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, SPCBASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1668:1, end:1668:23))"]
#[derive(Clone, Debug)]
struct indexedByteAccessCmpltVar3 {
    RX: TableRX,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
}
impl indexedByteAccessCmpltVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",SM")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, RB, SPCBASE }))
    }
}
#[derive(Clone, Debug)]
enum TableindexedByteAccessCmplt {
    Var0(indexedByteAccessCmpltVar0),
    Var1(indexedByteAccessCmpltVar1),
    Var2(indexedByteAccessCmpltVar2),
    Var3(indexedByteAccessCmpltVar3),
}
impl TableindexedByteAccessCmplt {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexedByteAccessCmpltVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = indexedByteAccessCmpltVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = indexedByteAccessCmpltVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = indexedByteAccessCmpltVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1671:1, end:1671:27))"]
#[derive(Clone, Debug)]
struct indexedHalfwordAccessCmpltVar0 {
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl indexedHalfwordAccessCmpltVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, SPCBASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1672:1, end:1672:27))"]
#[derive(Clone, Debug)]
struct indexedHalfwordAccessCmpltVar1 {
    RX: TableRX,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
}
impl indexedHalfwordAccessCmpltVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",M")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, RB, SPCBASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1673:1, end:1673:27))"]
#[derive(Clone, Debug)]
struct indexedHalfwordAccessCmpltVar2 {
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl indexedHalfwordAccessCmpltVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",S")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, SPCBASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1674:1, end:1674:27))"]
#[derive(Clone, Debug)]
struct indexedHalfwordAccessCmpltVar3 {
    RX: TableRX,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
}
impl indexedHalfwordAccessCmpltVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",SM")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, RB, SPCBASE }))
    }
}
#[derive(Clone, Debug)]
enum TableindexedHalfwordAccessCmplt {
    Var0(indexedHalfwordAccessCmpltVar0),
    Var1(indexedHalfwordAccessCmpltVar1),
    Var2(indexedHalfwordAccessCmpltVar2),
    Var3(indexedHalfwordAccessCmpltVar3),
}
impl TableindexedHalfwordAccessCmplt {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexedHalfwordAccessCmpltVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = indexedHalfwordAccessCmpltVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = indexedHalfwordAccessCmpltVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = indexedHalfwordAccessCmpltVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1677:1, end:1677:23))"]
#[derive(Clone, Debug)]
struct indexedWordAccessCmpltVar0 {
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl indexedWordAccessCmpltVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, SPCBASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1678:1, end:1678:23))"]
#[derive(Clone, Debug)]
struct indexedWordAccessCmpltVar1 {
    RX: TableRX,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
}
impl indexedWordAccessCmpltVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",M")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, RB, SPCBASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1679:1, end:1679:23))"]
#[derive(Clone, Debug)]
struct indexedWordAccessCmpltVar2 {
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl indexedWordAccessCmpltVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",S")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, SPCBASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1680:1, end:1680:23))"]
#[derive(Clone, Debug)]
struct indexedWordAccessCmpltVar3 {
    RX: TableRX,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
}
impl indexedWordAccessCmpltVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",SM")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, RB, SPCBASE }))
    }
}
#[derive(Clone, Debug)]
enum TableindexedWordAccessCmplt {
    Var0(indexedWordAccessCmpltVar0),
    Var1(indexedWordAccessCmpltVar1),
    Var2(indexedWordAccessCmpltVar2),
    Var3(indexedWordAccessCmpltVar3),
}
impl TableindexedWordAccessCmplt {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexedWordAccessCmpltVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = indexedWordAccessCmpltVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = indexedWordAccessCmpltVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = indexedWordAccessCmpltVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1683:1, end:1683:29))"]
#[derive(Clone, Debug)]
struct indexedDoublewordAccessCmpltVar0 {
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl indexedDoublewordAccessCmpltVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, SPCBASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1684:1, end:1684:29))"]
#[derive(Clone, Debug)]
struct indexedDoublewordAccessCmpltVar1 {
    RX: TableRX,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
}
impl indexedDoublewordAccessCmpltVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",M")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, RB, SPCBASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1685:1, end:1685:29))"]
#[derive(Clone, Debug)]
struct indexedDoublewordAccessCmpltVar2 {
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl indexedDoublewordAccessCmpltVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",S")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, SPCBASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1686:1, end:1686:29))"]
#[derive(Clone, Debug)]
struct indexedDoublewordAccessCmpltVar3 {
    RX: TableRX,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
}
impl indexedDoublewordAccessCmpltVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",SM")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, RB, SPCBASE }))
    }
}
#[derive(Clone, Debug)]
enum TableindexedDoublewordAccessCmplt {
    Var0(indexedDoublewordAccessCmpltVar0),
    Var1(indexedDoublewordAccessCmpltVar1),
    Var2(indexedDoublewordAccessCmpltVar2),
    Var3(indexedDoublewordAccessCmpltVar3),
}
impl TableindexedDoublewordAccessCmplt {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            indexedDoublewordAccessCmpltVar0::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            )
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexedDoublewordAccessCmpltVar1::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            )
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexedDoublewordAccessCmpltVar2::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            )
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexedDoublewordAccessCmpltVar3::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            )
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1691:1, end:1691:15))"]
#[derive(Clone, Debug)]
struct shortDispCmpltVar0 {
    RB: TableRB,
    RX: TableRX,
    SPCBASE: TableSPCBASE,
    highlse5: Tablehighlse5,
}
impl shortDispCmpltVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",MA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                RX,
                SPCBASE,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1692:1, end:1692:15))"]
#[derive(Clone, Debug)]
struct shortDispCmpltVar1 {
    RB: TableRB,
    RX: TableRX,
    SPCBASE: TableSPCBASE,
    highlse5: Tablehighlse5,
}
impl shortDispCmpltVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",MB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                RX,
                SPCBASE,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1690:1, end:1690:15))"]
#[derive(Clone, Debug)]
struct shortDispCmpltVar2 {
    highlse5: Tablehighlse5,
    SPCBASE: TableSPCBASE,
}
impl shortDispCmpltVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { highlse5, SPCBASE }))
    }
}
#[derive(Clone, Debug)]
enum TableshortDispCmplt {
    Var0(shortDispCmpltVar0),
    Var1(shortDispCmpltVar1),
    Var2(shortDispCmpltVar2),
}
impl TableshortDispCmplt {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = shortDispCmpltVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = shortDispCmpltVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = shortDispCmpltVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1696:1, end:1696:20))"]
#[derive(Clone, Debug)]
struct storeShortDispCmpltVar0 {
    RB: TableRB,
    RX: TableRX,
    SPCBASE: TableSPCBASE,
    lse5: Tablelse5,
}
impl storeShortDispCmpltVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",MA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                RX,
                SPCBASE,
                lse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1697:1, end:1697:20))"]
#[derive(Clone, Debug)]
struct storeShortDispCmpltVar1 {
    RB: TableRB,
    RX: TableRX,
    SPCBASE: TableSPCBASE,
    lse5: Tablelse5,
}
impl storeShortDispCmpltVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",MB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                RX,
                SPCBASE,
                lse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1695:1, end:1695:20))"]
#[derive(Clone, Debug)]
struct storeShortDispCmpltVar2 {
    lse5: Tablelse5,
    SPCBASE: TableSPCBASE,
}
impl storeShortDispCmpltVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse5, SPCBASE }))
    }
}
#[derive(Clone, Debug)]
enum TablestoreShortDispCmplt {
    Var0(storeShortDispCmpltVar0),
    Var1(storeShortDispCmpltVar1),
    Var2(storeShortDispCmpltVar2),
}
impl TablestoreShortDispCmplt {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = storeShortDispCmpltVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = storeShortDispCmpltVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = storeShortDispCmpltVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1700:1, end:1700:21))"]
#[derive(Clone, Debug)]
struct storeBytesShortCmpltVar0 {
    SPCBASE: TableSPCBASE,
    lse5: Tablelse5,
}
impl storeBytesShortCmpltVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPCBASE, lse5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1701:1, end:1701:21))"]
#[derive(Clone, Debug)]
struct storeBytesShortCmpltVar1 {
    SPCBASE: TableSPCBASE,
    RR: TableRR,
    lse5: Tablelse5,
}
impl storeBytesShortCmpltVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",BM")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPCBASE, RR, lse5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1702:1, end:1702:21))"]
#[derive(Clone, Debug)]
struct storeBytesShortCmpltVar2 {
    SPCBASE: TableSPCBASE,
    lse5: Tablelse5,
}
impl storeBytesShortCmpltVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",E")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPCBASE, lse5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1703:1, end:1703:21))"]
#[derive(Clone, Debug)]
struct storeBytesShortCmpltVar3 {
    SPCBASE: TableSPCBASE,
    RR: TableRR,
    lse5: Tablelse5,
}
impl storeBytesShortCmpltVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",EM")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPCBASE, RR, lse5 }))
    }
}
#[derive(Clone, Debug)]
enum TablestoreBytesShortCmplt {
    Var0(storeBytesShortCmpltVar0),
    Var1(storeBytesShortCmpltVar1),
    Var2(storeBytesShortCmpltVar2),
    Var3(storeBytesShortCmpltVar3),
}
impl TablestoreBytesShortCmplt {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = storeBytesShortCmpltVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = storeBytesShortCmpltVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = storeBytesShortCmpltVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = storeBytesShortCmpltVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1706:1, end:1706:9))"]
#[derive(Clone, Debug)]
struct sysCmpltVar0 {}
impl sysCmpltVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldm().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1707:1, end:1707:9))"]
#[derive(Clone, Debug)]
struct sysCmpltVar1 {}
impl sysCmpltVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",M")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldm().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablesysCmplt {
    Var0(sysCmpltVar0),
    Var1(sysCmpltVar1),
}
impl TablesysCmplt {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sysCmpltVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sysCmpltVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1710:1, end:1710:7))"]
#[derive(Clone, Debug)]
struct loadCCVar0 {}
impl loadCCVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcc().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1711:1, end:1711:7))"]
#[derive(Clone, Debug)]
struct loadCCVar1 {}
impl loadCCVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",SL")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcc().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableloadCC {
    Var0(loadCCVar0),
    Var1(loadCCVar1),
}
impl TableloadCC {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            loadCCVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            loadCCVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1714:1, end:1714:8))"]
#[derive(Clone, Debug)]
struct storeCCVar0 {}
impl storeCCVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcc().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1715:1, end:1715:8))"]
#[derive(Clone, Debug)]
struct storeCCVar1 {}
impl storeCCVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",BC")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcc().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1716:1, end:1716:8))"]
#[derive(Clone, Debug)]
struct storeCCVar2 {}
impl storeCCVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",SL")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcc().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablestoreCC {
    Var0(storeCCVar0),
    Var1(storeCCVar1),
    Var2(storeCCVar2),
}
impl TablestoreCC {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            storeCCVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            storeCCVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            storeCCVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1719:1, end:1719:12))"]
#[derive(Clone, Debug)]
struct loadClearCCVar0 {}
impl loadClearCCVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcc().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1720:1, end:1720:12))"]
#[derive(Clone, Debug)]
struct loadClearCCVar1 {}
impl loadClearCCVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",CO")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcc().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableloadClearCC {
    Var0(loadClearCCVar0),
    Var1(loadClearCCVar1),
}
impl TableloadClearCC {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = loadClearCCVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = loadClearCCVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1726:1, end:1726:17))"]
#[derive(Clone, Debug)]
struct nullifyForBranchVar0 {}
impl nullifyForBranchVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldn().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1727:1, end:1727:17))"]
#[derive(Clone, Debug)]
struct nullifyForBranchVar1 {}
impl nullifyForBranchVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_nullifyEnable(
            Some(inst_next),
            context.register().read_nullifyEnable_disassembly().unwrap(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",N")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldn().disassembly() != 1i128 {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_nullifyEnable_disassembly(tmp)
            .unwrap();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablenullifyForBranch {
    Var0(nullifyForBranchVar0),
    Var1(nullifyForBranchVar1),
}
impl TablenullifyForBranch {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = nullifyForBranchVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = nullifyForBranchVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1729:1, end:1729:20))"]
#[derive(Clone, Debug)]
struct nullifySymForBranchVar0 {}
impl nullifySymForBranchVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldn().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1730:1, end:1730:20))"]
#[derive(Clone, Debug)]
struct nullifySymForBranchVar1 {}
impl nullifySymForBranchVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",N")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldn().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablenullifySymForBranch {
    Var0(nullifySymForBranchVar0),
    Var1(nullifySymForBranchVar1),
}
impl TablenullifySymForBranch {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = nullifySymForBranchVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = nullifySymForBranchVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1733:1, end:1733:18))"]
#[derive(Clone, Debug)]
struct nullifyForSpecialVar0 {}
impl nullifyForSpecialVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldspn().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1734:1, end:1734:18))"]
#[derive(Clone, Debug)]
struct nullifyForSpecialVar1 {}
impl nullifyForSpecialVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",N")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldspn().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablenullifyForSpecial {
    Var0(nullifyForSpecialVar0),
    Var1(nullifyForSpecialVar1),
}
impl TablenullifyForSpecial {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = nullifyForSpecialVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = nullifyForSpecialVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1744:1, end:1744:4))"]
#[derive(Clone, Debug)]
struct SFUVar0 {
    sfu: TokenField_sfu,
}
impl SFUVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.sfu.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let sfu = token_parser.TokenFieldsfu();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sfu }))
    }
}
#[derive(Clone, Debug)]
enum TableSFU {
    Var0(SFUVar0),
}
impl TableSFU {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            SFUVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
pub fn parse_instruction<T>(
    tokens: &[u8],
    context: &mut T,
    inst_start: u32,
    global_set: &mut impl GlobalSetTrait,
) -> Option<(u32, Vec<DisplayElement>)>
where
    T: ContextTrait + Clone,
{
    let (inst_len, instruction) =
        Tableinstruction::parse(tokens, context, inst_start)?;
    let inst_next = inst_start + inst_len;
    let mut display = vec![];
    instruction.display_extend(
        &mut display,
        context,
        inst_start,
        inst_next,
        global_set,
    );
    Some((inst_next, display))
}
