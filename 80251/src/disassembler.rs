use sleigh4rust::*;
pub type AddrType = u32;
pub trait GlobalSetTrait {
    fn set_phase(&mut self, address: Option<u32>, value: i128);
    fn set_srcMode(&mut self, address: Option<u32>, value: i128);
    fn set_A5Prefix(&mut self, address: Option<u32>, value: i128);
}
#[derive(Default)]
pub struct GlobalSetDefault<C: ContextTrait>(
    pub std::collections::HashMap<AddrType, C>,
);
impl<C: ContextTrait> GlobalSetTrait for GlobalSetDefault<C> {
    fn set_phase(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_phase_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_srcMode(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_srcMode_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_A5Prefix(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_A5Prefix_disassembly(value)
                .unwrap();
            context
        });
    }
}
pub trait ContextregisterTrait:
    MemoryRead<AddressType = u8> + MemoryWrite
{
    fn read_phase_raw(&self) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<true>(3, 0, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_phase_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<true>(u8::from(param), 3, 0, 1)
    }
    fn read_phase_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_phase_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_phase_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_phase_raw(param as u8)
    }
    fn read_phase_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_phase_raw()
    }
    fn write_phase_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_phase_raw(param)
    }
    fn phase_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_phase_raw()?))
    }
    fn read_srcMode_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<true>(3, 1, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_srcMode_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<true>(u8::from(param), 3, 1, 1)
    }
    fn read_srcMode_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_srcMode_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_srcMode_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_srcMode_raw(param as u8)
    }
    fn read_srcMode_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_srcMode_raw()
    }
    fn write_srcMode_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_srcMode_raw(param)
    }
    fn srcMode_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_srcMode_raw()?))
    }
    fn read_A5Prefix_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<true>(3, 2, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_A5Prefix_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<true>(u8::from(param), 3, 2, 1)
    }
    fn read_A5Prefix_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_A5Prefix_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_A5Prefix_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_A5Prefix_raw(param as u8)
    }
    fn read_A5Prefix_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_A5Prefix_raw()
    }
    fn write_A5Prefix_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_A5Prefix_raw(param)
    }
    fn A5Prefix_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_A5Prefix_raw()?))
    }
}
pub trait ContextTrait: Default {
    type Typeregister: ContextregisterTrait;
    fn register(&self) -> &Self::Typeregister;
    fn register_mut(&mut self) -> &mut Self::Typeregister;
}
#[derive(Debug, Clone, Copy)]
pub struct ContextregisterStructDebug {
    pub chunk_0x0: [Option<bool>; 32],
}
impl Default for ContextregisterStructDebug {
    fn default() -> Self {
        Self {
            chunk_0x0: [None; 32],
        }
    }
}
impl ContextregisterStructDebug {
    fn read_bits(
        &self,
        addr: <Self as MemoryRead>::AddressType,
        buf: &mut [u8],
        mask: &[u8],
    ) -> Result<(), MemoryReadError<<Self as MemoryRead>::AddressType>> {
        assert_eq!(buf.len(), mask.len());
        let buf_len =
            <<Self as MemoryRead>::AddressType>::try_from(buf.len()).unwrap();
        let addr_end = addr + ((buf_len + 7) / 8);
        match (addr, addr_end) {
            (0..=3, 0..=4) => {
                let byte_offset = usize::try_from(addr - 0).unwrap();
                for ((buf_byte, mask_byte), byte) in
                    buf.iter_mut().zip(mask.iter()).zip(byte_offset..)
                {
                    for bit in (0..8)
                        .into_iter()
                        .filter(|bit| ((*mask_byte >> bit) & 1) != 0)
                    {
                        *buf_byte |= (self.chunk_0x0[(byte * 8) + bit].unwrap()
                            as u8)
                            << bit;
                    }
                }
            }
            (addr_start, addr_end) => {
                return Err(MemoryReadError::UnableToReadMemory(
                    addr_start, addr_end,
                ))
            }
        }
        Ok(())
    }
    fn write_bits(
        &mut self,
        addr: <Self as MemoryRead>::AddressType,
        buf: &[u8],
        mask: &[u8],
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        assert_eq!(buf.len(), mask.len());
        let buf_len =
            <<Self as MemoryRead>::AddressType>::try_from(buf.len()).unwrap();
        let addr_end = addr + ((buf_len + 7) / 8);
        match (addr, addr_end) {
            (0..=3, 0..=4) => {
                let byte_offset = usize::try_from(addr - 0).unwrap();
                for ((buf_byte, mask_byte), byte) in
                    buf.iter().zip(mask.iter()).zip(byte_offset..)
                {
                    for bit in (0..8)
                        .into_iter()
                        .filter(|bit| ((*mask_byte >> bit) & 1) != 0)
                    {
                        self.chunk_0x0[(byte * 8) + bit] =
                            Some(*buf_byte & (1 << bit) != 0);
                    }
                }
            }
            (addr_start, addr_end) => {
                return Err(MemoryWriteError::UnableToWriteMemory(
                    addr_start, addr_end,
                ))
            }
        }
        Ok(())
    }
}
impl ContextregisterTrait for ContextregisterStructDebug {}
impl MemoryRead for ContextregisterStructDebug {
    type AddressType = u8;
    fn read(
        &self,
        addr: <Self as MemoryRead>::AddressType,
        buf: &mut [u8],
    ) -> Result<(), MemoryReadError<<Self as MemoryRead>::AddressType>> {
        let mut inner_buf = vec![0xFF; buf.len()];
        self.read_bits(addr, buf, &mut inner_buf)
    }
    fn read_u8<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u8, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u8>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u8>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u8>::from_be_bytes(data)
        } else {
            <u8>::from_le_bytes(data)
        };
        let value_mask = <u8>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
    fn read_u16<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u16, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u16>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u16>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u16>::from_be_bytes(data)
        } else {
            <u16>::from_le_bytes(data)
        };
        let value_mask = <u16>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
    fn read_u32<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u32, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u32>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u32>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u32>::from_be_bytes(data)
        } else {
            <u32>::from_le_bytes(data)
        };
        let value_mask = <u32>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
    fn read_u64<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u64, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u64>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u64>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u64>::from_be_bytes(data)
        } else {
            <u64>::from_le_bytes(data)
        };
        let value_mask = <u64>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
    fn read_u128<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u128, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u128>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u128>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u128>::from_be_bytes(data)
        } else {
            <u128>::from_le_bytes(data)
        };
        let value_mask = <u128>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
}
impl MemoryWrite for ContextregisterStructDebug {
    fn write(
        &mut self,
        addr: <Self as MemoryRead>::AddressType,
        buf: &[u8],
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        let mut inner_buf = vec![0xFF; buf.len()];
        self.write_bits(addr, buf, &inner_buf)
    }
    fn write_u8<const BIG_ENDIAN: bool>(
        &mut self,
        value: u8,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u8>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u8>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
    fn write_u16<const BIG_ENDIAN: bool>(
        &mut self,
        value: u16,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u16>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u16>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
    fn write_u32<const BIG_ENDIAN: bool>(
        &mut self,
        value: u32,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u32>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u32>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
    fn write_u64<const BIG_ENDIAN: bool>(
        &mut self,
        value: u64,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u64>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u64>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
    fn write_u128<const BIG_ENDIAN: bool>(
        &mut self,
        value: u128,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u128>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u128>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
}
#[derive(Debug, Clone, Copy, Default)]
pub struct SpacesStruct {
    pub register: ContextregisterStructDebug,
}
impl ContextTrait for SpacesStruct {
    type Typeregister = ContextregisterStructDebug;
    fn register(&self) -> &Self::Typeregister {
        &self.register
    }
    fn register_mut(&mut self) -> &mut Self::Typeregister {
        &mut self.register
    }
}
fn meaning_number<T>(hex: bool, num: T) -> DisplayElement
where
    i128: TryFrom<T>,
    <i128 as TryFrom<T>>::Error: core::fmt::Debug,
{
    DisplayElement::Number(hex, i128::try_from(num).unwrap())
}
fn meaning_0_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_0_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_0_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::R0,
        1 => Register::R1,
        2 => Register::R2,
        3 => Register::R3,
        4 => Register::R4,
        5 => Register::R5,
        6 => Register::R6,
        7 => Register::R7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_1_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_1_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_1_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::R0,
        1 => Register::R1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_2_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_2_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_2_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::R0,
        1 => Register::R1,
        2 => Register::R2,
        3 => Register::R3,
        4 => Register::R4,
        5 => Register::R5,
        6 => Register::R6,
        7 => Register::R7,
        8 => Register::R8,
        9 => Register::R9,
        10 => Register::B,
        11 => Register::ACC,
        12 => Register::R12,
        13 => Register::R13,
        14 => Register::R14,
        15 => Register::R15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_3_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_3_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_3_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::R0,
        1 => Register::R0,
        2 => Register::R2,
        3 => Register::R2,
        4 => Register::R4,
        5 => Register::R3,
        6 => Register::R6,
        7 => Register::R6,
        8 => Register::R8,
        9 => Register::R8,
        10 => Register::B,
        11 => Register::B,
        12 => Register::R12,
        13 => Register::R12,
        14 => Register::R14,
        15 => Register::R14,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_4_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_4_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_4_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::R1,
        1 => Register::R1,
        2 => Register::R3,
        3 => Register::R3,
        4 => Register::R5,
        5 => Register::R5,
        6 => Register::R7,
        7 => Register::R7,
        8 => Register::R9,
        9 => Register::R9,
        10 => Register::ACC,
        11 => Register::ACC,
        12 => Register::R13,
        13 => Register::R13,
        14 => Register::R15,
        15 => Register::R15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_5_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_5_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_5_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::WR0,
        1 => Register::WR2,
        2 => Register::WR4,
        3 => Register::WR6,
        4 => Register::WR8,
        5 => Register::AB,
        6 => Register::WR12,
        7 => Register::WR14,
        8 => Register::WR16,
        9 => Register::WR18,
        10 => Register::WR20,
        11 => Register::WR22,
        12 => Register::WR24,
        13 => Register::WR26,
        14 => Register::WR28,
        15 => Register::WR30,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_6_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_6_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_6_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::WR0,
        1 => Register::WR0,
        2 => Register::WR4,
        3 => Register::WR4,
        4 => Register::WR8,
        5 => Register::WR8,
        6 => Register::WR12,
        7 => Register::WR12,
        8 => Register::WR16,
        9 => Register::WR16,
        10 => Register::WR20,
        11 => Register::WR20,
        12 => Register::WR24,
        13 => Register::WR24,
        14 => Register::WR28,
        15 => Register::WR28,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_7_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_7_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_7_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::WR2,
        1 => Register::WR2,
        2 => Register::WR6,
        3 => Register::WR6,
        4 => Register::AB,
        5 => Register::AB,
        6 => Register::WR14,
        7 => Register::WR14,
        8 => Register::WR18,
        9 => Register::WR18,
        10 => Register::WR22,
        11 => Register::WR22,
        12 => Register::WR26,
        13 => Register::WR26,
        14 => Register::WR30,
        15 => Register::WR30,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_8_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_8_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_8_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::DR0,
        1 => Register::DR4,
        2 => Register::DR8,
        3 => Register::DR12,
        4 => Register::DR16,
        5 => Register::DR20,
        6 => Register::DR24,
        7 => Register::DR28,
        8 => Register::DPX,
        9 => Register::SPX,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_9_display<T>(hex: bool, num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_9_value(num);
    let value = i128::try_from(value).unwrap();
    DisplayElement::Number(hex, value)
}
fn meaning_9_value<T>(num: T) -> u8
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => 1,
        1 => 2,
        2 => 4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_opfull(u8);
impl TokenField_opfull {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_oplo(u8);
impl TokenField_oplo {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_ophi(u8);
impl TokenField_ophi {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rn(u8);
impl TokenField_rn {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rnfill(u8);
impl TokenField_rnfill {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_ri(u8);
impl TokenField_ri {
    fn execution(&self) -> Register {
        meaning_1_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rifill(u8);
impl TokenField_rifill {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_opaddr(u8);
impl TokenField_opaddr {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_addrfill(u8);
impl TokenField_addrfill {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_b_0000(u8);
impl TokenField_b_0000 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_b_0001(u8);
impl TokenField_b_0001 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_b_0002(u8);
impl TokenField_b_0002 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_b_0005(u8);
impl TokenField_b_0005 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_b_0101(u8);
impl TokenField_b_0101 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_b_0107(u8);
impl TokenField_b_0107 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_b_0207(u8);
impl TokenField_b_0207 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_b_0307(u8);
impl TokenField_b_0307 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_b_0607(u8);
impl TokenField_b_0607 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_direct(u8);
impl TokenField_direct {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bank(u8);
impl TokenField_bank {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sfr(u8);
impl TokenField_sfr {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sfr6(u8);
impl TokenField_sfr6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sfrlo(u8);
impl TokenField_sfrlo {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_mainreg(u8);
impl TokenField_mainreg {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_direct17(u8);
impl TokenField_direct17 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_direct2(u8);
impl TokenField_direct2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bank2(u8);
impl TokenField_bank2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sfr2(u8);
impl TokenField_sfr2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sfr26(u8);
impl TokenField_sfr26 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sfr2lo(u8);
impl TokenField_sfr2lo {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_mainreg2(u8);
impl TokenField_mainreg2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bitaddr8(u8);
impl TokenField_bitaddr8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bitaddr27(u8);
impl TokenField_bitaddr27 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bitbank(u8);
impl TokenField_bitbank {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sfrbyte(u8);
impl TokenField_sfrbyte {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bitaddr57(u8);
impl TokenField_bitaddr57 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sfrbit6(u8);
impl TokenField_sfrbit6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sfrbit3(u8);
impl TokenField_sfrbit3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sfrbit(u8);
impl TokenField_sfrbit {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(false, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_lowbyte(u8);
impl TokenField_lowbyte {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bitaddr0(u8);
impl TokenField_bitaddr0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_addr16(u16);
impl TokenField_addr16 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rel8(i8);
impl TokenField_rel8 {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_data(u8);
impl TokenField_data {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_data16(u16);
impl TokenField_data16 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rel16(i16);
impl TokenField_rel16 {
    fn execution(&self) -> i16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_aoplo(u8);
impl TokenField_aoplo {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_aopaddr(u8);
impl TokenField_aopaddr {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_aaddrfill(u8);
impl TokenField_aaddrfill {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_adata(u8);
impl TokenField_adata {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rm47(u8);
impl TokenField_rm47 {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rm47_d1(u8);
impl TokenField_rm47_d1 {
    fn execution(&self) -> Register {
        meaning_3_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_3_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rm47_d2(u8);
impl TokenField_rm47_d2 {
    fn execution(&self) -> Register {
        meaning_4_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_4_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rm03(u8);
impl TokenField_rm03 {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_wrj47(u8);
impl TokenField_wrj47 {
    fn execution(&self) -> Register {
        meaning_5_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_5_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_wrj47_d1(u8);
impl TokenField_wrj47_d1 {
    fn execution(&self) -> Register {
        meaning_6_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_6_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_wrj47_d2(u8);
impl TokenField_wrj47_d2 {
    fn execution(&self) -> Register {
        meaning_7_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_7_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_wrj03(u8);
impl TokenField_wrj03 {
    fn execution(&self) -> Register {
        meaning_5_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_5_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_drk47(u8);
impl TokenField_drk47 {
    fn execution(&self) -> Register {
        meaning_8_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_8_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_drk03(u8);
impl TokenField_drk03 {
    fn execution(&self) -> Register {
        meaning_8_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_8_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_d7(u8);
impl TokenField_d7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_d57(u8);
impl TokenField_d57 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_d47(u8);
impl TokenField_d47 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_s3(u8);
impl TokenField_s3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_s23(u8);
impl TokenField_s23 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_s13(u8);
impl TokenField_s13 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_s03(u8);
impl TokenField_s03 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_s1(u8);
impl TokenField_s1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_s0(u8);
impl TokenField_s0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_short01(i8);
impl TokenField_short01 {
    fn execution(&self) -> u8 {
        meaning_9_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.execution()).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_9_display(false, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit02(u8);
impl TokenField_bit02 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rm47_(u8);
impl TokenField_rm47_ {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rm03_(u8);
impl TokenField_rm03_ {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_wrj47_(u8);
impl TokenField_wrj47_ {
    fn execution(&self) -> Register {
        meaning_5_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_5_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_wrj03_(u8);
impl TokenField_wrj03_ {
    fn execution(&self) -> Register {
        meaning_5_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_5_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_drk47_(u8);
impl TokenField_drk47_ {
    fn execution(&self) -> Register {
        meaning_8_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_8_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_drk03_(u8);
impl TokenField_drk03_ {
    fn execution(&self) -> Register {
        meaning_8_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_8_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_d7_(u8);
impl TokenField_d7_ {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_d57_(u8);
impl TokenField_d57_ {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_s3_(u8);
impl TokenField_s3_ {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_s13_(u8);
impl TokenField_s13_ {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_s03_(u8);
impl TokenField_s03_ {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_addr24(u32);
impl TokenField_addr24 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_data24(u32);
impl TokenField_data24 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
struct TokenParser<const LEN: usize>([u8; LEN]);
impl<const LEN: usize> MemoryRead for TokenParser<LEN> {
    type AddressType = usize;
    fn read(
        &self,
        addr: Self::AddressType,
        buf: &mut [u8],
    ) -> Result<(), MemoryReadError<Self::AddressType>> {
        let end = addr + buf.len();
        self.0
            .get(addr..end)
            .map(|src| buf.copy_from_slice(src))
            .ok_or(MemoryReadError::UnableToReadMemory(addr, end))
    }
}
impl<const LEN: usize> TokenParser<LEN> {
    fn new(data: &[u8]) -> Option<Self> {
        let token_slice: &[u8] = data.get(..LEN)?;
        let token_data = <[u8; LEN]>::try_from(token_slice).unwrap();
        Some(Self(token_data))
    }
    fn TokenFieldopfull(&self) -> TokenField_opfull {
        let inner_value = self.read_u8::<true>(0, 0, 8).unwrap();
        TokenField_opfull(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldoplo(&self) -> TokenField_oplo {
        let inner_value = self.read_u8::<true>(0, 0, 4).unwrap();
        TokenField_oplo(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldophi(&self) -> TokenField_ophi {
        let inner_value = self.read_u8::<true>(0, 4, 4).unwrap();
        TokenField_ophi(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldrn(&self) -> TokenField_rn {
        let inner_value = self.read_u8::<true>(0, 0, 3).unwrap();
        TokenField_rn(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldrnfill(&self) -> TokenField_rnfill {
        let inner_value = self.read_u8::<true>(0, 3, 1).unwrap();
        TokenField_rnfill(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldri(&self) -> TokenField_ri {
        let inner_value = self.read_u8::<true>(0, 0, 1).unwrap();
        TokenField_ri(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldrifill(&self) -> TokenField_rifill {
        let inner_value = self.read_u8::<true>(0, 1, 3).unwrap();
        TokenField_rifill(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldopaddr(&self) -> TokenField_opaddr {
        let inner_value = self.read_u8::<true>(0, 5, 3).unwrap();
        TokenField_opaddr(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldaddrfill(&self) -> TokenField_addrfill {
        let inner_value = self.read_u8::<true>(0, 4, 1).unwrap();
        TokenField_addrfill(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldb_0000(&self) -> TokenField_b_0000 {
        let inner_value = self.read_u8::<true>(0, 0, 1).unwrap();
        TokenField_b_0000(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldb_0001(&self) -> TokenField_b_0001 {
        let inner_value = self.read_u8::<true>(0, 0, 2).unwrap();
        TokenField_b_0001(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldb_0002(&self) -> TokenField_b_0002 {
        let inner_value = self.read_u8::<true>(0, 0, 3).unwrap();
        TokenField_b_0002(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldb_0005(&self) -> TokenField_b_0005 {
        let inner_value = self.read_u8::<true>(0, 0, 6).unwrap();
        TokenField_b_0005(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldb_0101(&self) -> TokenField_b_0101 {
        let inner_value = self.read_u8::<true>(0, 1, 1).unwrap();
        TokenField_b_0101(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldb_0107(&self) -> TokenField_b_0107 {
        let inner_value = self.read_u8::<true>(0, 1, 7).unwrap();
        TokenField_b_0107(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldb_0207(&self) -> TokenField_b_0207 {
        let inner_value = self.read_u8::<true>(0, 2, 6).unwrap();
        TokenField_b_0207(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldb_0307(&self) -> TokenField_b_0307 {
        let inner_value = self.read_u8::<true>(0, 3, 5).unwrap();
        TokenField_b_0307(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldb_0607(&self) -> TokenField_b_0607 {
        let inner_value = self.read_u8::<true>(0, 6, 2).unwrap();
        TokenField_b_0607(u8::try_from(inner_value).unwrap())
    }
    fn TokenFielddirect(&self) -> TokenField_direct {
        let inner_value = self.read_u8::<true>(0, 0, 8).unwrap();
        TokenField_direct(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbank(&self) -> TokenField_bank {
        let inner_value = self.read_u8::<true>(0, 7, 1).unwrap();
        TokenField_bank(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsfr(&self) -> TokenField_sfr {
        let inner_value = self.read_u8::<true>(0, 0, 7).unwrap();
        TokenField_sfr(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsfr6(&self) -> TokenField_sfr6 {
        let inner_value = self.read_u8::<true>(0, 6, 1).unwrap();
        TokenField_sfr6(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsfrlo(&self) -> TokenField_sfrlo {
        let inner_value = self.read_u8::<true>(0, 0, 4).unwrap();
        TokenField_sfrlo(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldmainreg(&self) -> TokenField_mainreg {
        let inner_value = self.read_u8::<true>(0, 0, 7).unwrap();
        TokenField_mainreg(u8::try_from(inner_value).unwrap())
    }
    fn TokenFielddirect17(&self) -> TokenField_direct17 {
        let inner_value = self.read_u8::<true>(0, 1, 7).unwrap();
        TokenField_direct17(u8::try_from(inner_value).unwrap())
    }
    fn TokenFielddirect2(&self) -> TokenField_direct2 {
        let inner_value = self.read_u8::<true>(0, 0, 8).unwrap();
        TokenField_direct2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbank2(&self) -> TokenField_bank2 {
        let inner_value = self.read_u8::<true>(0, 7, 1).unwrap();
        TokenField_bank2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsfr2(&self) -> TokenField_sfr2 {
        let inner_value = self.read_u8::<true>(0, 0, 7).unwrap();
        TokenField_sfr2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsfr26(&self) -> TokenField_sfr26 {
        let inner_value = self.read_u8::<true>(0, 6, 1).unwrap();
        TokenField_sfr26(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsfr2lo(&self) -> TokenField_sfr2lo {
        let inner_value = self.read_u8::<true>(0, 0, 4).unwrap();
        TokenField_sfr2lo(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldmainreg2(&self) -> TokenField_mainreg2 {
        let inner_value = self.read_u8::<true>(0, 0, 7).unwrap();
        TokenField_mainreg2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbitaddr8(&self) -> TokenField_bitaddr8 {
        let inner_value = self.read_u8::<true>(0, 0, 8).unwrap();
        TokenField_bitaddr8(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbitaddr27(&self) -> TokenField_bitaddr27 {
        let inner_value = self.read_u8::<true>(0, 2, 6).unwrap();
        TokenField_bitaddr27(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbitbank(&self) -> TokenField_bitbank {
        let inner_value = self.read_u8::<true>(0, 7, 1).unwrap();
        TokenField_bitbank(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsfrbyte(&self) -> TokenField_sfrbyte {
        let inner_value = self.read_u8::<true>(0, 3, 5).unwrap();
        TokenField_sfrbyte(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbitaddr57(&self) -> TokenField_bitaddr57 {
        let inner_value = self.read_u8::<true>(0, 5, 3).unwrap();
        TokenField_bitaddr57(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsfrbit6(&self) -> TokenField_sfrbit6 {
        let inner_value = self.read_u8::<true>(0, 6, 1).unwrap();
        TokenField_sfrbit6(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsfrbit3(&self) -> TokenField_sfrbit3 {
        let inner_value = self.read_u8::<true>(0, 3, 1).unwrap();
        TokenField_sfrbit3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsfrbit(&self) -> TokenField_sfrbit {
        let inner_value = self.read_u8::<true>(0, 0, 3).unwrap();
        TokenField_sfrbit(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldlowbyte(&self) -> TokenField_lowbyte {
        let inner_value = self.read_u8::<true>(0, 3, 4).unwrap();
        TokenField_lowbyte(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbitaddr0(&self) -> TokenField_bitaddr0 {
        let inner_value = self.read_u8::<true>(0, 0, 1).unwrap();
        TokenField_bitaddr0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldaddr16(&self) -> TokenField_addr16 {
        let inner_value = self.read_u16::<true>(0, 0, 16).unwrap();
        TokenField_addr16(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldrel8(&self) -> TokenField_rel8 {
        let inner_value = self.read_i8::<true>(0, 0, 8).unwrap();
        TokenField_rel8(i8::try_from(inner_value).unwrap())
    }
    fn TokenFielddata(&self) -> TokenField_data {
        let inner_value = self.read_u8::<true>(0, 0, 8).unwrap();
        TokenField_data(u8::try_from(inner_value).unwrap())
    }
    fn TokenFielddata16(&self) -> TokenField_data16 {
        let inner_value = self.read_u16::<true>(0, 0, 16).unwrap();
        TokenField_data16(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldrel16(&self) -> TokenField_rel16 {
        let inner_value = self.read_i16::<true>(0, 0, 16).unwrap();
        TokenField_rel16(i16::try_from(inner_value).unwrap())
    }
    fn TokenFieldaoplo(&self) -> TokenField_aoplo {
        let inner_value = self.read_u8::<true>(0, 0, 4).unwrap();
        TokenField_aoplo(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldaopaddr(&self) -> TokenField_aopaddr {
        let inner_value = self.read_u8::<true>(0, 5, 3).unwrap();
        TokenField_aopaddr(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldaaddrfill(&self) -> TokenField_aaddrfill {
        let inner_value = self.read_u8::<true>(0, 4, 1).unwrap();
        TokenField_aaddrfill(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldadata(&self) -> TokenField_adata {
        let inner_value = self.read_u8::<true>(1, 0, 8).unwrap();
        TokenField_adata(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldrm47(&self) -> TokenField_rm47 {
        let inner_value = self.read_u8::<true>(0, 4, 4).unwrap();
        TokenField_rm47(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldrm47_d1(&self) -> TokenField_rm47_d1 {
        let inner_value = self.read_u8::<true>(0, 4, 4).unwrap();
        TokenField_rm47_d1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldrm47_d2(&self) -> TokenField_rm47_d2 {
        let inner_value = self.read_u8::<true>(0, 4, 4).unwrap();
        TokenField_rm47_d2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldrm03(&self) -> TokenField_rm03 {
        let inner_value = self.read_u8::<true>(0, 0, 4).unwrap();
        TokenField_rm03(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldwrj47(&self) -> TokenField_wrj47 {
        let inner_value = self.read_u8::<true>(0, 4, 4).unwrap();
        TokenField_wrj47(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldwrj47_d1(&self) -> TokenField_wrj47_d1 {
        let inner_value = self.read_u8::<true>(0, 4, 4).unwrap();
        TokenField_wrj47_d1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldwrj47_d2(&self) -> TokenField_wrj47_d2 {
        let inner_value = self.read_u8::<true>(0, 4, 4).unwrap();
        TokenField_wrj47_d2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldwrj03(&self) -> TokenField_wrj03 {
        let inner_value = self.read_u8::<true>(0, 0, 4).unwrap();
        TokenField_wrj03(u8::try_from(inner_value).unwrap())
    }
    fn TokenFielddrk47(&self) -> TokenField_drk47 {
        let inner_value = self.read_u8::<true>(0, 4, 4).unwrap();
        TokenField_drk47(u8::try_from(inner_value).unwrap())
    }
    fn TokenFielddrk03(&self) -> TokenField_drk03 {
        let inner_value = self.read_u8::<true>(0, 0, 4).unwrap();
        TokenField_drk03(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldd7(&self) -> TokenField_d7 {
        let inner_value = self.read_u8::<true>(0, 7, 1).unwrap();
        TokenField_d7(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldd57(&self) -> TokenField_d57 {
        let inner_value = self.read_u8::<true>(0, 5, 3).unwrap();
        TokenField_d57(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldd47(&self) -> TokenField_d47 {
        let inner_value = self.read_u8::<true>(0, 4, 4).unwrap();
        TokenField_d47(u8::try_from(inner_value).unwrap())
    }
    fn TokenFields3(&self) -> TokenField_s3 {
        let inner_value = self.read_u8::<true>(0, 3, 1).unwrap();
        TokenField_s3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFields23(&self) -> TokenField_s23 {
        let inner_value = self.read_u8::<true>(0, 2, 2).unwrap();
        TokenField_s23(u8::try_from(inner_value).unwrap())
    }
    fn TokenFields13(&self) -> TokenField_s13 {
        let inner_value = self.read_u8::<true>(0, 1, 3).unwrap();
        TokenField_s13(u8::try_from(inner_value).unwrap())
    }
    fn TokenFields03(&self) -> TokenField_s03 {
        let inner_value = self.read_u8::<true>(0, 0, 4).unwrap();
        TokenField_s03(u8::try_from(inner_value).unwrap())
    }
    fn TokenFields1(&self) -> TokenField_s1 {
        let inner_value = self.read_u8::<true>(0, 1, 1).unwrap();
        TokenField_s1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFields0(&self) -> TokenField_s0 {
        let inner_value = self.read_u8::<true>(0, 0, 1).unwrap();
        TokenField_s0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldshort01(&self) -> TokenField_short01 {
        let inner_value = self.read_i8::<true>(0, 0, 2).unwrap();
        TokenField_short01(i8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbit02(&self) -> TokenField_bit02 {
        let inner_value = self.read_u8::<true>(0, 0, 3).unwrap();
        TokenField_bit02(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldrm47_(&self) -> TokenField_rm47_ {
        let inner_value = self.read_u8::<true>(0, 4, 4).unwrap();
        TokenField_rm47_(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldrm03_(&self) -> TokenField_rm03_ {
        let inner_value = self.read_u8::<true>(0, 0, 4).unwrap();
        TokenField_rm03_(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldwrj47_(&self) -> TokenField_wrj47_ {
        let inner_value = self.read_u8::<true>(0, 4, 4).unwrap();
        TokenField_wrj47_(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldwrj03_(&self) -> TokenField_wrj03_ {
        let inner_value = self.read_u8::<true>(0, 0, 4).unwrap();
        TokenField_wrj03_(u8::try_from(inner_value).unwrap())
    }
    fn TokenFielddrk47_(&self) -> TokenField_drk47_ {
        let inner_value = self.read_u8::<true>(0, 4, 4).unwrap();
        TokenField_drk47_(u8::try_from(inner_value).unwrap())
    }
    fn TokenFielddrk03_(&self) -> TokenField_drk03_ {
        let inner_value = self.read_u8::<true>(0, 0, 4).unwrap();
        TokenField_drk03_(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldd7_(&self) -> TokenField_d7_ {
        let inner_value = self.read_u8::<true>(0, 7, 1).unwrap();
        TokenField_d7_(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldd57_(&self) -> TokenField_d57_ {
        let inner_value = self.read_u8::<true>(0, 5, 3).unwrap();
        TokenField_d57_(u8::try_from(inner_value).unwrap())
    }
    fn TokenFields3_(&self) -> TokenField_s3_ {
        let inner_value = self.read_u8::<true>(0, 3, 1).unwrap();
        TokenField_s3_(u8::try_from(inner_value).unwrap())
    }
    fn TokenFields13_(&self) -> TokenField_s13_ {
        let inner_value = self.read_u8::<true>(0, 1, 3).unwrap();
        TokenField_s13_(u8::try_from(inner_value).unwrap())
    }
    fn TokenFields03_(&self) -> TokenField_s03_ {
        let inner_value = self.read_u8::<true>(0, 0, 4).unwrap();
        TokenField_s03_(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldaddr24(&self) -> TokenField_addr24 {
        let inner_value = self.read_u32::<true>(0, 0, 24).unwrap();
        TokenField_addr24(u32::try_from(inner_value).unwrap())
    }
    fn TokenFielddata24(&self) -> TokenField_data24 {
        let inner_value = self.read_u32::<true>(0, 0, 24).unwrap();
        TokenField_data24(u32::try_from(inner_value).unwrap())
    }
}
#[derive(Clone, Copy, Debug)]
pub enum Register {
    R0,
    R1,
    R2,
    R3,
    R4,
    R5,
    R6,
    R7,
    jumpTableGuard1,
    jumpTableGuard2,
    R8,
    R9,
    B,
    ACC,
    R12,
    R13,
    R14,
    R15,
    R16,
    R17,
    R18,
    R19,
    R20,
    R21,
    R22,
    R23,
    R24,
    R25,
    R26,
    R27,
    R28,
    R29,
    R30,
    R31,
    WR0,
    WR2,
    WR4,
    WR6,
    WR8,
    AB,
    WR12,
    WR14,
    WR16,
    WR18,
    WR20,
    WR22,
    WR24,
    WR26,
    WR28,
    WR30,
    DR0,
    DR4,
    DR8,
    DR12,
    DR16,
    DR20,
    DR24,
    DR28,
    R56,
    DPXL,
    DPH,
    DPL,
    R60,
    R61,
    SPH,
    DPTR,
    DPX,
    SPX,
    SP,
    PC,
    PSW,
    contextReg,
}
impl core::fmt::Display for Register {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::R0 => write!(f, "R0"),
            Self::R1 => write!(f, "R1"),
            Self::R2 => write!(f, "R2"),
            Self::R3 => write!(f, "R3"),
            Self::R4 => write!(f, "R4"),
            Self::R5 => write!(f, "R5"),
            Self::R6 => write!(f, "R6"),
            Self::R7 => write!(f, "R7"),
            Self::jumpTableGuard1 => write!(f, "jumpTableGuard1"),
            Self::jumpTableGuard2 => write!(f, "jumpTableGuard2"),
            Self::R8 => write!(f, "R8"),
            Self::R9 => write!(f, "R9"),
            Self::B => write!(f, "B"),
            Self::ACC => write!(f, "ACC"),
            Self::R12 => write!(f, "R12"),
            Self::R13 => write!(f, "R13"),
            Self::R14 => write!(f, "R14"),
            Self::R15 => write!(f, "R15"),
            Self::R16 => write!(f, "R16"),
            Self::R17 => write!(f, "R17"),
            Self::R18 => write!(f, "R18"),
            Self::R19 => write!(f, "R19"),
            Self::R20 => write!(f, "R20"),
            Self::R21 => write!(f, "R21"),
            Self::R22 => write!(f, "R22"),
            Self::R23 => write!(f, "R23"),
            Self::R24 => write!(f, "R24"),
            Self::R25 => write!(f, "R25"),
            Self::R26 => write!(f, "R26"),
            Self::R27 => write!(f, "R27"),
            Self::R28 => write!(f, "R28"),
            Self::R29 => write!(f, "R29"),
            Self::R30 => write!(f, "R30"),
            Self::R31 => write!(f, "R31"),
            Self::WR0 => write!(f, "WR0"),
            Self::WR2 => write!(f, "WR2"),
            Self::WR4 => write!(f, "WR4"),
            Self::WR6 => write!(f, "WR6"),
            Self::WR8 => write!(f, "WR8"),
            Self::AB => write!(f, "AB"),
            Self::WR12 => write!(f, "WR12"),
            Self::WR14 => write!(f, "WR14"),
            Self::WR16 => write!(f, "WR16"),
            Self::WR18 => write!(f, "WR18"),
            Self::WR20 => write!(f, "WR20"),
            Self::WR22 => write!(f, "WR22"),
            Self::WR24 => write!(f, "WR24"),
            Self::WR26 => write!(f, "WR26"),
            Self::WR28 => write!(f, "WR28"),
            Self::WR30 => write!(f, "WR30"),
            Self::DR0 => write!(f, "DR0"),
            Self::DR4 => write!(f, "DR4"),
            Self::DR8 => write!(f, "DR8"),
            Self::DR12 => write!(f, "DR12"),
            Self::DR16 => write!(f, "DR16"),
            Self::DR20 => write!(f, "DR20"),
            Self::DR24 => write!(f, "DR24"),
            Self::DR28 => write!(f, "DR28"),
            Self::R56 => write!(f, "R56"),
            Self::DPXL => write!(f, "DPXL"),
            Self::DPH => write!(f, "DPH"),
            Self::DPL => write!(f, "DPL"),
            Self::R60 => write!(f, "R60"),
            Self::R61 => write!(f, "R61"),
            Self::SPH => write!(f, "SPH"),
            Self::DPTR => write!(f, "DPTR"),
            Self::DPX => write!(f, "DPX"),
            Self::SPX => write!(f, "SPX"),
            Self::SP => write!(f, "SP"),
            Self::PC => write!(f, "PC"),
            Self::PSW => write!(f, "PSW"),
            Self::contextReg => write!(f, "contextReg"),
        }
    }
}
#[derive(Clone, Copy, Debug)]
pub enum DisplayElement {
    Literal(&'static str),
    Register(Register),
    Number(bool, i128),
}
impl core::fmt::Display for DisplayElement {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Literal(lit) => lit.fmt(f),
            Self::Register(reg) => reg.fmt(f),
            Self::Number(hex, value) => match (*hex, value.is_negative()) {
                (true, true) => write!(f, "-0x{:x}", value.abs()),
                (true, false) => write!(f, "0x{:x}", value),
                (false, _) => value.fmt(f),
            },
        }
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:561:1, end:561:2))"]
#[derive(Clone, Debug)]
struct PUSH_instructionVar0 {
    Data: TableData,
}
impl PUSH_instructionVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("PUSH"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldd47().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFields03().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:564:1, end:564:2))"]
#[derive(Clone, Debug)]
struct PUSH_instructionVar1 {
    Data16: TableData16,
}
impl PUSH_instructionVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("PUSH"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Data16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldd47().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFields03().disassembly() != 6i128 {
            return None;
        }
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data16 = if let Some((len, table)) = TableData16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:252:1, end:252:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar2 {
    xBitByteAddr: TablexBitByteAddr,
    xBitAddr: TablexBitAddr,
}
impl ANL_instructionVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("ANL"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("CY,"),
        ];
        display.extend_from_slice(&extend);
        self.xBitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldd47().disassembly() != 8i128 {
                return None;
            }
            if token_parser.TokenFields3().disassembly() != 0i128 {
                return None;
            }
            let bit02 = token_parser.TokenFieldbit02();
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 0u64 as u32;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(
                    tokens,
                    &mut context_instance,
                    inst_start,
                ) {
                block_1_len = block_1_len.max(len as u32);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr = if let Some((len, table)) = TablexBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitByteAddr,
                xBitAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:255:1, end:255:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar3 {
    xBitByteAddr: TablexBitByteAddr,
    xBitAddr2: TablexBitAddr2,
}
impl ANL_instructionVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("ANL"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("CY,"),
        ];
        display.extend_from_slice(&extend);
        self.xBitAddr2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldd47().disassembly() != 15i128 {
                return None;
            }
            if token_parser.TokenFields3().disassembly() != 0i128 {
                return None;
            }
            let bit02 = token_parser.TokenFieldbit02();
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 0u64 as u32;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(
                    tokens,
                    &mut context_instance,
                    inst_start,
                ) {
                block_1_len = block_1_len.max(len as u32);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr2 = if let Some((len, table)) = TablexBitAddr2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitByteAddr,
                xBitAddr2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:258:1, end:258:2))"]
#[derive(Clone, Debug)]
struct CLR_instructionVar4 {
    xBitByteAddr: TablexBitByteAddr,
    xBitAddr: TablexBitAddr,
}
impl CLR_instructionVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CLR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.xBitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldd47().disassembly() != 12i128 {
                return None;
            }
            if token_parser.TokenFields3().disassembly() != 0i128 {
                return None;
            }
            let bit02 = token_parser.TokenFieldbit02();
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 0u64 as u32;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(
                    tokens,
                    &mut context_instance,
                    inst_start,
                ) {
                block_1_len = block_1_len.max(len as u32);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr = if let Some((len, table)) = TablexBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitByteAddr,
                xBitAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:301:1, end:301:2))"]
#[derive(Clone, Debug)]
struct CPL_instructionVar5 {
    xBitByteAddr: TablexBitByteAddr,
    xBitAddr: TablexBitAddr,
}
impl CPL_instructionVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.xBitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldd47().disassembly() != 11i128 {
                return None;
            }
            if token_parser.TokenFields3().disassembly() != 0i128 {
                return None;
            }
            let bit02 = token_parser.TokenFieldbit02();
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 0u64 as u32;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(
                    tokens,
                    &mut context_instance,
                    inst_start,
                ) {
                block_1_len = block_1_len.max(len as u32);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr = if let Some((len, table)) = TablexBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitByteAddr,
                xBitAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:344:1, end:344:2))"]
#[derive(Clone, Debug)]
struct JB_instructionVar6 {
    xBitByteAddr: TablexBitByteAddr,
    xBitAddr: TablexBitAddr,
    Rel8: TableRel8,
}
impl JB_instructionVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JB"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.xBitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c52 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldd47().disassembly() != 2i128 {
                return None;
            }
            if token_parser.TokenFields3().disassembly() != 0i128 {
                return None;
            }
            let bit02 = token_parser.TokenFieldbit02();
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 0u64 as u32;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(
                    tokens,
                    &mut context_instance,
                    inst_start,
                ) {
                block_1_len = block_1_len.max(len as u32);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c52(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr = if let Some((len, table)) = TablexBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitByteAddr,
                xBitAddr,
                Rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:347:1, end:347:2))"]
#[derive(Clone, Debug)]
struct JBC_instructionVar7 {
    xBitByteAddr: TablexBitByteAddr,
    xBitAddr: TablexBitAddr,
    Rel8: TableRel8,
}
impl JBC_instructionVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JBC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.xBitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldd47().disassembly() != 1i128 {
                return None;
            }
            if token_parser.TokenFields3().disassembly() != 0i128 {
                return None;
            }
            let bit02 = token_parser.TokenFieldbit02();
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 0u64 as u32;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(
                    tokens,
                    &mut context_instance,
                    inst_start,
                ) {
                block_1_len = block_1_len.max(len as u32);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr = if let Some((len, table)) = TablexBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitByteAddr,
                xBitAddr,
                Rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:359:1, end:359:2))"]
#[derive(Clone, Debug)]
struct JNB_instructionVar8 {
    xBitByteAddr: TablexBitByteAddr,
    xBitAddr: TablexBitAddr,
    Rel8: TableRel8,
}
impl JNB_instructionVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JNB"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.xBitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldd47().disassembly() != 3i128 {
                return None;
            }
            if token_parser.TokenFields3().disassembly() != 0i128 {
                return None;
            }
            let bit02 = token_parser.TokenFieldbit02();
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 0u64 as u32;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(
                    tokens,
                    &mut context_instance,
                    inst_start,
                ) {
                block_1_len = block_1_len.max(len as u32);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr = if let Some((len, table)) = TablexBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitByteAddr,
                xBitAddr,
                Rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:493:1, end:493:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar9 {
    xBitByteAddr: TablexBitByteAddr,
    xBitAddr: TablexBitAddr,
}
impl MOV_instructionVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.xBitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",CY")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldd47().disassembly() != 9i128 {
                return None;
            }
            if token_parser.TokenFields3().disassembly() != 0i128 {
                return None;
            }
            let bit02 = token_parser.TokenFieldbit02();
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 0u64 as u32;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(
                    tokens,
                    &mut context_instance,
                    inst_start,
                ) {
                block_1_len = block_1_len.max(len as u32);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr = if let Some((len, table)) = TablexBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitByteAddr,
                xBitAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:496:1, end:496:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar10 {
    xBitByteAddr: TablexBitByteAddr,
    xBitAddr: TablexBitAddr,
}
impl MOV_instructionVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("CY,"),
        ];
        display.extend_from_slice(&extend);
        self.xBitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldd47().disassembly() != 10i128 {
                return None;
            }
            if token_parser.TokenFields3().disassembly() != 0i128 {
                return None;
            }
            let bit02 = token_parser.TokenFieldbit02();
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 0u64 as u32;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(
                    tokens,
                    &mut context_instance,
                    inst_start,
                ) {
                block_1_len = block_1_len.max(len as u32);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr = if let Some((len, table)) = TablexBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitByteAddr,
                xBitAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:545:1, end:545:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar11 {
    xBitByteAddr: TablexBitByteAddr,
    xBitAddr: TablexBitAddr,
}
impl ORL_instructionVar11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("ORL"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("CY,"),
        ];
        display.extend_from_slice(&extend);
        self.xBitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldd47().disassembly() != 7i128 {
                return None;
            }
            if token_parser.TokenFields3().disassembly() != 0i128 {
                return None;
            }
            let bit02 = token_parser.TokenFieldbit02();
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 0u64 as u32;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(
                    tokens,
                    &mut context_instance,
                    inst_start,
                ) {
                block_1_len = block_1_len.max(len as u32);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr = if let Some((len, table)) = TablexBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitByteAddr,
                xBitAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:548:1, end:548:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar12 {
    xBitByteAddr: TablexBitByteAddr,
    xBitAddr2: TablexBitAddr2,
}
impl ORL_instructionVar12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("ORL"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("CY,"),
        ];
        display.extend_from_slice(&extend);
        self.xBitAddr2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldd47().disassembly() != 14i128 {
                return None;
            }
            if token_parser.TokenFields3().disassembly() != 0i128 {
                return None;
            }
            let bit02 = token_parser.TokenFieldbit02();
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 0u64 as u32;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(
                    tokens,
                    &mut context_instance,
                    inst_start,
                ) {
                block_1_len = block_1_len.max(len as u32);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr2 = if let Some((len, table)) = TablexBitAddr2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitByteAddr,
                xBitAddr2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:576:1, end:576:2))"]
#[derive(Clone, Debug)]
struct SETB_instructionVar13 {
    xBitByteAddr: TablexBitByteAddr,
    xBitAddr: TablexBitAddr,
}
impl SETB_instructionVar13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SETB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.xBitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(".")];
        display.extend_from_slice(&extend);
        self.xBitByteAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c68 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldd47().disassembly() != 13i128 {
                return None;
            }
            if token_parser.TokenFields3().disassembly() != 0i128 {
                return None;
            }
            let bit02 = token_parser.TokenFieldbit02();
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 0u64 as u32;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(
                    tokens,
                    &mut context_instance,
                    inst_start,
                ) {
                block_1_len = block_1_len.max(len as u32);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c68(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr = if let Some((len, table)) = TablexBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitByteAddr,
                xBitAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:679:1, end:679:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar14 {
    CY: TableCY,
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
}
impl ANL_instructionVar14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ANL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.BitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 2i128 {
            return None;
        }
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbitaddr57().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldsfrbit3().disassembly() != 0i128 {
            return None;
        }
        let BitAddr = if let Some((len, table)) = TableBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitAddr,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:680:1, end:680:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar15 {
    CY: TableCY,
    BitAddr2: TableBitAddr2,
    BitByteAddr: TableBitByteAddr,
}
impl ANL_instructionVar15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ANL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.BitAddr2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 0i128 {
            return None;
        }
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbitaddr57().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldsfrbit3().disassembly() != 0i128 {
            return None;
        }
        let BitAddr2 = if let Some((len, table)) = TableBitAddr2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitAddr2,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:700:1, end:700:2))"]
#[derive(Clone, Debug)]
struct CLR_instructionVar16 {
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
}
impl CLR_instructionVar16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CLR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbitaddr57().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldsfrbit3().disassembly() != 0i128 {
            return None;
        }
        let BitAddr = if let Some((len, table)) = TableBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitAddr,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:713:1, end:713:2))"]
#[derive(Clone, Debug)]
struct CPL_instructionVar17 {
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
}
impl CPL_instructionVar17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbitaddr57().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldsfrbit3().disassembly() != 0i128 {
            return None;
        }
        let BitAddr = if let Some((len, table)) = TableBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitAddr,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:749:1, end:749:2))"]
#[derive(Clone, Debug)]
struct JB_instructionVar18 {
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
    Rel8: TableRel8,
}
impl JB_instructionVar18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JB"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbitaddr57().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldsfrbit3().disassembly() != 0i128 {
            return None;
        }
        let BitAddr = if let Some((len, table)) = TableBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitAddr,
                BitByteAddr,
                Rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:750:1, end:750:2))"]
#[derive(Clone, Debug)]
struct JBC_instructionVar19 {
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
    Rel8: TableRel8,
}
impl JBC_instructionVar19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JBC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbitaddr57().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldsfrbit3().disassembly() != 0i128 {
            return None;
        }
        let BitAddr = if let Some((len, table)) = TableBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitAddr,
                BitByteAddr,
                Rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:764:1, end:764:2))"]
#[derive(Clone, Debug)]
struct JNB_instructionVar20 {
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
    Rel8: TableRel8,
}
impl JNB_instructionVar20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JNB"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbitaddr57().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldsfrbit3().disassembly() != 0i128 {
            return None;
        }
        let BitAddr = if let Some((len, table)) = TableBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitAddr,
                BitByteAddr,
                Rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:809:1, end:809:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar21 {
    CY: TableCY,
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
}
impl MOV_instructionVar21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.BitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 2i128 {
            return None;
        }
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbitaddr57().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldsfrbit3().disassembly() != 0i128 {
            return None;
        }
        let BitAddr = if let Some((len, table)) = TableBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitAddr,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:810:1, end:810:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar22 {
    CY: TableCY,
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
}
impl MOV_instructionVar22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.CY.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 2i128 {
            return None;
        }
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbitaddr57().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldsfrbit3().disassembly() != 0i128 {
            return None;
        }
        let BitAddr = if let Some((len, table)) = TableBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitAddr,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:842:1, end:842:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar23 {
    CY: TableCY,
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
}
impl ORL_instructionVar23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ORL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.BitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 2i128 {
            return None;
        }
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbitaddr57().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldsfrbit3().disassembly() != 0i128 {
            return None;
        }
        let BitAddr = if let Some((len, table)) = TableBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitAddr,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:843:1, end:843:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar24 {
    CY: TableCY,
    BitAddr2: TableBitAddr2,
    BitByteAddr: TableBitByteAddr,
}
impl ORL_instructionVar24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ORL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.BitAddr2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 0i128 {
            return None;
        }
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbitaddr57().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldsfrbit3().disassembly() != 0i128 {
            return None;
        }
        let BitAddr2 = if let Some((len, table)) = TableBitAddr2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitAddr2,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:886:1, end:886:2))"]
#[derive(Clone, Debug)]
struct SETB_instructionVar25 {
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
}
impl SETB_instructionVar25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SETB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.BitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbitaddr57().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldsfrbit3().disassembly() != 0i128 {
            return None;
        }
        let BitAddr = if let Some((len, table)) = TableBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitAddr,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:216:1, end:216:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar26 {
    rm47_: TokenField_rm47_,
    AtWRjb: TableAtWRjb,
}
impl ADD_instructionVar26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ADD"),
            DisplayElement::Literal(" "),
            self.rm47_.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtWRjb.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 9i128 {
            return None;
        }
        let AtWRjb = if let Some((len, table)) = TableAtWRjb::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03_().disassembly() != 0i128 {
            return None;
        }
        let rm47_ = token_parser.TokenFieldrm47_();
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:219:1, end:219:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar27 {
    rm47_: TokenField_rm47_,
    AtDRkb: TableAtDRkb,
}
impl ADD_instructionVar27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ADD"),
            DisplayElement::Literal(" "),
            self.rm47_.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtDRkb.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 11i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkb = if let Some((len, table)) = TableAtDRkb::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03_().disassembly() != 0i128 {
            return None;
        }
        let rm47_ = token_parser.TokenFieldrm47_();
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:246:1, end:246:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar28 {
    rm47_: TokenField_rm47_,
    AtWRjb: TableAtWRjb,
}
impl ANL_instructionVar28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ANL"),
            DisplayElement::Literal(" "),
            self.rm47_.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtWRjb.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 9i128 {
            return None;
        }
        let AtWRjb = if let Some((len, table)) = TableAtWRjb::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03_().disassembly() != 0i128 {
            return None;
        }
        let rm47_ = token_parser.TokenFieldrm47_();
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:249:1, end:249:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar29 {
    rm47_: TokenField_rm47_,
    AtDRkb: TableAtDRkb,
}
impl ANL_instructionVar29 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ANL"),
            DisplayElement::Literal(" "),
            self.rm47_.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtDRkb.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 11i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkb = if let Some((len, table)) = TableAtDRkb::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03_().disassembly() != 0i128 {
            return None;
        }
        let rm47_ = token_parser.TokenFieldrm47_();
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:295:1, end:295:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar30 {
    rm47_: TokenField_rm47_,
    AtWRjb: TableAtWRjb,
}
impl CMP_instructionVar30 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("CMP"),
            DisplayElement::Literal(" "),
            self.rm47_.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtWRjb.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 9i128 {
            return None;
        }
        let AtWRjb = if let Some((len, table)) = TableAtWRjb::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03_().disassembly() != 0i128 {
            return None;
        }
        let rm47_ = token_parser.TokenFieldrm47_();
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:298:1, end:298:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar31 {
    rm47_: TokenField_rm47_,
    AtDRkb: TableAtDRkb,
}
impl CMP_instructionVar31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("CMP"),
            DisplayElement::Literal(" "),
            self.rm47_.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtDRkb.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 11i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkb = if let Some((len, table)) = TableAtDRkb::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03_().disassembly() != 0i128 {
            return None;
        }
        let rm47_ = token_parser.TokenFieldrm47_();
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:422:1, end:422:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar32 {
    rm47_: TokenField_rm47_,
    AtWRjb: TableAtWRjb,
}
impl MOV_instructionVar32 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.rm47_.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtWRjb.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 9i128 {
            return None;
        }
        let AtWRjb = if let Some((len, table)) = TableAtWRjb::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03_().disassembly() != 0i128 {
            return None;
        }
        let rm47_ = token_parser.TokenFieldrm47_();
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:425:1, end:425:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar33 {
    rm47_: TokenField_rm47_,
    AtDRkb: TableAtDRkb,
}
impl MOV_instructionVar33 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.rm47_.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtDRkb.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 11i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkb = if let Some((len, table)) = TableAtDRkb::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03_().disassembly() != 0i128 {
            return None;
        }
        let rm47_ = token_parser.TokenFieldrm47_();
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:428:1, end:428:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar34 {
    wrj47_: TokenField_wrj47_,
    AtWRjw: TableAtWRjw,
}
impl MOV_instructionVar34 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.wrj47_.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtWRjw.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 11i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 8i128 {
            return None;
        }
        let AtWRjw = if let Some((len, table)) = TableAtWRjw::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03_().disassembly() != 0i128 {
            return None;
        }
        let wrj47_ = token_parser.TokenFieldwrj47_();
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjw, wrj47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:431:1, end:431:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar35 {
    wrj47_: TokenField_wrj47_,
    AtDRkw: TableAtDRkw,
}
impl MOV_instructionVar35 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.wrj47_.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtDRkw.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 11i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkw = if let Some((len, table)) = TableAtDRkw::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03_().disassembly() != 0i128 {
            return None;
        }
        let wrj47_ = token_parser.TokenFieldwrj47_();
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkw, wrj47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:438:1, end:438:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar36 {
    wrj47: TokenField_wrj47,
    Direct8w: TableDirect8w,
}
impl MOV_instructionVar36 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct8w.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.wrj47.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 5i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbank().disassembly() != 0i128 {
            return None;
        }
        let Direct8w = if let Some((len, table)) = TableDirect8w::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct8w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:439:1, end:439:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar37 {
    wrj47: TokenField_wrj47,
    Direct: TableDirect,
}
impl MOV_instructionVar37 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.wrj47.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 5i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbank().disassembly() != 1i128 {
            return None;
        }
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:444:1, end:444:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar38 {
    drk47: TokenField_drk47,
    Direct8w: TableDirect8w,
}
impl MOV_instructionVar38 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct8w.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.drk47.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 13i128 {
            return None;
        }
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_parser.TokenFielddrk47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbank().disassembly() != 0i128 {
            return None;
        }
        let Direct8w = if let Some((len, table)) = TableDirect8w::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct8w, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:445:1, end:445:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar39 {
    drk47: TokenField_drk47,
    Direct: TableDirect,
}
impl MOV_instructionVar39 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.drk47.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 13i128 {
            return None;
        }
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_parser.TokenFielddrk47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbank().disassembly() != 1i128 {
            return None;
        }
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:457:1, end:457:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar40 {
    rm47_: TokenField_rm47_,
    AtWRjb: TableAtWRjb,
}
impl MOV_instructionVar40 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.AtWRjb.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.rm47_.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 9i128 {
            return None;
        }
        let AtWRjb = if let Some((len, table)) = TableAtWRjb::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03_().disassembly() != 0i128 {
            return None;
        }
        let rm47_ = token_parser.TokenFieldrm47_();
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:460:1, end:460:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar41 {
    rm47_: TokenField_rm47_,
    AtDRkb: TableAtDRkb,
}
impl MOV_instructionVar41 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.AtDRkb.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.rm47_.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 11i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkb = if let Some((len, table)) = TableAtDRkb::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03_().disassembly() != 0i128 {
            return None;
        }
        let rm47_ = token_parser.TokenFieldrm47_();
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:463:1, end:463:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar42 {
    wrj47_: TokenField_wrj47_,
    AtWRjw: TableAtWRjw,
}
impl MOV_instructionVar42 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.AtWRjw.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.wrj47_.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 11i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 8i128 {
            return None;
        }
        let AtWRjw = if let Some((len, table)) = TableAtWRjw::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03_().disassembly() != 0i128 {
            return None;
        }
        let wrj47_ = token_parser.TokenFieldwrj47_();
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjw, wrj47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:466:1, end:466:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar43 {
    wrj47_: TokenField_wrj47_,
    AtDRkw: TableAtDRkw,
}
impl MOV_instructionVar43 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.AtDRkw.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.wrj47_.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 11i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkw = if let Some((len, table)) = TableAtDRkw::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03_().disassembly() != 0i128 {
            return None;
        }
        let wrj47_ = token_parser.TokenFieldwrj47_();
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkw, wrj47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:539:1, end:539:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar44 {
    rm47_: TokenField_rm47_,
    AtWRjb: TableAtWRjb,
}
impl ORL_instructionVar44 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ORL"),
            DisplayElement::Literal(" "),
            self.rm47_.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtWRjb.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 9i128 {
            return None;
        }
        let AtWRjb = if let Some((len, table)) = TableAtWRjb::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03_().disassembly() != 0i128 {
            return None;
        }
        let rm47_ = token_parser.TokenFieldrm47_();
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:542:1, end:542:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar45 {
    rm47_: TokenField_rm47_,
    AtDRkb: TableAtDRkb,
}
impl ORL_instructionVar45 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ORL"),
            DisplayElement::Literal(" "),
            self.rm47_.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtDRkb.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 11i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkb = if let Some((len, table)) = TableAtDRkb::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03_().disassembly() != 0i128 {
            return None;
        }
        let rm47_ = token_parser.TokenFieldrm47_();
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:628:1, end:628:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar46 {
    rm47_: TokenField_rm47_,
    AtWRjb: TableAtWRjb,
}
impl SUB_instructionVar46 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("SUB"),
            DisplayElement::Literal(" "),
            self.rm47_.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtWRjb.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 9i128 {
            return None;
        }
        let AtWRjb = if let Some((len, table)) = TableAtWRjb::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03_().disassembly() != 0i128 {
            return None;
        }
        let rm47_ = token_parser.TokenFieldrm47_();
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:631:1, end:631:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar47 {
    rm47_: TokenField_rm47_,
    AtDRkb: TableAtDRkb,
}
impl SUB_instructionVar47 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("SUB"),
            DisplayElement::Literal(" "),
            self.rm47_.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtDRkb.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 11i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkb = if let Some((len, table)) = TableAtDRkb::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03_().disassembly() != 0i128 {
            return None;
        }
        let rm47_ = token_parser.TokenFieldrm47_();
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:659:1, end:659:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar48 {
    rm47_: TokenField_rm47_,
    AtWRjb: TableAtWRjb,
}
impl XRL_instructionVar48 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("XRL"),
            DisplayElement::Literal(" "),
            self.rm47_.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtWRjb.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 9i128 {
            return None;
        }
        let AtWRjb = if let Some((len, table)) = TableAtWRjb::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03_().disassembly() != 0i128 {
            return None;
        }
        let rm47_ = token_parser.TokenFieldrm47_();
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:662:1, end:662:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar49 {
    rm47_: TokenField_rm47_,
    AtDRkb: TableAtDRkb,
}
impl XRL_instructionVar49 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("XRL"),
            DisplayElement::Literal(" "),
            self.rm47_.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtDRkb.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 11i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkb = if let Some((len, table)) = TableAtDRkb::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03_().disassembly() != 0i128 {
            return None;
        }
        let rm47_ = token_parser.TokenFieldrm47_();
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:195:1, end:195:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar50 {
    rm47: TokenField_rm47,
    Data: TableData,
}
impl ADD_instructionVar50 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ADD"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 0i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:198:1, end:198:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar51 {
    wrj47: TokenField_wrj47,
    Data16: TableData16,
}
impl ADD_instructionVar51 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ADD"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 4i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data16 = if let Some((len, table)) = TableData16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:201:1, end:201:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar52 {
    drk47: TokenField_drk47,
    Data16x0: TableData16x0,
}
impl ADD_instructionVar52 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ADD"),
            DisplayElement::Literal(" "),
            self.drk47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16x0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 8i128 {
            return None;
        }
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_parser.TokenFielddrk47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data16x0 = if let Some((len, table)) = TableData16x0::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16x0, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:204:1, end:204:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar53 {
    rm47: TokenField_rm47,
    Direct: TableDirect,
}
impl ADD_instructionVar53 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ADD"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 1i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:207:1, end:207:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar54 {
    wrj47: TokenField_wrj47,
    Direct8w: TableDirect8w,
}
impl ADD_instructionVar54 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ADD"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct8w.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 5i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct8w = if let Some((len, table)) = TableDirect8w::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct8w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:210:1, end:210:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar55 {
    rm47: TokenField_rm47,
    Direct16b: TableDirect16b,
}
impl ADD_instructionVar55 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ADD"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16b.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 3i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct16b = if let Some((len, table)) = TableDirect16b::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16b, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:213:1, end:213:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar56 {
    wrj47: TokenField_wrj47,
    Direct16w: TableDirect16w,
}
impl ADD_instructionVar56 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ADD"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16w.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 7i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct16w = if let Some((len, table)) = TableDirect16w::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:228:1, end:228:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar57 {
    rm47: TokenField_rm47,
    Data: TableData,
}
impl ADD_instructionVar57 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ADD"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 0i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:231:1, end:231:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar58 {
    wrj47: TokenField_wrj47,
    Data16: TableData16,
}
impl ANL_instructionVar58 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ANL"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 4i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data16 = if let Some((len, table)) = TableData16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:234:1, end:234:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar59 {
    rm47: TokenField_rm47,
    Direct: TableDirect,
}
impl ANL_instructionVar59 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ANL"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 1i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:237:1, end:237:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar60 {
    wrj47: TokenField_wrj47,
    Direct8w: TableDirect8w,
}
impl ANL_instructionVar60 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ANL"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct8w.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 5i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct8w = if let Some((len, table)) = TableDirect8w::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct8w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:240:1, end:240:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar61 {
    rm47: TokenField_rm47,
    Direct16b: TableDirect16b,
}
impl ANL_instructionVar61 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ANL"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16b.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 3i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct16b = if let Some((len, table)) = TableDirect16b::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16b, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:243:1, end:243:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar62 {
    wrj47: TokenField_wrj47,
    Direct16w: TableDirect16w,
}
impl ANL_instructionVar62 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ANL"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16w.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 7i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct16w = if let Some((len, table)) = TableDirect16w::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:271:1, end:271:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar63 {
    rm47: TokenField_rm47,
    Data: TableData,
}
impl CMP_instructionVar63 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("CMP"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 0i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:274:1, end:274:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar64 {
    wrj47: TokenField_wrj47,
    Data16: TableData16,
}
impl CMP_instructionVar64 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("CMP"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 4i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data16 = if let Some((len, table)) = TableData16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:277:1, end:277:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar65 {
    drk47: TokenField_drk47,
    Data16x0: TableData16x0,
}
impl CMP_instructionVar65 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("CMP"),
            DisplayElement::Literal(" "),
            self.drk47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16x0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 8i128 {
            return None;
        }
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_parser.TokenFielddrk47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data16x0 = if let Some((len, table)) = TableData16x0::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16x0, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:280:1, end:280:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar66 {
    drk47: TokenField_drk47,
    Data16x1: TableData16x1,
}
impl CMP_instructionVar66 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("CMP"),
            DisplayElement::Literal(" "),
            self.drk47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16x1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 12i128 {
            return None;
        }
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_parser.TokenFielddrk47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data16x1 = if let Some((len, table)) = TableData16x1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16x1, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:283:1, end:283:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar67 {
    rm47: TokenField_rm47,
    Direct: TableDirect,
}
impl CMP_instructionVar67 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("CMP"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 1i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:286:1, end:286:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar68 {
    wrj47: TokenField_wrj47,
    Direct8w: TableDirect8w,
}
impl CMP_instructionVar68 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("CMP"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct8w.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 5i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct8w = if let Some((len, table)) = TableDirect8w::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct8w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:289:1, end:289:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar69 {
    rm47: TokenField_rm47,
    Direct16b: TableDirect16b,
}
impl CMP_instructionVar69 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("CMP"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16b.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 3i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct16b = if let Some((len, table)) = TableDirect16b::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16b, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:292:1, end:292:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar70 {
    wrj47: TokenField_wrj47,
    Direct16w: TableDirect16w,
}
impl CMP_instructionVar70 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("CMP"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16w.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 7i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct16w = if let Some((len, table)) = TableDirect16w::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:323:1, end:323:2))"]
#[derive(Clone, Debug)]
struct ECALL_instructionVar71 {
    AtDRkt: TableAtDRkt,
}
impl ECALL_instructionVar71 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ECALL"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.AtDRkt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 8i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkt = if let Some((len, table)) = TableAtDRkt::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:329:1, end:329:2))"]
#[derive(Clone, Debug)]
struct EJMP_instructionVar72 {
    AtDRkt: TableAtDRkt,
}
impl EJMP_instructionVar72 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EJMP"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.AtDRkt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 8i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkt = if let Some((len, table)) = TableAtDRkt::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:377:1, end:377:2))"]
#[derive(Clone, Debug)]
struct LCALL_instructionVar73 {
    AtWRjw: TableAtWRjw,
}
impl LCALL_instructionVar73 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LCALL"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.AtWRjw.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 4i128 {
            return None;
        }
        let AtWRjw = if let Some((len, table)) = TableAtWRjw::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:380:1, end:380:2))"]
#[derive(Clone, Debug)]
struct LJMP_instructionVar74 {
    AtWRjw: TableAtWRjw,
}
impl LJMP_instructionVar74 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LJMP"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.AtWRjw.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 4i128 {
            return None;
        }
        let AtWRjw = if let Some((len, table)) = TableAtWRjw::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:392:1, end:392:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar75 {
    rm47: TokenField_rm47,
    Data: TableData,
}
impl MOV_instructionVar75 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 0i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:395:1, end:395:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar76 {
    wrj47: TokenField_wrj47,
    Data16: TableData16,
}
impl MOV_instructionVar76 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 4i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data16 = if let Some((len, table)) = TableData16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:398:1, end:398:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar77 {
    drk47: TokenField_drk47,
    Data16x0: TableData16x0,
}
impl MOV_instructionVar77 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.drk47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16x0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 8i128 {
            return None;
        }
        let drk47 = token_parser.TokenFielddrk47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data16x0 = if let Some((len, table)) = TableData16x0::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16x0, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:401:1, end:401:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar78 {
    drk47: TokenField_drk47,
    Data16x1: TableData16x1,
}
impl MOV_instructionVar78 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.drk47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16x1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 12i128 {
            return None;
        }
        let drk47 = token_parser.TokenFielddrk47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data16x1 = if let Some((len, table)) = TableData16x1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16x1, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:404:1, end:404:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar79 {
    rm47: TokenField_rm47,
    Direct: TableDirect,
}
impl MOV_instructionVar79 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 1i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:407:1, end:407:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar80 {
    wrj47: TokenField_wrj47,
    Direct8w: TableDirect8w,
}
impl MOV_instructionVar80 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct8w.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 5i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct8w = if let Some((len, table)) = TableDirect8w::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct8w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:410:1, end:410:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar81 {
    drk47: TokenField_drk47,
    Direct8w: TableDirect8w,
}
impl MOV_instructionVar81 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.drk47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct8w.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 13i128 {
            return None;
        }
        let drk47 = token_parser.TokenFielddrk47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct8w = if let Some((len, table)) = TableDirect8w::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct8w, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:413:1, end:413:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar82 {
    rm47: TokenField_rm47,
    Direct16b: TableDirect16b,
}
impl MOV_instructionVar82 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16b.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 3i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct16b = if let Some((len, table)) = TableDirect16b::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16b, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:416:1, end:416:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar83 {
    wrj47: TokenField_wrj47,
    Direct16w: TableDirect16w,
}
impl MOV_instructionVar83 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16w.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 7i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct16w = if let Some((len, table)) = TableDirect16w::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:419:1, end:419:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar84 {
    drk47: TokenField_drk47,
    Direct16d: TableDirect16d,
}
impl MOV_instructionVar84 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.drk47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16d.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 15i128 {
            return None;
        }
        let drk47 = token_parser.TokenFielddrk47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct16d = if let Some((len, table)) = TableDirect16d::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16d, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:434:1, end:434:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar85 {
    rm47: TokenField_rm47,
    Direct: TableDirect,
}
impl MOV_instructionVar85 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.rm47.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 1i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:448:1, end:448:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar86 {
    rm47: TokenField_rm47,
    Direct16b: TableDirect16b,
}
impl MOV_instructionVar86 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct16b.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.rm47.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 3i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct16b = if let Some((len, table)) = TableDirect16b::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16b, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:451:1, end:451:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar87 {
    wrj47: TokenField_wrj47,
    Direct16w: TableDirect16w,
}
impl MOV_instructionVar87 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct16w.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.wrj47.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 7i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct16w = if let Some((len, table)) = TableDirect16w::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:454:1, end:454:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar88 {
    drk47: TokenField_drk47,
    Direct16d: TableDirect16d,
}
impl MOV_instructionVar88 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct16d.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.drk47.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 15i128 {
            return None;
        }
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_parser.TokenFielddrk47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct16d = if let Some((len, table)) = TableDirect16d::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16d, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:500:1, end:500:2))"]
#[derive(Clone, Debug)]
struct MOVH_instructionVar89 {
    drk47: TokenField_drk47,
    Data16x0: TableData16x0,
}
impl MOVH_instructionVar89 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MOVH"),
            DisplayElement::Literal(" "),
            self.drk47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16x0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 12i128 {
            return None;
        }
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_parser.TokenFielddrk47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data16x0 = if let Some((len, table)) = TableData16x0::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16x0, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:521:1, end:521:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar90 {
    rm47: TokenField_rm47,
    Data: TableData,
}
impl ORL_instructionVar90 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ORL"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 0i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:524:1, end:524:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar91 {
    wrj47: TokenField_wrj47,
    Data16: TableData16,
}
impl ORL_instructionVar91 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ORL"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 4i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data16 = if let Some((len, table)) = TableData16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:527:1, end:527:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar92 {
    rm47: TokenField_rm47,
    Direct: TableDirect,
}
impl ORL_instructionVar92 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ORL"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 1i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:530:1, end:530:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar93 {
    wrj47: TokenField_wrj47,
    Direct8w: TableDirect8w,
}
impl ORL_instructionVar93 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ORL"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct8w.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 15i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 5i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct8w = if let Some((len, table)) = TableDirect8w::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct8w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:533:1, end:533:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar94 {
    rm47: TokenField_rm47,
    Direct16b: TableDirect16b,
}
impl ORL_instructionVar94 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ORL"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16b.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 3i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct16b = if let Some((len, table)) = TableDirect16b::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16b, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:536:1, end:536:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar95 {
    wrj47: TokenField_wrj47,
    Direct16w: TableDirect16w,
}
impl ORL_instructionVar95 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ORL"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16w.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 7i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct16w = if let Some((len, table)) = TableDirect16w::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:551:1, end:551:2))"]
#[derive(Clone, Debug)]
struct POP_instructionVar96 {
    rm47: TokenField_rm47,
}
impl POP_instructionVar96 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("POP"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 8i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:554:1, end:554:2))"]
#[derive(Clone, Debug)]
struct POP_instructionVar97 {
    wrj47: TokenField_wrj47,
}
impl POP_instructionVar97 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("POP"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 9i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:557:1, end:557:2))"]
#[derive(Clone, Debug)]
struct POP_instructionVar98 {
    drk47: TokenField_drk47,
}
impl POP_instructionVar98 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("POP"),
            DisplayElement::Literal(" "),
            self.drk47.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 11i128 {
            return None;
        }
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_parser.TokenFielddrk47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:567:1, end:567:2))"]
#[derive(Clone, Debug)]
struct PUSH_instructionVar99 {
    rm47: TokenField_rm47,
}
impl PUSH_instructionVar99 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("PUSH"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 8i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:570:1, end:570:2))"]
#[derive(Clone, Debug)]
struct PUSH_instructionVar100 {
    wrj47: TokenField_wrj47,
}
impl PUSH_instructionVar100 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("PUSH"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 9i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:573:1, end:573:2))"]
#[derive(Clone, Debug)]
struct PUSH_instructionVar101 {
    drk47: TokenField_drk47,
}
impl PUSH_instructionVar101 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("PUSH"),
            DisplayElement::Literal(" "),
            self.drk47.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 11i128 {
            return None;
        }
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_parser.TokenFielddrk47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:579:1, end:579:2))"]
#[derive(Clone, Debug)]
struct SLL_instructionVar102 {
    rm47: TokenField_rm47,
}
impl SLL_instructionVar102 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("SLL"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 0i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:582:1, end:582:2))"]
#[derive(Clone, Debug)]
struct SLL_instructionVar103 {
    wrj47: TokenField_wrj47,
}
impl SLL_instructionVar103 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("SLL"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 4i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:585:1, end:585:2))"]
#[derive(Clone, Debug)]
struct SRA_instructionVar104 {
    rm47: TokenField_rm47,
}
impl SRA_instructionVar104 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("SRA"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 0i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:588:1, end:588:2))"]
#[derive(Clone, Debug)]
struct SRA_instructionVar105 {
    wrj47: TokenField_wrj47,
}
impl SRA_instructionVar105 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("SRA"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 4i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:591:1, end:591:2))"]
#[derive(Clone, Debug)]
struct SRL_instructionVar106 {
    rm47: TokenField_rm47,
}
impl SRL_instructionVar106 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("SRL"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 0i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:594:1, end:594:2))"]
#[derive(Clone, Debug)]
struct SRL_instructionVar107 {
    wrj47: TokenField_wrj47,
}
impl SRL_instructionVar107 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("SRL"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 4i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:607:1, end:607:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar108 {
    rm47: TokenField_rm47,
    Data: TableData,
}
impl SUB_instructionVar108 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("SUB"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 0i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:610:1, end:610:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar109 {
    wrj47: TokenField_wrj47,
    Data16: TableData16,
}
impl SUB_instructionVar109 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("SUB"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 4i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data16 = if let Some((len, table)) = TableData16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:613:1, end:613:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar110 {
    drk47: TokenField_drk47,
    Data16x0: TableData16x0,
}
impl SUB_instructionVar110 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("SUB"),
            DisplayElement::Literal(" "),
            self.drk47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16x0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 8i128 {
            return None;
        }
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_parser.TokenFielddrk47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data16x0 = if let Some((len, table)) = TableData16x0::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16x0, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:616:1, end:616:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar111 {
    rm47: TokenField_rm47,
    Direct: TableDirect,
}
impl SUB_instructionVar111 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("SUB"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 1i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:619:1, end:619:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar112 {
    wrj47: TokenField_wrj47,
    Direct8w: TableDirect8w,
}
impl SUB_instructionVar112 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("SUB"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct8w.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 5i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct8w = if let Some((len, table)) = TableDirect8w::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct8w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:622:1, end:622:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar113 {
    rm47: TokenField_rm47,
    Direct16b: TableDirect16b,
}
impl SUB_instructionVar113 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("SUB"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16b.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 3i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct16b = if let Some((len, table)) = TableDirect16b::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16b, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:625:1, end:625:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar114 {
    wrj47: TokenField_wrj47,
    Direct16w: TableDirect16w,
}
impl SUB_instructionVar114 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("SUB"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16w.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 7i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct16w = if let Some((len, table)) = TableDirect16w::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:641:1, end:641:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar115 {
    rm47: TokenField_rm47,
    Data: TableData,
}
impl XRL_instructionVar115 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("XRL"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 0i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:644:1, end:644:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar116 {
    wrj47: TokenField_wrj47,
    Data16: TableData16,
}
impl XRL_instructionVar116 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("XRL"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 4i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data16 = if let Some((len, table)) = TableData16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:647:1, end:647:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar117 {
    rm47: TokenField_rm47,
    Direct: TableDirect,
}
impl XRL_instructionVar117 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("XRL"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 1i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:650:1, end:650:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar118 {
    wrj47: TokenField_wrj47,
    Direct8w: TableDirect8w,
}
impl XRL_instructionVar118 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("XRL"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct8w.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 5i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct8w = if let Some((len, table)) = TableDirect8w::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct8w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:653:1, end:653:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar119 {
    rm47: TokenField_rm47,
    Direct16b: TableDirect16b,
}
impl XRL_instructionVar119 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("XRL"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16b.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 3i128 {
            return None;
        }
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct16b = if let Some((len, table)) = TableDirect16b::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16b, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:656:1, end:656:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar120 {
    wrj47: TokenField_wrj47,
    Direct16w: TableDirect16w,
}
impl XRL_instructionVar120 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("XRL"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16w.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 14i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields03().disassembly() != 7i128 {
            return None;
        }
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct16w = if let Some((len, table)) = TableDirect16w::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:305:1, end:305:2))"]
#[derive(Clone, Debug)]
struct DEC_instructionVar121 {
    rm47: TokenField_rm47,
    Short: TableShort,
}
impl DEC_instructionVar121 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("DEC"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Short.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 11i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields23().disassembly() != 0i128 {
            return None;
        }
        let Short = if let Some((len, table)) =
            TableShort::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFields0().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFields1().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Short, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:308:1, end:308:2))"]
#[derive(Clone, Debug)]
struct DEC_instructionVar122 {
    wrj47: TokenField_wrj47,
    Short: TableShort,
}
impl DEC_instructionVar122 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("DEC"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Short.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 11i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields23().disassembly() != 1i128 {
            return None;
        }
        let Short = if let Some((len, table)) =
            TableShort::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFields0().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFields1().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Short, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:311:1, end:311:2))"]
#[derive(Clone, Debug)]
struct DEC_instructionVar123 {
    drk47: TokenField_drk47,
    Short: TableShort,
}
impl DEC_instructionVar123 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("DEC"),
            DisplayElement::Literal(" "),
            self.drk47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Short.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 11i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields23().disassembly() != 3i128 {
            return None;
        }
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let Short = if let Some((len, table)) =
            TableShort::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFields0().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFields1().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_parser.TokenFielddrk47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Short, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:335:1, end:335:2))"]
#[derive(Clone, Debug)]
struct INC_instructionVar124 {
    rm47: TokenField_rm47,
    Short: TableShort,
}
impl INC_instructionVar124 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("INC"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Short.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 11i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields23().disassembly() != 0i128 {
            return None;
        }
        let Short = if let Some((len, table)) =
            TableShort::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFields0().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFields1().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Short, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:338:1, end:338:2))"]
#[derive(Clone, Debug)]
struct INC_instructionVar125 {
    wrj47: TokenField_wrj47,
    Short: TableShort,
}
impl INC_instructionVar125 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("INC"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Short.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 11i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields23().disassembly() != 1i128 {
            return None;
        }
        let Short = if let Some((len, table)) =
            TableShort::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFields0().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFields1().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Short, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:341:1, end:341:2))"]
#[derive(Clone, Debug)]
struct INC_instructionVar126 {
    drk47: TokenField_drk47,
    Short: TableShort,
}
impl INC_instructionVar126 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("INC"),
            DisplayElement::Literal(" "),
            self.drk47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Short.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 11i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFields23().disassembly() != 3i128 {
            return None;
        }
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let Short = if let Some((len, table)) =
            TableShort::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFields0().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFields1().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_parser.TokenFielddrk47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Short, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:645:1, end:645:2))"]
#[derive(Clone, Debug)]
struct instructionVar127 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar127 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 5i128 {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_A5Prefix_disassembly(tmp)
            .unwrap();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:652:1, end:652:2))"]
#[derive(Clone, Debug)]
struct ACALL_instructionVar128 {
    Addr11: TableAddr11,
}
impl ACALL_instructionVar128 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ACALL"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Addr11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldaaddrfill().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldaoplo().disassembly() != 1i128 {
            return None;
        }
        let Addr11 = if let Some((len, table)) = TableAddr11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:656:1, end:656:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar129 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl ADD_instructionVar129 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ADD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 5i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:658:1, end:658:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar130 {
    Areg: TableAreg,
    Data: TableData,
}
impl ADD_instructionVar130 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ADD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 4i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:661:1, end:661:2))"]
#[derive(Clone, Debug)]
struct ADDC_instructionVar131 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl ADDC_instructionVar131 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDC"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 5i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:663:1, end:663:2))"]
#[derive(Clone, Debug)]
struct ADDC_instructionVar132 {
    Areg: TableAreg,
    Data: TableData,
}
impl ADDC_instructionVar132 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDC"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 4i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:673:1, end:673:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar133 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl ANL_instructionVar133 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ANL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 5i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:675:1, end:675:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar134 {
    Areg: TableAreg,
    Data: TableData,
}
impl ANL_instructionVar134 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ANL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 4i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:676:1, end:676:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar135 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl ANL_instructionVar135 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ANL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 2i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:677:1, end:677:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar136 {
    Direct: TableDirect,
    Data: TableData,
}
impl ANL_instructionVar136 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ANL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 3i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:682:1, end:682:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar137 {
    CY: TableCY,
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
}
impl ANL_instructionVar137 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ANL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.BitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 2i128 {
            return None;
        }
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let BitAddr = if let Some((len, table)) = TableBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitAddr,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:683:1, end:683:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar138 {
    CY: TableCY,
    BitAddr2: TableBitAddr2,
    BitByteAddr: TableBitByteAddr,
}
impl ANL_instructionVar138 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ANL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.BitAddr2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 0i128 {
            return None;
        }
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let BitAddr2 = if let Some((len, table)) = TableBitAddr2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitAddr2,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:692:1, end:692:2))"]
#[derive(Clone, Debug)]
struct CJNE_instructionVar139 {
    Areg: TableAreg,
    Direct: TableDirect,
    Rel8: TableRel8,
}
impl CJNE_instructionVar139 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CJNE"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 5i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct, Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:693:1, end:693:2))"]
#[derive(Clone, Debug)]
struct CJNE_instructionVar140 {
    Areg: TableAreg,
    Data: TableData,
    Rel8: TableRel8,
}
impl CJNE_instructionVar140 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CJNE"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 4i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Data, Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:697:1, end:697:2))"]
#[derive(Clone, Debug)]
struct CLR_instructionVar141 {
    Areg: TableAreg,
}
impl CLR_instructionVar141 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CLR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 4i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:698:1, end:698:2))"]
#[derive(Clone, Debug)]
struct CLR_instructionVar142 {
    CY: TableCY,
}
impl CLR_instructionVar142 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CLR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 3i128 {
            return None;
        }
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CY }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:702:1, end:702:2))"]
#[derive(Clone, Debug)]
struct CLR_instructionVar143 {
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
}
impl CLR_instructionVar143 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CLR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let BitAddr = if let Some((len, table)) = TableBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitAddr,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:710:1, end:710:2))"]
#[derive(Clone, Debug)]
struct CPL_instructionVar144 {
    Areg: TableAreg,
}
impl CPL_instructionVar144 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 4i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:711:1, end:711:2))"]
#[derive(Clone, Debug)]
struct CPL_instructionVar145 {
    CY: TableCY,
}
impl CPL_instructionVar145 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 3i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CY }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:715:1, end:715:2))"]
#[derive(Clone, Debug)]
struct CPL_instructionVar146 {
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
}
impl CPL_instructionVar146 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let BitAddr = if let Some((len, table)) = TableBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitAddr,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:722:1, end:722:2))"]
#[derive(Clone, Debug)]
struct DA_instructionVar147 {
    Areg: TableAreg,
}
impl DA_instructionVar147 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("DA"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 4i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:724:1, end:724:2))"]
#[derive(Clone, Debug)]
struct DEC_instructionVar148 {
    Areg: TableAreg,
}
impl DEC_instructionVar148 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("DEC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 4i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:726:1, end:726:2))"]
#[derive(Clone, Debug)]
struct DEC_instructionVar149 {
    Direct: TableDirect,
}
impl DEC_instructionVar149 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("DEC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 5i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:729:1, end:729:2))"]
#[derive(Clone, Debug)]
struct DIV_instructionVar150 {
    ABreg: TableABreg,
}
impl DIV_instructionVar150 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("DIV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ABreg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 4i128 {
            return None;
        }
        let ABreg = if let Some((len, table)) =
            TableABreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ABreg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:733:1, end:733:2))"]
#[derive(Clone, Debug)]
struct DJNZ_instructionVar151 {
    Direct: TableDirect,
    Rel8: TableRel8,
}
impl DJNZ_instructionVar151 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("DJNZ"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 5i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:735:1, end:735:2))"]
#[derive(Clone, Debug)]
struct INC_instructionVar152 {
    Areg: TableAreg,
}
impl INC_instructionVar152 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("INC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 4i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:737:1, end:737:2))"]
#[derive(Clone, Debug)]
struct INC_instructionVar153 {
    Direct: TableDirect,
}
impl INC_instructionVar153 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("INC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 5i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:747:1, end:747:2))"]
#[derive(Clone, Debug)]
struct INC_instructionVar154 {
    DPTRreg: TableDPTRreg,
}
impl INC_instructionVar154 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("INC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.DPTRreg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 3i128 {
            return None;
        }
        let DPTRreg = if let Some((len, table)) = TableDPTRreg::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { DPTRreg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:752:1, end:752:2))"]
#[derive(Clone, Debug)]
struct JB_instructionVar155 {
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
    Rel8: TableRel8,
}
impl JB_instructionVar155 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JB"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let BitAddr = if let Some((len, table)) = TableBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitAddr,
                BitByteAddr,
                Rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:753:1, end:753:2))"]
#[derive(Clone, Debug)]
struct JBC_instructionVar156 {
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
    Rel8: TableRel8,
}
impl JBC_instructionVar156 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JBC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let BitAddr = if let Some((len, table)) = TableBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitAddr,
                BitByteAddr,
                Rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:761:1, end:761:2))"]
#[derive(Clone, Debug)]
struct JC_instructionVar157 {
    Rel8: TableRel8,
}
impl JC_instructionVar157 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:762:1, end:762:2))"]
#[derive(Clone, Debug)]
struct JMP_instructionVar158 {
    ADPTR: TableADPTR,
}
impl JMP_instructionVar158 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JMP"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ADPTR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 3i128 {
            return None;
        }
        let ADPTR = if let Some((len, table)) =
            TableADPTR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ADPTR }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:766:1, end:766:2))"]
#[derive(Clone, Debug)]
struct JNB_instructionVar159 {
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
    Rel8: TableRel8,
}
impl JNB_instructionVar159 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JNB"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let BitAddr = if let Some((len, table)) = TableBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitAddr,
                BitByteAddr,
                Rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:773:1, end:773:2))"]
#[derive(Clone, Debug)]
struct JNC_instructionVar160 {
    Rel8: TableRel8,
}
impl JNC_instructionVar160 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JNC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:774:1, end:774:2))"]
#[derive(Clone, Debug)]
struct JNZ_instructionVar161 {
    Rel8: TableRel8,
}
impl JNZ_instructionVar161 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JNZ"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:775:1, end:775:2))"]
#[derive(Clone, Debug)]
struct JZ_instructionVar162 {
    Rel8: TableRel8,
}
impl JZ_instructionVar162 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JZ"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:784:1, end:784:2))"]
#[derive(Clone, Debug)]
struct LCALL_instructionVar163 {
    Addr16: TableAddr16,
}
impl LCALL_instructionVar163 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LCALL"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Addr16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Addr16 = if let Some((len, table)) = TableAddr16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:785:1, end:785:2))"]
#[derive(Clone, Debug)]
struct LJMP_instructionVar164 {
    Addr16: TableAddr16,
}
impl LJMP_instructionVar164 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LJMP"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Addr16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Addr16 = if let Some((len, table)) = TableAddr16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:789:1, end:789:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar165 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl MOV_instructionVar165 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 5i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:791:1, end:791:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar166 {
    Areg: TableAreg,
    Data: TableData,
}
impl MOV_instructionVar166 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 4i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:795:1, end:795:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar167 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl MOV_instructionVar167 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 5i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:797:1, end:797:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar168 {
    Direct: TableDirect,
    Direct2: TableDirect2,
}
impl MOV_instructionVar168 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 5i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Direct2 = if let Some((len, table)) = TableDirect2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, Direct2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:799:1, end:799:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar169 {
    Direct: TableDirect,
    Data: TableData,
}
impl MOV_instructionVar169 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 5i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:806:1, end:806:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar170 {
    DPTRreg: TableDPTRreg,
    Data16: TableData16,
}
impl MOV_instructionVar170 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.DPTRreg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 0i128 {
            return None;
        }
        let DPTRreg = if let Some((len, table)) = TableDPTRreg::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Data16 = if let Some((len, table)) = TableData16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { DPTRreg, Data16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:812:1, end:812:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar171 {
    CY: TableCY,
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
}
impl MOV_instructionVar171 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.BitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 2i128 {
            return None;
        }
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let BitAddr = if let Some((len, table)) = TableBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitAddr,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:813:1, end:813:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar172 {
    CY: TableCY,
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
}
impl MOV_instructionVar172 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.CY.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 2i128 {
            return None;
        }
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let BitAddr = if let Some((len, table)) = TableBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitAddr,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:822:1, end:822:2))"]
#[derive(Clone, Debug)]
struct MOVC_instructionVar173 {
    ADPTR: TableADPTR,
    Areg: TableAreg,
}
impl MOVC_instructionVar173 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVC"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.ADPTR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 3i128 {
            return None;
        }
        let ADPTR = if let Some((len, table)) =
            TableADPTR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ADPTR, Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:823:1, end:823:2))"]
#[derive(Clone, Debug)]
struct MOVC_instructionVar174 {
    APC: TableAPC,
    Areg: TableAreg,
}
impl MOVC_instructionVar174 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVC"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.APC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 3i128 {
            return None;
        }
        let APC = if let Some((len, table)) =
            TableAPC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { APC, Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:826:1, end:826:2))"]
#[derive(Clone, Debug)]
struct MOVX_instructionVar175 {
    Areg: TableAreg,
    ATDPTR: TableATDPTR,
}
impl MOVX_instructionVar175 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVX"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.ATDPTR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 0i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ATDPTR = if let Some((len, table)) = TableATDPTR::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, ATDPTR }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:828:1, end:828:2))"]
#[derive(Clone, Debug)]
struct MOVX_instructionVar176 {
    Areg: TableAreg,
    ATDPTR: TableATDPTR,
}
impl MOVX_instructionVar176 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVX"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.ATDPTR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 0i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ATDPTR = if let Some((len, table)) = TableATDPTR::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, ATDPTR }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:830:1, end:830:2))"]
#[derive(Clone, Debug)]
struct MUL_instructionVar177 {
    ABreg: TableABreg,
}
impl MUL_instructionVar177 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MUL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ABreg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 4i128 {
            return None;
        }
        let ABreg = if let Some((len, table)) =
            TableABreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ABreg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:833:1, end:833:2))"]
#[derive(Clone, Debug)]
struct NOP_instructionVar178 {}
impl NOP_instructionVar178 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("NOP")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:836:1, end:836:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar179 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl ORL_instructionVar179 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ORL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 5i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:838:1, end:838:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar180 {
    Areg: TableAreg,
    Data: TableData,
}
impl ORL_instructionVar180 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ORL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 4i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:839:1, end:839:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar181 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl ORL_instructionVar181 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ORL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 2i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:840:1, end:840:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar182 {
    Areg: TableAreg,
    Direct: TableDirect,
    Data: TableData,
}
impl ORL_instructionVar182 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ORL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 3i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:845:1, end:845:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar183 {
    CY: TableCY,
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
}
impl ORL_instructionVar183 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ORL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.BitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 2i128 {
            return None;
        }
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let BitAddr = if let Some((len, table)) = TableBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitAddr,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:846:1, end:846:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar184 {
    CY: TableCY,
    BitAddr2: TableBitAddr2,
    BitByteAddr: TableBitByteAddr,
}
impl ORL_instructionVar184 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ORL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.BitAddr2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 0i128 {
            return None;
        }
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let BitAddr2 = if let Some((len, table)) = TableBitAddr2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitAddr2,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:855:1, end:855:2))"]
#[derive(Clone, Debug)]
struct POP_instructionVar185 {
    Direct: TableDirect,
}
impl POP_instructionVar185 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("POP"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:857:1, end:857:2))"]
#[derive(Clone, Debug)]
struct PUSH_instructionVar186 {
    Direct: TableDirect,
}
impl PUSH_instructionVar186 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("PUSH"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:859:1, end:859:2))"]
#[derive(Clone, Debug)]
struct RET_instructionVar187 {}
impl RET_instructionVar187 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("RET")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:869:1, end:869:2))"]
#[derive(Clone, Debug)]
struct RETI_instructionVar188 {}
impl RETI_instructionVar188 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("RETI")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:879:1, end:879:2))"]
#[derive(Clone, Debug)]
struct RL_instructionVar189 {
    Areg: TableAreg,
}
impl RL_instructionVar189 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("RL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 3i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:880:1, end:880:2))"]
#[derive(Clone, Debug)]
struct RLC_instructionVar190 {
    Areg: TableAreg,
}
impl RLC_instructionVar190 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("RLC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 3i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:881:1, end:881:2))"]
#[derive(Clone, Debug)]
struct RR_instructionVar191 {
    Areg: TableAreg,
}
impl RR_instructionVar191 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("RR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 3i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:882:1, end:882:2))"]
#[derive(Clone, Debug)]
struct RRC_instructionVar192 {
    Areg: TableAreg,
}
impl RRC_instructionVar192 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("RRC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 3i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:884:1, end:884:2))"]
#[derive(Clone, Debug)]
struct SETB_instructionVar193 {
    CY: TableCY,
}
impl SETB_instructionVar193 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SETB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.CY.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 3i128 {
            return None;
        }
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CY }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:888:1, end:888:2))"]
#[derive(Clone, Debug)]
struct SETB_instructionVar194 {
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
}
impl SETB_instructionVar194 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SETB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.BitAddr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let BitAddr = if let Some((len, table)) = TableBitAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) = TableBitByteAddr::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitAddr,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:895:1, end:895:2))"]
#[derive(Clone, Debug)]
struct SJMP_instructionVar195 {
    Rel8: TableRel8,
}
impl SJMP_instructionVar195 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SJMP"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:898:1, end:898:2))"]
#[derive(Clone, Debug)]
struct SUBB_instructionVar196 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl SUBB_instructionVar196 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 5i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:900:1, end:900:2))"]
#[derive(Clone, Debug)]
struct SUBB_instructionVar197 {
    Areg: TableAreg,
    Data: TableData,
}
impl SUBB_instructionVar197 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 4i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:902:1, end:902:2))"]
#[derive(Clone, Debug)]
struct SWAP_instructionVar198 {
    Areg: TableAreg,
}
impl SWAP_instructionVar198 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SWAP"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 4i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:905:1, end:905:2))"]
#[derive(Clone, Debug)]
struct XCH_instructionVar199 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl XCH_instructionVar199 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("XCH"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 5i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:912:1, end:912:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar200 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl XRL_instructionVar200 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("XRL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 5i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:914:1, end:914:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar201 {
    Areg: TableAreg,
    Data: TableData,
}
impl XRL_instructionVar201 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("XRL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 4i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:915:1, end:915:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar202 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl XRL_instructionVar202 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("XRL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 2i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:916:1, end:916:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar203 {
    Direct: TableDirect,
    Data: TableData,
}
impl XRL_instructionVar203 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("XRL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 3i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:186:1, end:186:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar204 {
    rm47: TokenField_rm47,
    rm03: TokenField_rm03,
}
impl ADD_instructionVar204 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("ADD"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
            self.rm03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 12i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let rm47 = token_parser.TokenFieldrm47();
        let rm03 = token_parser.TokenFieldrm03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47, rm03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:189:1, end:189:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar205 {
    wrj47: TokenField_wrj47,
    wrj03: TokenField_wrj03,
}
impl ADD_instructionVar205 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("ADD"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
            self.wrj03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 13i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let wrj47 = token_parser.TokenFieldwrj47();
        let wrj03 = token_parser.TokenFieldwrj03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, wrj03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:192:1, end:192:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar206 {
    drk47: TokenField_drk47,
    drk03: TokenField_drk03,
}
impl ADD_instructionVar206 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("ADD"),
            DisplayElement::Literal(" "),
            self.drk47.display(),
            DisplayElement::Literal(","),
            self.drk03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 15i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFields3().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFields13().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_parser.TokenFielddrk47();
        let drk03 = token_parser.TokenFielddrk03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk47, drk03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:222:1, end:222:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar207 {
    rm47: TokenField_rm47,
    rm03: TokenField_rm03,
}
impl ANL_instructionVar207 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("ANL"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
            self.rm03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 12i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let rm47 = token_parser.TokenFieldrm47();
        let rm03 = token_parser.TokenFieldrm03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47, rm03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:225:1, end:225:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar208 {
    wrj47: TokenField_wrj47,
    wrj03: TokenField_wrj03,
}
impl ANL_instructionVar208 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("ANL"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
            self.wrj03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 13i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let wrj47 = token_parser.TokenFieldwrj47();
        let wrj03 = token_parser.TokenFieldwrj03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, wrj03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:261:1, end:261:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar209 {
    rm47: TokenField_rm47,
    rm03: TokenField_rm03,
}
impl CMP_instructionVar209 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("CMP"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
            self.rm03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 12i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let rm47 = token_parser.TokenFieldrm47();
        let rm03 = token_parser.TokenFieldrm03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47, rm03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:265:1, end:265:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar210 {
    wrj47: TokenField_wrj47,
    wrj03: TokenField_wrj03,
}
impl CMP_instructionVar210 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("CMP"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
            self.wrj03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 13i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let wrj47 = token_parser.TokenFieldwrj47();
        let wrj03 = token_parser.TokenFieldwrj03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, wrj03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:268:1, end:268:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar211 {
    drk47: TokenField_drk47,
    drk03: TokenField_drk03,
}
impl CMP_instructionVar211 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("CMP"),
            DisplayElement::Literal(" "),
            self.drk47.display(),
            DisplayElement::Literal(","),
            self.drk03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 15i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFields3().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFields13().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_parser.TokenFielddrk47();
        let drk03 = token_parser.TokenFielddrk03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk47, drk03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:314:1, end:314:2))"]
#[derive(Clone, Debug)]
struct DIV_instructionVar212 {
    rm47: TokenField_rm47,
    rm03: TokenField_rm03,
}
impl DIV_instructionVar212 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("DIV"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
            self.rm03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 12i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let rm47 = token_parser.TokenFieldrm47();
        let rm47_d1 = token_parser.TokenFieldrm47_d1();
        let rm47_d2 = token_parser.TokenFieldrm47_d2();
        let rm03 = token_parser.TokenFieldrm03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47, rm03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:317:1, end:317:2))"]
#[derive(Clone, Debug)]
struct DIV_instructionVar213 {
    wrj47: TokenField_wrj47,
    wrj03: TokenField_wrj03,
}
impl DIV_instructionVar213 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("DIV"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
            self.wrj03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 13i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let wrj47 = token_parser.TokenFieldwrj47();
        let wrj47_d1 = token_parser.TokenFieldwrj47_d1();
        let wrj47_d2 = token_parser.TokenFieldwrj47_d2();
        let wrj03 = token_parser.TokenFieldwrj03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, wrj03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:320:1, end:320:2))"]
#[derive(Clone, Debug)]
struct ECALL_instructionVar214 {
    Addr24: TableAddr24,
}
impl ECALL_instructionVar214 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ECALL"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Addr24.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Addr24 = if let Some((len, table)) = TableAddr24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:326:1, end:326:2))"]
#[derive(Clone, Debug)]
struct EJMP_instructionVar215 {
    Addr24: TableAddr24,
}
impl EJMP_instructionVar215 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EJMP"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Addr24.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Addr24 = if let Some((len, table)) = TableAddr24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:332:1, end:332:2))"]
#[derive(Clone, Debug)]
struct ERET_instructionVar216 {}
impl ERET_instructionVar216 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ERET")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:350:1, end:350:2))"]
#[derive(Clone, Debug)]
struct JE_instructionVar217 {
    Rel8: TableRel8,
}
impl JE_instructionVar217 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JE"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 8i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:353:1, end:353:2))"]
#[derive(Clone, Debug)]
struct JG_instructionVar218 {
    Rel8: TableRel8,
}
impl JG_instructionVar218 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JG"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 8i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:356:1, end:356:2))"]
#[derive(Clone, Debug)]
struct JLE_instructionVar219 {
    Rel8: TableRel8,
}
impl JLE_instructionVar219 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JLE"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 8i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:362:1, end:362:2))"]
#[derive(Clone, Debug)]
struct JNE_instructionVar220 {
    Rel8: TableRel8,
}
impl JNE_instructionVar220 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JNE"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 8i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:365:1, end:365:2))"]
#[derive(Clone, Debug)]
struct JSG_instructionVar221 {
    Rel8: TableRel8,
}
impl JSG_instructionVar221 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JSG"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 8i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:368:1, end:368:2))"]
#[derive(Clone, Debug)]
struct JSGE_instructionVar222 {
    Rel8: TableRel8,
}
impl JSGE_instructionVar222 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("JSGE"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 8i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:371:1, end:371:2))"]
#[derive(Clone, Debug)]
struct JSL_instructionVar223 {
    Rel8: TableRel8,
}
impl JSL_instructionVar223 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JSL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 8i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:374:1, end:374:2))"]
#[derive(Clone, Debug)]
struct JSLE_instructionVar224 {
    Rel8: TableRel8,
}
impl JSLE_instructionVar224 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("JSLE"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 8i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:383:1, end:383:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar225 {
    rm47: TokenField_rm47,
    rm03: TokenField_rm03,
}
impl MOV_instructionVar225 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
            self.rm03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 12i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let rm47 = token_parser.TokenFieldrm47();
        let rm03 = token_parser.TokenFieldrm03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47, rm03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:386:1, end:386:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar226 {
    wrj47: TokenField_wrj47,
    wrj03: TokenField_wrj03,
}
impl MOV_instructionVar226 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
            self.wrj03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 13i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let wrj47 = token_parser.TokenFieldwrj47();
        let wrj03 = token_parser.TokenFieldwrj03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, wrj03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:389:1, end:389:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar227 {
    drk47: TokenField_drk47,
    drk03: TokenField_drk03,
}
impl MOV_instructionVar227 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.drk47.display(),
            DisplayElement::Literal(","),
            self.drk03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 15i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let drk47 = token_parser.TokenFielddrk47();
        let drk03 = token_parser.TokenFielddrk03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk47, drk03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:469:1, end:469:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar228 {
    rm47: TokenField_rm47,
    AtWRj03Dis16b: TableAtWRj03Dis16b,
}
impl MOV_instructionVar228 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtWRj03Dis16b.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let AtWRj03Dis16b = if let Some((len, table)) =
            TableAtWRj03Dis16b::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm47 = token_parser.TokenFieldrm47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                AtWRj03Dis16b,
                rm47,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:472:1, end:472:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar229 {
    wrj47: TokenField_wrj47,
    AtWRj03Dis16w: TableAtWRj03Dis16w,
}
impl MOV_instructionVar229 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtWRj03Dis16w.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let AtWRj03Dis16w = if let Some((len, table)) =
            TableAtWRj03Dis16w::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                AtWRj03Dis16w,
                wrj47,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:475:1, end:475:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar230 {
    rm47: TokenField_rm47,
    AtDRk03Dis24b: TableAtDRk03Dis24b,
}
impl MOV_instructionVar230 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtDRk03Dis24b.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c58 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                    let token_parser =
                        <TokenParser<1usize>>::new(tokens_param)?;
                    if token_parser.TokenFields3().disassembly() == 0i128 {
                        return Some(((), (), u32::try_from(1u64).unwrap()));
                    }
                    let token_parser =
                        <TokenParser<1usize>>::new(tokens_param)?;
                    if token_parser.TokenFields13().disassembly() == 4i128 {
                        return Some(((), (), u32::try_from(1u64).unwrap()));
                    }
                    None
                };
                let ((), (), block_0_len) =
                    block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c9(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let rm47 = token_parser.TokenFieldrm47();
            let drk03 = token_parser.TokenFielddrk03();
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (rm47, drk03), pattern_len))
        };
        let ((), (rm47, drk03), sub_len) =
            sub_pattern_c58(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRk03Dis24b = if let Some((len, table)) =
            TableAtDRk03Dis24b::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                AtDRk03Dis24b,
                rm47,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:478:1, end:478:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar231 {
    wrj47: TokenField_wrj47,
    AtDRk03Dis24w: TableAtDRk03Dis24w,
}
impl MOV_instructionVar231 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtDRk03Dis24w.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c58 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                    let token_parser =
                        <TokenParser<1usize>>::new(tokens_param)?;
                    if token_parser.TokenFields3().disassembly() == 0i128 {
                        return Some(((), (), u32::try_from(1u64).unwrap()));
                    }
                    let token_parser =
                        <TokenParser<1usize>>::new(tokens_param)?;
                    if token_parser.TokenFields13().disassembly() == 4i128 {
                        return Some(((), (), u32::try_from(1u64).unwrap()));
                    }
                    None
                };
                let ((), (), block_0_len) =
                    block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c9(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let wrj47 = token_parser.TokenFieldwrj47();
            let drk03 = token_parser.TokenFielddrk03();
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (wrj47, drk03), pattern_len))
        };
        let ((), (wrj47, drk03), sub_len) =
            sub_pattern_c58(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRk03Dis24w = if let Some((len, table)) =
            TableAtDRk03Dis24w::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                AtDRk03Dis24w,
                wrj47,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:481:1, end:481:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar232 {
    rm03: TokenField_rm03,
    AtWRj47Dis16b: TableAtWRj47Dis16b,
}
impl MOV_instructionVar232 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.AtWRj47Dis16b.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.rm03.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let AtWRj47Dis16b = if let Some((len, table)) =
            TableAtWRj47Dis16b::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm03 = token_parser.TokenFieldrm03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                AtWRj47Dis16b,
                rm03,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:484:1, end:484:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar233 {
    wrj03: TokenField_wrj03,
    AtWRj47Dis16w: TableAtWRj47Dis16w,
}
impl MOV_instructionVar233 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.AtWRj47Dis16w.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.wrj03.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let AtWRj47Dis16w = if let Some((len, table)) =
            TableAtWRj47Dis16w::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let wrj03 = token_parser.TokenFieldwrj03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                AtWRj47Dis16w,
                wrj03,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:487:1, end:487:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar234 {
    rm03: TokenField_rm03,
    AtDRk47Dis24b: TableAtDRk47Dis24b,
}
impl MOV_instructionVar234 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.AtDRk47Dis24b.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.rm03.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c58 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                    let token_parser =
                        <TokenParser<1usize>>::new(tokens_param)?;
                    if token_parser.TokenFieldd7().disassembly() == 0i128 {
                        return Some(((), (), u32::try_from(1u64).unwrap()));
                    }
                    let token_parser =
                        <TokenParser<1usize>>::new(tokens_param)?;
                    if token_parser.TokenFieldd57().disassembly() == 4i128 {
                        return Some(((), (), u32::try_from(1u64).unwrap()));
                    }
                    None
                };
                let ((), (), block_0_len) =
                    block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c9(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let rm03 = token_parser.TokenFieldrm03();
            let drk47 = token_parser.TokenFielddrk47();
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (rm03, drk47), pattern_len))
        };
        let ((), (rm03, drk47), sub_len) =
            sub_pattern_c58(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRk47Dis24b = if let Some((len, table)) =
            TableAtDRk47Dis24b::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                AtDRk47Dis24b,
                rm03,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:490:1, end:490:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar235 {
    wrj03: TokenField_wrj03,
    AtDRk47Dis24w: TableAtDRk47Dis24w,
}
impl MOV_instructionVar235 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.AtDRk47Dis24w.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.wrj03.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 9i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c59 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                    let token_parser =
                        <TokenParser<1usize>>::new(tokens_param)?;
                    if token_parser.TokenFieldd7().disassembly() == 0i128 {
                        return Some(((), (), u32::try_from(1u64).unwrap()));
                    }
                    let token_parser =
                        <TokenParser<1usize>>::new(tokens_param)?;
                    if token_parser.TokenFieldd57().disassembly() == 4i128 {
                        return Some(((), (), u32::try_from(1u64).unwrap()));
                    }
                    None
                };
                let ((), (), block_0_len) =
                    block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c9(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let wrj03 = token_parser.TokenFieldwrj03();
            let drk47 = token_parser.TokenFielddrk47();
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (wrj03, drk47), pattern_len))
        };
        let ((), (wrj03, drk47), sub_len) =
            sub_pattern_c59(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRk47Dis24w = if let Some((len, table)) =
            TableAtDRk47Dis24w::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                AtDRk47Dis24w,
                wrj03,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:503:1, end:503:2))"]
#[derive(Clone, Debug)]
struct MOVZ_instructionVar236 {
    wrj47: TokenField_wrj47,
    rm03: TokenField_rm03,
}
impl MOVZ_instructionVar236 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("MOVZ"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
            self.rm03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let wrj47 = token_parser.TokenFieldwrj47();
        let rm03 = token_parser.TokenFieldrm03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, rm03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:506:1, end:506:2))"]
#[derive(Clone, Debug)]
struct MOVZ_instructionVar237 {
    wrj47: TokenField_wrj47,
    rm03: TokenField_rm03,
}
impl MOVZ_instructionVar237 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("MOVZ"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
            self.rm03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 10i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let wrj47 = token_parser.TokenFieldwrj47();
        let rm03 = token_parser.TokenFieldrm03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, rm03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:509:1, end:509:2))"]
#[derive(Clone, Debug)]
struct MUL_instructionVar238 {
    rm47: TokenField_rm47,
    rm03: TokenField_rm03,
}
impl MUL_instructionVar238 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("MUL"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
            self.rm03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 12i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let rm47 = token_parser.TokenFieldrm47();
        let rm03 = token_parser.TokenFieldrm03();
        let rm47_d1 = token_parser.TokenFieldrm47_d1();
        let rm47_d2 = token_parser.TokenFieldrm47_d2();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47, rm03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:512:1, end:512:2))"]
#[derive(Clone, Debug)]
struct MUL_instructionVar239 {
    wrj47: TokenField_wrj47,
    wrj03: TokenField_wrj03,
}
impl MUL_instructionVar239 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("MUL"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
            self.wrj03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 13i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let wrj47 = token_parser.TokenFieldwrj47();
        let wrj03 = token_parser.TokenFieldwrj03();
        let wrj47_d1 = token_parser.TokenFieldwrj47_d1();
        let wrj47_d2 = token_parser.TokenFieldwrj47_d2();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, wrj03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:515:1, end:515:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar240 {
    rm47: TokenField_rm47,
    rm03: TokenField_rm03,
}
impl ORL_instructionVar240 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("ORL"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
            self.rm03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 12i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let rm47 = token_parser.TokenFieldrm47();
        let rm03 = token_parser.TokenFieldrm03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47, rm03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:518:1, end:518:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar241 {
    wrj47: TokenField_wrj47,
    wrj03: TokenField_wrj03,
}
impl ORL_instructionVar241 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("ORL"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
            self.wrj03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 13i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let wrj47 = token_parser.TokenFieldwrj47();
        let wrj03 = token_parser.TokenFieldwrj03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, wrj03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:598:1, end:598:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar242 {
    rm47: TokenField_rm47,
    rm03: TokenField_rm03,
}
impl SUB_instructionVar242 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("SUB"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
            self.rm03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 12i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let rm47 = token_parser.TokenFieldrm47();
        let rm03 = token_parser.TokenFieldrm03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47, rm03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:601:1, end:601:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar243 {
    wrj47: TokenField_wrj47,
    wrj03: TokenField_wrj03,
}
impl SUB_instructionVar243 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("SUB"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
            self.wrj03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 13i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let wrj47 = token_parser.TokenFieldwrj47();
        let wrj03 = token_parser.TokenFieldwrj03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, wrj03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:604:1, end:604:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar244 {
    drk47: TokenField_drk47,
    drk03: TokenField_drk03,
}
impl SUB_instructionVar244 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("SUB"),
            DisplayElement::Literal(" "),
            self.drk47.display(),
            DisplayElement::Literal(","),
            self.drk03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 15i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd7().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldd57().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFields3().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFields13().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_parser.TokenFielddrk47();
        let drk03 = token_parser.TokenFielddrk03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk47, drk03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:635:1, end:635:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar245 {
    rm47: TokenField_rm47,
    rm03: TokenField_rm03,
}
impl XRL_instructionVar245 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("XRL"),
            DisplayElement::Literal(" "),
            self.rm47.display(),
            DisplayElement::Literal(","),
            self.rm03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 12i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let rm47 = token_parser.TokenFieldrm47();
        let rm03 = token_parser.TokenFieldrm03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47, rm03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:638:1, end:638:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar246 {
    wrj47: TokenField_wrj47,
    wrj03: TokenField_wrj03,
}
impl XRL_instructionVar246 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("XRL"),
            DisplayElement::Literal(" "),
            self.wrj47.display(),
            DisplayElement::Literal(","),
            self.wrj03.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldoplo().disassembly() != 13i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let wrj47 = token_parser.TokenFieldwrj47();
        let wrj03 = token_parser.TokenFieldwrj03();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, wrj03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:657:1, end:657:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar247 {
    Areg: TableAreg,
    Ri: TableRi,
}
impl ADD_instructionVar247 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ADD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ri.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldrifill().disassembly() != 3i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Ri }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:662:1, end:662:2))"]
#[derive(Clone, Debug)]
struct ADDC_instructionVar248 {
    Areg: TableAreg,
    Ri: TableRi,
}
impl ADDC_instructionVar248 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDC"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ri.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldrifill().disassembly() != 3i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Ri }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:674:1, end:674:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar249 {
    Areg: TableAreg,
    Ri: TableRi,
}
impl ANL_instructionVar249 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ANL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ri.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldrifill().disassembly() != 3i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Ri }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:695:1, end:695:2))"]
#[derive(Clone, Debug)]
struct CJNE_instructionVar250 {
    Ri: TableRi,
    Data: TableData,
    Rel8: TableRel8,
}
impl CJNE_instructionVar250 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CJNE"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Ri.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldrifill().disassembly() != 3i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ri, Data, Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:727:1, end:727:2))"]
#[derive(Clone, Debug)]
struct DEC_instructionVar251 {
    Ri: TableRi,
}
impl DEC_instructionVar251 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("DEC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Ri.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldrifill().disassembly() != 3i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ri }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:746:1, end:746:2))"]
#[derive(Clone, Debug)]
struct INC_instructionVar252 {
    Ri: TableRi,
}
impl INC_instructionVar252 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("INC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Ri.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldrifill().disassembly() != 3i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ri }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:790:1, end:790:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar253 {
    Areg: TableAreg,
    Ri: TableRi,
}
impl MOV_instructionVar253 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ri.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldrifill().disassembly() != 3i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Ri }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:798:1, end:798:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar254 {
    Ri: TableRi,
    Direct: TableDirect,
}
impl MOV_instructionVar254 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ri.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldrifill().disassembly() != 3i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ri, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:800:1, end:800:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar255 {
    Ri: TableRi,
    Areg: TableAreg,
}
impl MOV_instructionVar255 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Ri.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldrifill().disassembly() != 3i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ri, Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:801:1, end:801:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar256 {
    Ri: TableRi,
    Direct: TableDirect,
}
impl MOV_instructionVar256 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Ri.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldrifill().disassembly() != 3i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ri, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:802:1, end:802:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar257 {
    Ri: TableRi,
    Data: TableData,
}
impl MOV_instructionVar257 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Ri.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldrifill().disassembly() != 3i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ri, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:825:1, end:825:2))"]
#[derive(Clone, Debug)]
struct MOVX_instructionVar258 {
    RiX: TableRiX,
    Areg: TableAreg,
}
impl MOVX_instructionVar258 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVX"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RiX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldrifill().disassembly() != 1i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let RiX = if let Some((len, table)) =
            TableRiX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RiX, Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:827:1, end:827:2))"]
#[derive(Clone, Debug)]
struct MOVX_instructionVar259 {
    RiX: TableRiX,
    Areg: TableAreg,
}
impl MOVX_instructionVar259 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVX"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RiX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldrifill().disassembly() != 1i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let RiX = if let Some((len, table)) =
            TableRiX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RiX, Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:837:1, end:837:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar260 {
    Areg: TableAreg,
    Ri: TableRi,
}
impl ORL_instructionVar260 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ORL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ri.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldrifill().disassembly() != 3i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Ri }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:899:1, end:899:2))"]
#[derive(Clone, Debug)]
struct SUBB_instructionVar261 {
    Areg: TableAreg,
    Ri: TableRi,
}
impl SUBB_instructionVar261 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ri.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldrifill().disassembly() != 3i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Ri }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:906:1, end:906:2))"]
#[derive(Clone, Debug)]
struct XCH_instructionVar262 {
    Ri: TableRi,
    Areg: TableAreg,
}
impl XCH_instructionVar262 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("XCH"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ri.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldrifill().disassembly() != 3i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ri, Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:909:1, end:909:2))"]
#[derive(Clone, Debug)]
struct XCHD_instructionVar263 {
    Areg: TableAreg,
    Ri: TableRi,
}
impl XCHD_instructionVar263 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("XCHD"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ri.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldrifill().disassembly() != 3i128 {
            return None;
        }
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Ri }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:913:1, end:913:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar264 {
    Ri: TableRi,
    Areg: TableAreg,
}
impl XRL_instructionVar264 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("XRL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ri.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldrifill().disassembly() != 3i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ri, Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:655:1, end:655:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar265 {
    rn: TokenField_rn,
    Areg: TableAreg,
}
impl ADD_instructionVar265 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ADD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.rn.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldrnfill().disassembly() != 1i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = token_parser.TokenFieldrn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:660:1, end:660:2))"]
#[derive(Clone, Debug)]
struct ADDC_instructionVar266 {
    rn: TokenField_rn,
    Areg: TableAreg,
}
impl ADDC_instructionVar266 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDC"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.rn.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldrnfill().disassembly() != 1i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = token_parser.TokenFieldrn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:669:1, end:669:2))"]
#[derive(Clone, Debug)]
struct AJMP_instructionVar267 {
    Addr11: TableAddr11,
}
impl AJMP_instructionVar267 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("AJMP"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Addr11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldaaddrfill().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldaoplo().disassembly() != 1i128 {
            return None;
        }
        let Addr11 = if let Some((len, table)) = TableAddr11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:672:1, end:672:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar268 {
    rn: TokenField_rn,
    Areg: TableAreg,
}
impl ANL_instructionVar268 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ANL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.rn.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldrnfill().disassembly() != 1i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = token_parser.TokenFieldrn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:694:1, end:694:2))"]
#[derive(Clone, Debug)]
struct CJNE_instructionVar269 {
    rn: TokenField_rn,
    Data: TableData,
    Rel8: TableRel8,
}
impl CJNE_instructionVar269 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("CJNE"),
            DisplayElement::Literal(" "),
            self.rn.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldrnfill().disassembly() != 1i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rn = token_parser.TokenFieldrn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data, Rel8, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:725:1, end:725:2))"]
#[derive(Clone, Debug)]
struct DEC_instructionVar270 {
    rn: TokenField_rn,
}
impl DEC_instructionVar270 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("DEC"),
            DisplayElement::Literal(" "),
            self.rn.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldrnfill().disassembly() != 1i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rn = token_parser.TokenFieldrn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:732:1, end:732:2))"]
#[derive(Clone, Debug)]
struct DJNZ_instructionVar271 {
    rn: TokenField_rn,
    Rel8: TableRel8,
}
impl DJNZ_instructionVar271 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("DJNZ"),
            DisplayElement::Literal(" "),
            self.rn.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldrnfill().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldrnfill().disassembly() != 1i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rn = token_parser.TokenFieldrn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:736:1, end:736:2))"]
#[derive(Clone, Debug)]
struct INC_instructionVar272 {
    rn: TokenField_rn,
}
impl INC_instructionVar272 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("INC"),
            DisplayElement::Literal(" "),
            self.rn.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldrnfill().disassembly() != 1i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rn = token_parser.TokenFieldrn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:788:1, end:788:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar273 {
    rn: TokenField_rn,
    Areg: TableAreg,
}
impl MOV_instructionVar273 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.rn.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldrnfill().disassembly() != 1i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = token_parser.TokenFieldrn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:792:1, end:792:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar274 {
    rn: TokenField_rn,
    Areg: TableAreg,
}
impl MOV_instructionVar274 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.rn.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldrnfill().disassembly() != 1i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = token_parser.TokenFieldrn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:793:1, end:793:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar275 {
    rn: TokenField_rn,
    Direct: TableDirect,
}
impl MOV_instructionVar275 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.rn.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldrnfill().disassembly() != 1i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rn = token_parser.TokenFieldrn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:794:1, end:794:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar276 {
    rn: TokenField_rn,
    Data: TableData,
}
impl MOV_instructionVar276 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MOV"),
            DisplayElement::Literal(" "),
            self.rn.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldrnfill().disassembly() != 1i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rn = token_parser.TokenFieldrn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:796:1, end:796:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar277 {
    rn: TokenField_rn,
    Direct: TableDirect,
}
impl MOV_instructionVar277 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOV"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.rn.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldrnfill().disassembly() != 1i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rn = token_parser.TokenFieldrn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:835:1, end:835:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar278 {
    rn: TokenField_rn,
    Areg: TableAreg,
}
impl ORL_instructionVar278 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ORL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.rn.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldrnfill().disassembly() != 1i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = token_parser.TokenFieldrn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:897:1, end:897:2))"]
#[derive(Clone, Debug)]
struct SUBB_instructionVar279 {
    rn: TokenField_rn,
    Areg: TableAreg,
}
impl SUBB_instructionVar279 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.rn.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 9i128 {
            return None;
        }
        if token_parser.TokenFieldrnfill().disassembly() != 1i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = token_parser.TokenFieldrn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:904:1, end:904:2))"]
#[derive(Clone, Debug)]
struct XCH_instructionVar280 {
    rn: TokenField_rn,
    Areg: TableAreg,
}
impl XCH_instructionVar280 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("XCH"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.rn.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldrnfill().disassembly() != 1i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = token_parser.TokenFieldrn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:911:1, end:911:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar281 {
    rn: TokenField_rn,
    Areg: TableAreg,
}
impl XRL_instructionVar281 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("XRL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.rn.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldophi().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldrnfill().disassembly() != 1i128 {
            return None;
        }
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 0u64 as u32;
                        if context_instance
                            .register()
                            .read_srcMode_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        if context_instance
                            .register()
                            .read_A5Prefix_disassembly()
                            .unwrap()
                            != 1i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = token_parser.TokenFieldrn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:646:1, end:646:2))"]
#[derive(Clone, Debug)]
struct instructionVar282 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar282 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_phase_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_phase_disassembly(tmp)
            .unwrap();
        let tmp = 0i128;
        context_instance
            .register_mut()
            .write_A5Prefix_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[derive(Clone, Debug)]
enum Tableinstruction {
    Var0(PUSH_instructionVar0),
    Var1(PUSH_instructionVar1),
    Var2(ANL_instructionVar2),
    Var3(ANL_instructionVar3),
    Var4(CLR_instructionVar4),
    Var5(CPL_instructionVar5),
    Var6(JB_instructionVar6),
    Var7(JBC_instructionVar7),
    Var8(JNB_instructionVar8),
    Var9(MOV_instructionVar9),
    Var10(MOV_instructionVar10),
    Var11(ORL_instructionVar11),
    Var12(ORL_instructionVar12),
    Var13(SETB_instructionVar13),
    Var14(ANL_instructionVar14),
    Var15(ANL_instructionVar15),
    Var16(CLR_instructionVar16),
    Var17(CPL_instructionVar17),
    Var18(JB_instructionVar18),
    Var19(JBC_instructionVar19),
    Var20(JNB_instructionVar20),
    Var21(MOV_instructionVar21),
    Var22(MOV_instructionVar22),
    Var23(ORL_instructionVar23),
    Var24(ORL_instructionVar24),
    Var25(SETB_instructionVar25),
    Var26(ADD_instructionVar26),
    Var27(ADD_instructionVar27),
    Var28(ANL_instructionVar28),
    Var29(ANL_instructionVar29),
    Var30(CMP_instructionVar30),
    Var31(CMP_instructionVar31),
    Var32(MOV_instructionVar32),
    Var33(MOV_instructionVar33),
    Var34(MOV_instructionVar34),
    Var35(MOV_instructionVar35),
    Var36(MOV_instructionVar36),
    Var37(MOV_instructionVar37),
    Var38(MOV_instructionVar38),
    Var39(MOV_instructionVar39),
    Var40(MOV_instructionVar40),
    Var41(MOV_instructionVar41),
    Var42(MOV_instructionVar42),
    Var43(MOV_instructionVar43),
    Var44(ORL_instructionVar44),
    Var45(ORL_instructionVar45),
    Var46(SUB_instructionVar46),
    Var47(SUB_instructionVar47),
    Var48(XRL_instructionVar48),
    Var49(XRL_instructionVar49),
    Var50(ADD_instructionVar50),
    Var51(ADD_instructionVar51),
    Var52(ADD_instructionVar52),
    Var53(ADD_instructionVar53),
    Var54(ADD_instructionVar54),
    Var55(ADD_instructionVar55),
    Var56(ADD_instructionVar56),
    Var57(ADD_instructionVar57),
    Var58(ANL_instructionVar58),
    Var59(ANL_instructionVar59),
    Var60(ANL_instructionVar60),
    Var61(ANL_instructionVar61),
    Var62(ANL_instructionVar62),
    Var63(CMP_instructionVar63),
    Var64(CMP_instructionVar64),
    Var65(CMP_instructionVar65),
    Var66(CMP_instructionVar66),
    Var67(CMP_instructionVar67),
    Var68(CMP_instructionVar68),
    Var69(CMP_instructionVar69),
    Var70(CMP_instructionVar70),
    Var71(ECALL_instructionVar71),
    Var72(EJMP_instructionVar72),
    Var73(LCALL_instructionVar73),
    Var74(LJMP_instructionVar74),
    Var75(MOV_instructionVar75),
    Var76(MOV_instructionVar76),
    Var77(MOV_instructionVar77),
    Var78(MOV_instructionVar78),
    Var79(MOV_instructionVar79),
    Var80(MOV_instructionVar80),
    Var81(MOV_instructionVar81),
    Var82(MOV_instructionVar82),
    Var83(MOV_instructionVar83),
    Var84(MOV_instructionVar84),
    Var85(MOV_instructionVar85),
    Var86(MOV_instructionVar86),
    Var87(MOV_instructionVar87),
    Var88(MOV_instructionVar88),
    Var89(MOVH_instructionVar89),
    Var90(ORL_instructionVar90),
    Var91(ORL_instructionVar91),
    Var92(ORL_instructionVar92),
    Var93(ORL_instructionVar93),
    Var94(ORL_instructionVar94),
    Var95(ORL_instructionVar95),
    Var96(POP_instructionVar96),
    Var97(POP_instructionVar97),
    Var98(POP_instructionVar98),
    Var99(PUSH_instructionVar99),
    Var100(PUSH_instructionVar100),
    Var101(PUSH_instructionVar101),
    Var102(SLL_instructionVar102),
    Var103(SLL_instructionVar103),
    Var104(SRA_instructionVar104),
    Var105(SRA_instructionVar105),
    Var106(SRL_instructionVar106),
    Var107(SRL_instructionVar107),
    Var108(SUB_instructionVar108),
    Var109(SUB_instructionVar109),
    Var110(SUB_instructionVar110),
    Var111(SUB_instructionVar111),
    Var112(SUB_instructionVar112),
    Var113(SUB_instructionVar113),
    Var114(SUB_instructionVar114),
    Var115(XRL_instructionVar115),
    Var116(XRL_instructionVar116),
    Var117(XRL_instructionVar117),
    Var118(XRL_instructionVar118),
    Var119(XRL_instructionVar119),
    Var120(XRL_instructionVar120),
    Var121(DEC_instructionVar121),
    Var122(DEC_instructionVar122),
    Var123(DEC_instructionVar123),
    Var124(INC_instructionVar124),
    Var125(INC_instructionVar125),
    Var126(INC_instructionVar126),
    Var127(instructionVar127),
    Var128(ACALL_instructionVar128),
    Var129(ADD_instructionVar129),
    Var130(ADD_instructionVar130),
    Var131(ADDC_instructionVar131),
    Var132(ADDC_instructionVar132),
    Var133(ANL_instructionVar133),
    Var134(ANL_instructionVar134),
    Var135(ANL_instructionVar135),
    Var136(ANL_instructionVar136),
    Var137(ANL_instructionVar137),
    Var138(ANL_instructionVar138),
    Var139(CJNE_instructionVar139),
    Var140(CJNE_instructionVar140),
    Var141(CLR_instructionVar141),
    Var142(CLR_instructionVar142),
    Var143(CLR_instructionVar143),
    Var144(CPL_instructionVar144),
    Var145(CPL_instructionVar145),
    Var146(CPL_instructionVar146),
    Var147(DA_instructionVar147),
    Var148(DEC_instructionVar148),
    Var149(DEC_instructionVar149),
    Var150(DIV_instructionVar150),
    Var151(DJNZ_instructionVar151),
    Var152(INC_instructionVar152),
    Var153(INC_instructionVar153),
    Var154(INC_instructionVar154),
    Var155(JB_instructionVar155),
    Var156(JBC_instructionVar156),
    Var157(JC_instructionVar157),
    Var158(JMP_instructionVar158),
    Var159(JNB_instructionVar159),
    Var160(JNC_instructionVar160),
    Var161(JNZ_instructionVar161),
    Var162(JZ_instructionVar162),
    Var163(LCALL_instructionVar163),
    Var164(LJMP_instructionVar164),
    Var165(MOV_instructionVar165),
    Var166(MOV_instructionVar166),
    Var167(MOV_instructionVar167),
    Var168(MOV_instructionVar168),
    Var169(MOV_instructionVar169),
    Var170(MOV_instructionVar170),
    Var171(MOV_instructionVar171),
    Var172(MOV_instructionVar172),
    Var173(MOVC_instructionVar173),
    Var174(MOVC_instructionVar174),
    Var175(MOVX_instructionVar175),
    Var176(MOVX_instructionVar176),
    Var177(MUL_instructionVar177),
    Var178(NOP_instructionVar178),
    Var179(ORL_instructionVar179),
    Var180(ORL_instructionVar180),
    Var181(ORL_instructionVar181),
    Var182(ORL_instructionVar182),
    Var183(ORL_instructionVar183),
    Var184(ORL_instructionVar184),
    Var185(POP_instructionVar185),
    Var186(PUSH_instructionVar186),
    Var187(RET_instructionVar187),
    Var188(RETI_instructionVar188),
    Var189(RL_instructionVar189),
    Var190(RLC_instructionVar190),
    Var191(RR_instructionVar191),
    Var192(RRC_instructionVar192),
    Var193(SETB_instructionVar193),
    Var194(SETB_instructionVar194),
    Var195(SJMP_instructionVar195),
    Var196(SUBB_instructionVar196),
    Var197(SUBB_instructionVar197),
    Var198(SWAP_instructionVar198),
    Var199(XCH_instructionVar199),
    Var200(XRL_instructionVar200),
    Var201(XRL_instructionVar201),
    Var202(XRL_instructionVar202),
    Var203(XRL_instructionVar203),
    Var204(ADD_instructionVar204),
    Var205(ADD_instructionVar205),
    Var206(ADD_instructionVar206),
    Var207(ANL_instructionVar207),
    Var208(ANL_instructionVar208),
    Var209(CMP_instructionVar209),
    Var210(CMP_instructionVar210),
    Var211(CMP_instructionVar211),
    Var212(DIV_instructionVar212),
    Var213(DIV_instructionVar213),
    Var214(ECALL_instructionVar214),
    Var215(EJMP_instructionVar215),
    Var216(ERET_instructionVar216),
    Var217(JE_instructionVar217),
    Var218(JG_instructionVar218),
    Var219(JLE_instructionVar219),
    Var220(JNE_instructionVar220),
    Var221(JSG_instructionVar221),
    Var222(JSGE_instructionVar222),
    Var223(JSL_instructionVar223),
    Var224(JSLE_instructionVar224),
    Var225(MOV_instructionVar225),
    Var226(MOV_instructionVar226),
    Var227(MOV_instructionVar227),
    Var228(MOV_instructionVar228),
    Var229(MOV_instructionVar229),
    Var230(MOV_instructionVar230),
    Var231(MOV_instructionVar231),
    Var232(MOV_instructionVar232),
    Var233(MOV_instructionVar233),
    Var234(MOV_instructionVar234),
    Var235(MOV_instructionVar235),
    Var236(MOVZ_instructionVar236),
    Var237(MOVZ_instructionVar237),
    Var238(MUL_instructionVar238),
    Var239(MUL_instructionVar239),
    Var240(ORL_instructionVar240),
    Var241(ORL_instructionVar241),
    Var242(SUB_instructionVar242),
    Var243(SUB_instructionVar243),
    Var244(SUB_instructionVar244),
    Var245(XRL_instructionVar245),
    Var246(XRL_instructionVar246),
    Var247(ADD_instructionVar247),
    Var248(ADDC_instructionVar248),
    Var249(ANL_instructionVar249),
    Var250(CJNE_instructionVar250),
    Var251(DEC_instructionVar251),
    Var252(INC_instructionVar252),
    Var253(MOV_instructionVar253),
    Var254(MOV_instructionVar254),
    Var255(MOV_instructionVar255),
    Var256(MOV_instructionVar256),
    Var257(MOV_instructionVar257),
    Var258(MOVX_instructionVar258),
    Var259(MOVX_instructionVar259),
    Var260(ORL_instructionVar260),
    Var261(SUBB_instructionVar261),
    Var262(XCH_instructionVar262),
    Var263(XCHD_instructionVar263),
    Var264(XRL_instructionVar264),
    Var265(ADD_instructionVar265),
    Var266(ADDC_instructionVar266),
    Var267(AJMP_instructionVar267),
    Var268(ANL_instructionVar268),
    Var269(CJNE_instructionVar269),
    Var270(DEC_instructionVar270),
    Var271(DJNZ_instructionVar271),
    Var272(INC_instructionVar272),
    Var273(MOV_instructionVar273),
    Var274(MOV_instructionVar274),
    Var275(MOV_instructionVar275),
    Var276(MOV_instructionVar276),
    Var277(MOV_instructionVar277),
    Var278(ORL_instructionVar278),
    Var279(SUBB_instructionVar279),
    Var280(XCH_instructionVar280),
    Var281(XRL_instructionVar281),
    Var282(instructionVar282),
}
impl Tableinstruction {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var18(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var19(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var20(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var21(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var22(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var23(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var24(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var25(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var26(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var27(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var28(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var29(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var30(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var31(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var32(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var33(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var34(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var35(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var36(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var37(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var38(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var39(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var40(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var41(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var42(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var43(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var44(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var45(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var46(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var47(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var48(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var49(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var50(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var51(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var52(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var53(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var54(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var55(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var56(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var57(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var58(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var59(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var60(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var61(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var62(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var63(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var64(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var65(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var66(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var67(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var68(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var69(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var70(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var71(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var72(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var73(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var74(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var75(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var76(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var77(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var78(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var79(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var80(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var81(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var82(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var83(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var84(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var85(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var86(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var87(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var88(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var89(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var90(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var91(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var92(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var93(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var94(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var95(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var96(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var97(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var98(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var99(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var100(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var101(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var102(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var103(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var104(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var105(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var106(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var107(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var108(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var109(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var110(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var111(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var112(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var113(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var114(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var115(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var116(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var117(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var118(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var119(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var120(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var121(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var122(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var123(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var124(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var125(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var126(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var127(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var128(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var129(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var130(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var131(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var132(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var133(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var134(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var135(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var136(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var137(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var138(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var139(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var140(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var141(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var142(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var143(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var144(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var145(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var146(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var147(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var148(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var149(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var150(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var151(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var152(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var153(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var154(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var155(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var156(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var157(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var158(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var159(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var160(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var161(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var162(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var163(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var164(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var165(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var166(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var167(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var168(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var169(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var170(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var171(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var172(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var173(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var174(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var175(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var176(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var177(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var178(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var179(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var180(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var181(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var182(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var183(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var184(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var185(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var186(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var187(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var188(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var189(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var190(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var191(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var192(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var193(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var194(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var195(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var196(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var197(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var198(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var199(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var200(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var201(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var202(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var203(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var204(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var205(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var206(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var207(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var208(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var209(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var210(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var211(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var212(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var213(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var214(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var215(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var216(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var217(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var218(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var219(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var220(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var221(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var222(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var223(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var224(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var225(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var226(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var227(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var228(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var229(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var230(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var231(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var232(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var233(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var234(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var235(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var236(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var237(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var238(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var239(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var240(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var241(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var242(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var243(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var244(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var245(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var246(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var247(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var248(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var249(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var250(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var251(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var252(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var253(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var254(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var255(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var256(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var257(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var258(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var259(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var260(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var261(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var262(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var263(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var264(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var265(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var266(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var267(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var268(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var269(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var270(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var271(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var272(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var273(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var274(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var275(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var276(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var277(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var278(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var279(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var280(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var281(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var282(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = PUSH_instructionVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = PUSH_instructionVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = ANL_instructionVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = ANL_instructionVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = CLR_instructionVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = CPL_instructionVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = JB_instructionVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = JBC_instructionVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) = JNB_instructionVar8::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar9::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar10::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) = ORL_instructionVar11::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) = ORL_instructionVar12::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) = SETB_instructionVar13::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) = ANL_instructionVar14::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) = ANL_instructionVar15::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) = CLR_instructionVar16::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) = CPL_instructionVar17::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        if let Some((inst_len, parsed)) = JB_instructionVar18::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var18(parsed)));
        }
        if let Some((inst_len, parsed)) = JBC_instructionVar19::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var19(parsed)));
        }
        if let Some((inst_len, parsed)) = JNB_instructionVar20::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var20(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar21::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var21(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar22::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var22(parsed)));
        }
        if let Some((inst_len, parsed)) = ORL_instructionVar23::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var23(parsed)));
        }
        if let Some((inst_len, parsed)) = ORL_instructionVar24::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var24(parsed)));
        }
        if let Some((inst_len, parsed)) = SETB_instructionVar25::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var25(parsed)));
        }
        if let Some((inst_len, parsed)) = ADD_instructionVar26::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var26(parsed)));
        }
        if let Some((inst_len, parsed)) = ADD_instructionVar27::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var27(parsed)));
        }
        if let Some((inst_len, parsed)) = ANL_instructionVar28::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var28(parsed)));
        }
        if let Some((inst_len, parsed)) = ANL_instructionVar29::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var29(parsed)));
        }
        if let Some((inst_len, parsed)) = CMP_instructionVar30::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var30(parsed)));
        }
        if let Some((inst_len, parsed)) = CMP_instructionVar31::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var31(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar32::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var32(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar33::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var33(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar34::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var34(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar35::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var35(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar36::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var36(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar37::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var37(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar38::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var38(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar39::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var39(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar40::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var40(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar41::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var41(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar42::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var42(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar43::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var43(parsed)));
        }
        if let Some((inst_len, parsed)) = ORL_instructionVar44::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var44(parsed)));
        }
        if let Some((inst_len, parsed)) = ORL_instructionVar45::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var45(parsed)));
        }
        if let Some((inst_len, parsed)) = SUB_instructionVar46::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var46(parsed)));
        }
        if let Some((inst_len, parsed)) = SUB_instructionVar47::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var47(parsed)));
        }
        if let Some((inst_len, parsed)) = XRL_instructionVar48::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var48(parsed)));
        }
        if let Some((inst_len, parsed)) = XRL_instructionVar49::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var49(parsed)));
        }
        if let Some((inst_len, parsed)) = ADD_instructionVar50::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var50(parsed)));
        }
        if let Some((inst_len, parsed)) = ADD_instructionVar51::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var51(parsed)));
        }
        if let Some((inst_len, parsed)) = ADD_instructionVar52::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var52(parsed)));
        }
        if let Some((inst_len, parsed)) = ADD_instructionVar53::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var53(parsed)));
        }
        if let Some((inst_len, parsed)) = ADD_instructionVar54::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var54(parsed)));
        }
        if let Some((inst_len, parsed)) = ADD_instructionVar55::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var55(parsed)));
        }
        if let Some((inst_len, parsed)) = ADD_instructionVar56::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var56(parsed)));
        }
        if let Some((inst_len, parsed)) = ADD_instructionVar57::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var57(parsed)));
        }
        if let Some((inst_len, parsed)) = ANL_instructionVar58::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var58(parsed)));
        }
        if let Some((inst_len, parsed)) = ANL_instructionVar59::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var59(parsed)));
        }
        if let Some((inst_len, parsed)) = ANL_instructionVar60::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var60(parsed)));
        }
        if let Some((inst_len, parsed)) = ANL_instructionVar61::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var61(parsed)));
        }
        if let Some((inst_len, parsed)) = ANL_instructionVar62::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var62(parsed)));
        }
        if let Some((inst_len, parsed)) = CMP_instructionVar63::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var63(parsed)));
        }
        if let Some((inst_len, parsed)) = CMP_instructionVar64::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var64(parsed)));
        }
        if let Some((inst_len, parsed)) = CMP_instructionVar65::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var65(parsed)));
        }
        if let Some((inst_len, parsed)) = CMP_instructionVar66::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var66(parsed)));
        }
        if let Some((inst_len, parsed)) = CMP_instructionVar67::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var67(parsed)));
        }
        if let Some((inst_len, parsed)) = CMP_instructionVar68::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var68(parsed)));
        }
        if let Some((inst_len, parsed)) = CMP_instructionVar69::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var69(parsed)));
        }
        if let Some((inst_len, parsed)) = CMP_instructionVar70::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var70(parsed)));
        }
        if let Some((inst_len, parsed)) = ECALL_instructionVar71::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var71(parsed)));
        }
        if let Some((inst_len, parsed)) = EJMP_instructionVar72::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var72(parsed)));
        }
        if let Some((inst_len, parsed)) = LCALL_instructionVar73::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var73(parsed)));
        }
        if let Some((inst_len, parsed)) = LJMP_instructionVar74::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var74(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar75::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var75(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar76::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var76(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar77::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var77(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar78::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var78(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar79::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var79(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar80::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var80(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar81::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var81(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar82::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var82(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar83::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var83(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar84::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var84(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar85::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var85(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar86::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var86(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar87::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var87(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar88::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var88(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVH_instructionVar89::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var89(parsed)));
        }
        if let Some((inst_len, parsed)) = ORL_instructionVar90::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var90(parsed)));
        }
        if let Some((inst_len, parsed)) = ORL_instructionVar91::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var91(parsed)));
        }
        if let Some((inst_len, parsed)) = ORL_instructionVar92::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var92(parsed)));
        }
        if let Some((inst_len, parsed)) = ORL_instructionVar93::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var93(parsed)));
        }
        if let Some((inst_len, parsed)) = ORL_instructionVar94::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var94(parsed)));
        }
        if let Some((inst_len, parsed)) = ORL_instructionVar95::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var95(parsed)));
        }
        if let Some((inst_len, parsed)) = POP_instructionVar96::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var96(parsed)));
        }
        if let Some((inst_len, parsed)) = POP_instructionVar97::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var97(parsed)));
        }
        if let Some((inst_len, parsed)) = POP_instructionVar98::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var98(parsed)));
        }
        if let Some((inst_len, parsed)) = PUSH_instructionVar99::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var99(parsed)));
        }
        if let Some((inst_len, parsed)) = PUSH_instructionVar100::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var100(parsed)));
        }
        if let Some((inst_len, parsed)) = PUSH_instructionVar101::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var101(parsed)));
        }
        if let Some((inst_len, parsed)) = SLL_instructionVar102::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var102(parsed)));
        }
        if let Some((inst_len, parsed)) = SLL_instructionVar103::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var103(parsed)));
        }
        if let Some((inst_len, parsed)) = SRA_instructionVar104::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var104(parsed)));
        }
        if let Some((inst_len, parsed)) = SRA_instructionVar105::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var105(parsed)));
        }
        if let Some((inst_len, parsed)) = SRL_instructionVar106::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var106(parsed)));
        }
        if let Some((inst_len, parsed)) = SRL_instructionVar107::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var107(parsed)));
        }
        if let Some((inst_len, parsed)) = SUB_instructionVar108::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var108(parsed)));
        }
        if let Some((inst_len, parsed)) = SUB_instructionVar109::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var109(parsed)));
        }
        if let Some((inst_len, parsed)) = SUB_instructionVar110::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var110(parsed)));
        }
        if let Some((inst_len, parsed)) = SUB_instructionVar111::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var111(parsed)));
        }
        if let Some((inst_len, parsed)) = SUB_instructionVar112::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var112(parsed)));
        }
        if let Some((inst_len, parsed)) = SUB_instructionVar113::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var113(parsed)));
        }
        if let Some((inst_len, parsed)) = SUB_instructionVar114::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var114(parsed)));
        }
        if let Some((inst_len, parsed)) = XRL_instructionVar115::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var115(parsed)));
        }
        if let Some((inst_len, parsed)) = XRL_instructionVar116::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var116(parsed)));
        }
        if let Some((inst_len, parsed)) = XRL_instructionVar117::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var117(parsed)));
        }
        if let Some((inst_len, parsed)) = XRL_instructionVar118::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var118(parsed)));
        }
        if let Some((inst_len, parsed)) = XRL_instructionVar119::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var119(parsed)));
        }
        if let Some((inst_len, parsed)) = XRL_instructionVar120::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var120(parsed)));
        }
        if let Some((inst_len, parsed)) = DEC_instructionVar121::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var121(parsed)));
        }
        if let Some((inst_len, parsed)) = DEC_instructionVar122::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var122(parsed)));
        }
        if let Some((inst_len, parsed)) = DEC_instructionVar123::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var123(parsed)));
        }
        if let Some((inst_len, parsed)) = INC_instructionVar124::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var124(parsed)));
        }
        if let Some((inst_len, parsed)) = INC_instructionVar125::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var125(parsed)));
        }
        if let Some((inst_len, parsed)) = INC_instructionVar126::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var126(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar127::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var127(parsed)));
        }
        if let Some((inst_len, parsed)) = ACALL_instructionVar128::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var128(parsed)));
        }
        if let Some((inst_len, parsed)) = ADD_instructionVar129::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var129(parsed)));
        }
        if let Some((inst_len, parsed)) = ADD_instructionVar130::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var130(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDC_instructionVar131::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var131(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDC_instructionVar132::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var132(parsed)));
        }
        if let Some((inst_len, parsed)) = ANL_instructionVar133::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var133(parsed)));
        }
        if let Some((inst_len, parsed)) = ANL_instructionVar134::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var134(parsed)));
        }
        if let Some((inst_len, parsed)) = ANL_instructionVar135::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var135(parsed)));
        }
        if let Some((inst_len, parsed)) = ANL_instructionVar136::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var136(parsed)));
        }
        if let Some((inst_len, parsed)) = ANL_instructionVar137::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var137(parsed)));
        }
        if let Some((inst_len, parsed)) = ANL_instructionVar138::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var138(parsed)));
        }
        if let Some((inst_len, parsed)) = CJNE_instructionVar139::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var139(parsed)));
        }
        if let Some((inst_len, parsed)) = CJNE_instructionVar140::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var140(parsed)));
        }
        if let Some((inst_len, parsed)) = CLR_instructionVar141::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var141(parsed)));
        }
        if let Some((inst_len, parsed)) = CLR_instructionVar142::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var142(parsed)));
        }
        if let Some((inst_len, parsed)) = CLR_instructionVar143::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var143(parsed)));
        }
        if let Some((inst_len, parsed)) = CPL_instructionVar144::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var144(parsed)));
        }
        if let Some((inst_len, parsed)) = CPL_instructionVar145::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var145(parsed)));
        }
        if let Some((inst_len, parsed)) = CPL_instructionVar146::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var146(parsed)));
        }
        if let Some((inst_len, parsed)) = DA_instructionVar147::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var147(parsed)));
        }
        if let Some((inst_len, parsed)) = DEC_instructionVar148::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var148(parsed)));
        }
        if let Some((inst_len, parsed)) = DEC_instructionVar149::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var149(parsed)));
        }
        if let Some((inst_len, parsed)) = DIV_instructionVar150::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var150(parsed)));
        }
        if let Some((inst_len, parsed)) = DJNZ_instructionVar151::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var151(parsed)));
        }
        if let Some((inst_len, parsed)) = INC_instructionVar152::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var152(parsed)));
        }
        if let Some((inst_len, parsed)) = INC_instructionVar153::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var153(parsed)));
        }
        if let Some((inst_len, parsed)) = INC_instructionVar154::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var154(parsed)));
        }
        if let Some((inst_len, parsed)) = JB_instructionVar155::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var155(parsed)));
        }
        if let Some((inst_len, parsed)) = JBC_instructionVar156::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var156(parsed)));
        }
        if let Some((inst_len, parsed)) = JC_instructionVar157::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var157(parsed)));
        }
        if let Some((inst_len, parsed)) = JMP_instructionVar158::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var158(parsed)));
        }
        if let Some((inst_len, parsed)) = JNB_instructionVar159::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var159(parsed)));
        }
        if let Some((inst_len, parsed)) = JNC_instructionVar160::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var160(parsed)));
        }
        if let Some((inst_len, parsed)) = JNZ_instructionVar161::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var161(parsed)));
        }
        if let Some((inst_len, parsed)) = JZ_instructionVar162::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var162(parsed)));
        }
        if let Some((inst_len, parsed)) = LCALL_instructionVar163::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var163(parsed)));
        }
        if let Some((inst_len, parsed)) = LJMP_instructionVar164::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var164(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar165::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var165(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar166::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var166(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar167::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var167(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar168::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var168(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar169::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var169(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar170::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var170(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar171::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var171(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar172::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var172(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVC_instructionVar173::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var173(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVC_instructionVar174::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var174(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVX_instructionVar175::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var175(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVX_instructionVar176::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var176(parsed)));
        }
        if let Some((inst_len, parsed)) = MUL_instructionVar177::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var177(parsed)));
        }
        if let Some((inst_len, parsed)) = NOP_instructionVar178::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var178(parsed)));
        }
        if let Some((inst_len, parsed)) = ORL_instructionVar179::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var179(parsed)));
        }
        if let Some((inst_len, parsed)) = ORL_instructionVar180::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var180(parsed)));
        }
        if let Some((inst_len, parsed)) = ORL_instructionVar181::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var181(parsed)));
        }
        if let Some((inst_len, parsed)) = ORL_instructionVar182::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var182(parsed)));
        }
        if let Some((inst_len, parsed)) = ORL_instructionVar183::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var183(parsed)));
        }
        if let Some((inst_len, parsed)) = ORL_instructionVar184::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var184(parsed)));
        }
        if let Some((inst_len, parsed)) = POP_instructionVar185::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var185(parsed)));
        }
        if let Some((inst_len, parsed)) = PUSH_instructionVar186::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var186(parsed)));
        }
        if let Some((inst_len, parsed)) = RET_instructionVar187::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var187(parsed)));
        }
        if let Some((inst_len, parsed)) = RETI_instructionVar188::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var188(parsed)));
        }
        if let Some((inst_len, parsed)) = RL_instructionVar189::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var189(parsed)));
        }
        if let Some((inst_len, parsed)) = RLC_instructionVar190::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var190(parsed)));
        }
        if let Some((inst_len, parsed)) = RR_instructionVar191::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var191(parsed)));
        }
        if let Some((inst_len, parsed)) = RRC_instructionVar192::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var192(parsed)));
        }
        if let Some((inst_len, parsed)) = SETB_instructionVar193::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var193(parsed)));
        }
        if let Some((inst_len, parsed)) = SETB_instructionVar194::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var194(parsed)));
        }
        if let Some((inst_len, parsed)) = SJMP_instructionVar195::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var195(parsed)));
        }
        if let Some((inst_len, parsed)) = SUBB_instructionVar196::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var196(parsed)));
        }
        if let Some((inst_len, parsed)) = SUBB_instructionVar197::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var197(parsed)));
        }
        if let Some((inst_len, parsed)) = SWAP_instructionVar198::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var198(parsed)));
        }
        if let Some((inst_len, parsed)) = XCH_instructionVar199::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var199(parsed)));
        }
        if let Some((inst_len, parsed)) = XRL_instructionVar200::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var200(parsed)));
        }
        if let Some((inst_len, parsed)) = XRL_instructionVar201::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var201(parsed)));
        }
        if let Some((inst_len, parsed)) = XRL_instructionVar202::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var202(parsed)));
        }
        if let Some((inst_len, parsed)) = XRL_instructionVar203::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var203(parsed)));
        }
        if let Some((inst_len, parsed)) = ADD_instructionVar204::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var204(parsed)));
        }
        if let Some((inst_len, parsed)) = ADD_instructionVar205::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var205(parsed)));
        }
        if let Some((inst_len, parsed)) = ADD_instructionVar206::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var206(parsed)));
        }
        if let Some((inst_len, parsed)) = ANL_instructionVar207::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var207(parsed)));
        }
        if let Some((inst_len, parsed)) = ANL_instructionVar208::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var208(parsed)));
        }
        if let Some((inst_len, parsed)) = CMP_instructionVar209::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var209(parsed)));
        }
        if let Some((inst_len, parsed)) = CMP_instructionVar210::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var210(parsed)));
        }
        if let Some((inst_len, parsed)) = CMP_instructionVar211::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var211(parsed)));
        }
        if let Some((inst_len, parsed)) = DIV_instructionVar212::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var212(parsed)));
        }
        if let Some((inst_len, parsed)) = DIV_instructionVar213::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var213(parsed)));
        }
        if let Some((inst_len, parsed)) = ECALL_instructionVar214::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var214(parsed)));
        }
        if let Some((inst_len, parsed)) = EJMP_instructionVar215::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var215(parsed)));
        }
        if let Some((inst_len, parsed)) = ERET_instructionVar216::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var216(parsed)));
        }
        if let Some((inst_len, parsed)) = JE_instructionVar217::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var217(parsed)));
        }
        if let Some((inst_len, parsed)) = JG_instructionVar218::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var218(parsed)));
        }
        if let Some((inst_len, parsed)) = JLE_instructionVar219::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var219(parsed)));
        }
        if let Some((inst_len, parsed)) = JNE_instructionVar220::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var220(parsed)));
        }
        if let Some((inst_len, parsed)) = JSG_instructionVar221::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var221(parsed)));
        }
        if let Some((inst_len, parsed)) = JSGE_instructionVar222::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var222(parsed)));
        }
        if let Some((inst_len, parsed)) = JSL_instructionVar223::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var223(parsed)));
        }
        if let Some((inst_len, parsed)) = JSLE_instructionVar224::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var224(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar225::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var225(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar226::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var226(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar227::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var227(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar228::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var228(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar229::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var229(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar230::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var230(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar231::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var231(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar232::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var232(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar233::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var233(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar234::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var234(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar235::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var235(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVZ_instructionVar236::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var236(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVZ_instructionVar237::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var237(parsed)));
        }
        if let Some((inst_len, parsed)) = MUL_instructionVar238::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var238(parsed)));
        }
        if let Some((inst_len, parsed)) = MUL_instructionVar239::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var239(parsed)));
        }
        if let Some((inst_len, parsed)) = ORL_instructionVar240::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var240(parsed)));
        }
        if let Some((inst_len, parsed)) = ORL_instructionVar241::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var241(parsed)));
        }
        if let Some((inst_len, parsed)) = SUB_instructionVar242::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var242(parsed)));
        }
        if let Some((inst_len, parsed)) = SUB_instructionVar243::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var243(parsed)));
        }
        if let Some((inst_len, parsed)) = SUB_instructionVar244::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var244(parsed)));
        }
        if let Some((inst_len, parsed)) = XRL_instructionVar245::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var245(parsed)));
        }
        if let Some((inst_len, parsed)) = XRL_instructionVar246::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var246(parsed)));
        }
        if let Some((inst_len, parsed)) = ADD_instructionVar247::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var247(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDC_instructionVar248::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var248(parsed)));
        }
        if let Some((inst_len, parsed)) = ANL_instructionVar249::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var249(parsed)));
        }
        if let Some((inst_len, parsed)) = CJNE_instructionVar250::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var250(parsed)));
        }
        if let Some((inst_len, parsed)) = DEC_instructionVar251::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var251(parsed)));
        }
        if let Some((inst_len, parsed)) = INC_instructionVar252::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var252(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar253::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var253(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar254::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var254(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar255::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var255(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar256::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var256(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar257::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var257(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVX_instructionVar258::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var258(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVX_instructionVar259::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var259(parsed)));
        }
        if let Some((inst_len, parsed)) = ORL_instructionVar260::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var260(parsed)));
        }
        if let Some((inst_len, parsed)) = SUBB_instructionVar261::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var261(parsed)));
        }
        if let Some((inst_len, parsed)) = XCH_instructionVar262::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var262(parsed)));
        }
        if let Some((inst_len, parsed)) = XCHD_instructionVar263::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var263(parsed)));
        }
        if let Some((inst_len, parsed)) = XRL_instructionVar264::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var264(parsed)));
        }
        if let Some((inst_len, parsed)) = ADD_instructionVar265::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var265(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDC_instructionVar266::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var266(parsed)));
        }
        if let Some((inst_len, parsed)) = AJMP_instructionVar267::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var267(parsed)));
        }
        if let Some((inst_len, parsed)) = ANL_instructionVar268::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var268(parsed)));
        }
        if let Some((inst_len, parsed)) = CJNE_instructionVar269::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var269(parsed)));
        }
        if let Some((inst_len, parsed)) = DEC_instructionVar270::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var270(parsed)));
        }
        if let Some((inst_len, parsed)) = DJNZ_instructionVar271::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var271(parsed)));
        }
        if let Some((inst_len, parsed)) = INC_instructionVar272::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var272(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar273::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var273(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar274::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var274(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar275::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var275(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar276::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var276(parsed)));
        }
        if let Some((inst_len, parsed)) = MOV_instructionVar277::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var277(parsed)));
        }
        if let Some((inst_len, parsed)) = ORL_instructionVar278::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var278(parsed)));
        }
        if let Some((inst_len, parsed)) = SUBB_instructionVar279::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var279(parsed)));
        }
        if let Some((inst_len, parsed)) = XCH_instructionVar280::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var280(parsed)));
        }
        if let Some((inst_len, parsed)) = XRL_instructionVar281::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var281(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar282::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var282(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:507:1, end:507:3))"]
#[derive(Clone, Debug)]
struct CYVar0 {}
impl CYVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("CY")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableCY {
    Var0(CYVar0),
}
impl TableCY {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            CYVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:509:1, end:509:5))"]
#[derive(Clone, Debug)]
struct AregVar0 {}
impl AregVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("A")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let ophi = token_parser.TokenFieldophi();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableAreg {
    Var0(AregVar0),
}
impl TableAreg {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            AregVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:510:1, end:510:6))"]
#[derive(Clone, Debug)]
struct ABregVar0 {}
impl ABregVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::AB)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let ophi = token_parser.TokenFieldophi();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableABreg {
    Var0(ABregVar0),
}
impl TableABreg {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ABregVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:511:1, end:511:8))"]
#[derive(Clone, Debug)]
struct DPTRregVar0 {}
impl DPTRregVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::DPTR)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let ophi = token_parser.TokenFieldophi();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableDPTRreg {
    Var0(DPTRregVar0),
}
impl TableDPTRreg {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            DPTRregVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:514:1, end:514:6))"]
#[derive(Clone, Debug)]
struct ADPTRVar0 {}
impl ADPTRVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("@A+"),
            DisplayElement::Register(Register::DPTR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let ophi = token_parser.TokenFieldophi();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableADPTR {
    Var0(ADPTRVar0),
}
impl TableADPTR {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ADPTRVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:523:1, end:523:4))"]
#[derive(Clone, Debug)]
struct APCVar0 {}
impl APCVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("@A+PC")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableAPC {
    Var0(APCVar0),
}
impl TableAPC {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            APCVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:526:1, end:526:7))"]
#[derive(Clone, Debug)]
struct ATDPTRVar0 {}
impl ATDPTRVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("@"),
            DisplayElement::Register(Register::DPTR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let ophi = token_parser.TokenFieldophi();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableATDPTR {
    Var0(ATDPTRVar0),
}
impl TableATDPTR {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ATDPTRVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:536:1, end:536:3))"]
#[derive(Clone, Debug)]
struct RiVar0 {
    ri: TokenField_ri,
}
impl RiVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("@"), self.ri.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let ri = token_parser.TokenFieldri();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ri }))
    }
}
#[derive(Clone, Debug)]
enum TableRi {
    Var0(RiVar0),
}
impl TableRi {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            RiVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:544:1, end:544:4))"]
#[derive(Clone, Debug)]
struct RiXVar0 {
    ri: TokenField_ri,
}
impl RiXVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("@"), self.ri.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let ri = token_parser.TokenFieldri();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ri }))
    }
}
#[derive(Clone, Debug)]
enum TableRiX {
    Var0(RiXVar0),
}
impl TableRiX {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            RiXVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:553:1, end:553:5))"]
#[derive(Clone, Debug)]
struct DataVar0 {
    data: TokenField_data,
}
impl DataVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.data.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let data = token_parser.TokenFielddata();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { data }))
    }
}
#[derive(Clone, Debug)]
enum TableData {
    Var0(DataVar0),
}
impl TableData {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            DataVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:554:1, end:554:7))"]
#[derive(Clone, Debug)]
struct Data16Var0 {
    data16: TokenField_data16,
}
impl Data16Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.data16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let data16 = token_parser.TokenFielddata16();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { data16 }))
    }
}
#[derive(Clone, Debug)]
enum TableData16 {
    Var0(Data16Var0),
}
impl TableData16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Data16Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:567:1, end:567:7))"]
#[derive(Clone, Debug)]
struct DirectVar0 {}
impl DirectVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::PSW)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbank().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFielddirect().disassembly() != 208i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:568:1, end:568:7))"]
#[derive(Clone, Debug)]
struct DirectVar1 {}
impl DirectVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("A")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbank().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFielddirect().disassembly() != 224i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:569:1, end:569:7))"]
#[derive(Clone, Debug)]
struct DirectVar2 {}
impl DirectVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::B)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbank().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFielddirect().disassembly() != 240i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:570:1, end:570:7))"]
#[derive(Clone, Debug)]
struct DirectVar3 {}
impl DirectVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::DPL)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbank().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFielddirect().disassembly() != 130i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:571:1, end:571:7))"]
#[derive(Clone, Debug)]
struct DirectVar4 {}
impl DirectVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::DPH)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbank().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFielddirect().disassembly() != 131i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:576:1, end:576:7))"]
#[derive(Clone, Debug)]
struct DirectVar5 {}
impl DirectVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::DPXL)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbank().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFielddirect().disassembly() != 132i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:560:1, end:560:7))"]
#[derive(Clone, Debug)]
struct DirectVar6 {
    mainreg: TokenField_mainreg,
}
impl DirectVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.mainreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbank().disassembly() != 0i128 {
            return None;
        }
        let mainreg = token_parser.TokenFieldmainreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mainreg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:566:1, end:566:7))"]
#[derive(Clone, Debug)]
struct DirectVar7 {
    direct: TokenField_direct,
}
impl DirectVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.direct.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbank().disassembly() != 1i128 {
            return None;
        }
        let direct = token_parser.TokenFielddirect();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { direct }))
    }
}
#[derive(Clone, Debug)]
enum TableDirect {
    Var0(DirectVar0),
    Var1(DirectVar1),
    Var2(DirectVar2),
    Var3(DirectVar3),
    Var4(DirectVar4),
    Var5(DirectVar5),
    Var6(DirectVar6),
    Var7(DirectVar7),
}
impl TableDirect {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            DirectVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            DirectVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            DirectVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            DirectVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            DirectVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            DirectVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            DirectVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            DirectVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:587:1, end:587:8))"]
#[derive(Clone, Debug)]
struct Direct2Var0 {}
impl Direct2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::PSW)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbank2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFielddirect2().disassembly() != 208i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:588:1, end:588:8))"]
#[derive(Clone, Debug)]
struct Direct2Var1 {}
impl Direct2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("A")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbank2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFielddirect2().disassembly() != 224i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:589:1, end:589:8))"]
#[derive(Clone, Debug)]
struct Direct2Var2 {}
impl Direct2Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::B)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbank2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFielddirect2().disassembly() != 240i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:590:1, end:590:8))"]
#[derive(Clone, Debug)]
struct Direct2Var3 {}
impl Direct2Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::DPL)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbank2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFielddirect2().disassembly() != 130i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:591:1, end:591:8))"]
#[derive(Clone, Debug)]
struct Direct2Var4 {}
impl Direct2Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::DPH)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbank2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFielddirect2().disassembly() != 131i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:596:1, end:596:8))"]
#[derive(Clone, Debug)]
struct Direct2Var5 {}
impl Direct2Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::DPXL)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbank2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFielddirect2().disassembly() != 132i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:580:1, end:580:8))"]
#[derive(Clone, Debug)]
struct Direct2Var6 {
    mainreg2: TokenField_mainreg2,
}
impl Direct2Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.mainreg2.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbank2().disassembly() != 0i128 {
            return None;
        }
        let mainreg2 = token_parser.TokenFieldmainreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mainreg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:586:1, end:586:8))"]
#[derive(Clone, Debug)]
struct Direct2Var7 {
    direct2: TokenField_direct2,
}
impl Direct2Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.direct2.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbank2().disassembly() != 1i128 {
            return None;
        }
        let direct2 = token_parser.TokenFielddirect2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { direct2 }))
    }
}
#[derive(Clone, Debug)]
enum TableDirect2 {
    Var0(Direct2Var0),
    Var1(Direct2Var1),
    Var2(Direct2Var2),
    Var3(Direct2Var3),
    Var4(Direct2Var4),
    Var5(Direct2Var5),
    Var6(Direct2Var6),
    Var7(Direct2Var7),
}
impl TableDirect2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Direct2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Direct2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Direct2Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Direct2Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Direct2Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Direct2Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Direct2Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Direct2Var7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:600:1, end:600:8))"]
#[derive(Clone, Debug)]
struct BitAddrVar0 {
    sfrbyte: TokenField_sfrbyte,
    sfrbit: TokenField_sfrbit,
}
impl BitAddrVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_bitaddr: i128 = 0;
        calc_bitaddr = u32::try_from(6i128)
            .ok()
            .map(|shl| self.sfrbyte.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            .wrapping_add(self.sfrbit.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_bitaddr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_bitaddr: i128 = 0;
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbitbank().disassembly() != 1i128 {
            return None;
        }
        calc_bitaddr = u32::try_from(6i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldsfrbyte()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            .wrapping_add(token_parser.TokenFieldsfrbit().disassembly());
        let sfrbyte = token_parser.TokenFieldsfrbyte();
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sfrbyte, sfrbit }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:601:1, end:601:8))"]
#[derive(Clone, Debug)]
struct BitAddrVar1 {
    lowbyte: TokenField_lowbyte,
    sfrbit: TokenField_sfrbit,
}
impl BitAddrVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_bitaddr: i128 = 0;
        calc_bitaddr = u32::try_from(3i128)
            .ok()
            .map(|shl| self.lowbyte.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            .wrapping_add(self.sfrbit.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_bitaddr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_bitaddr: i128 = 0;
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbitbank().disassembly() != 0i128 {
            return None;
        }
        calc_bitaddr = u32::try_from(3i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldlowbyte()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            .wrapping_add(token_parser.TokenFieldsfrbit().disassembly());
        let lowbyte = token_parser.TokenFieldlowbyte();
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lowbyte, sfrbit }))
    }
}
#[derive(Clone, Debug)]
enum TableBitAddr {
    Var0(BitAddrVar0),
    Var1(BitAddrVar1),
}
impl TableBitAddr {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            BitAddrVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            BitAddrVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:602:1, end:602:9))"]
#[derive(Clone, Debug)]
struct BitAddr2Var0 {
    sfrbyte: TokenField_sfrbyte,
    sfrbit: TokenField_sfrbit,
}
impl BitAddr2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_bitaddr: i128 = 0;
        calc_bitaddr = u32::try_from(6i128)
            .ok()
            .map(|shl| self.sfrbyte.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            .wrapping_add(self.sfrbit.disassembly());
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("/"),
            DisplayElement::Number(true, calc_bitaddr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_bitaddr: i128 = 0;
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbitbank().disassembly() != 1i128 {
            return None;
        }
        calc_bitaddr = u32::try_from(6i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldsfrbyte()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            .wrapping_add(token_parser.TokenFieldsfrbit().disassembly());
        let sfrbyte = token_parser.TokenFieldsfrbyte();
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sfrbyte, sfrbit }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:603:1, end:603:9))"]
#[derive(Clone, Debug)]
struct BitAddr2Var1 {
    lowbyte: TokenField_lowbyte,
    sfrbit: TokenField_sfrbit,
}
impl BitAddr2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_bitaddr: i128 = 0;
        calc_bitaddr = u32::try_from(3i128)
            .ok()
            .map(|shl| self.lowbyte.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            .wrapping_add(self.sfrbit.disassembly());
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("/"),
            DisplayElement::Number(true, calc_bitaddr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_bitaddr: i128 = 0;
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbitbank().disassembly() != 0i128 {
            return None;
        }
        calc_bitaddr = u32::try_from(3i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldlowbyte()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            .wrapping_add(token_parser.TokenFieldsfrbit().disassembly());
        let lowbyte = token_parser.TokenFieldlowbyte();
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lowbyte, sfrbit }))
    }
}
#[derive(Clone, Debug)]
enum TableBitAddr2 {
    Var0(BitAddr2Var0),
    Var1(BitAddr2Var1),
}
impl TableBitAddr2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            BitAddr2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            BitAddr2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:618:1, end:618:12))"]
#[derive(Clone, Debug)]
struct BitByteAddrVar0 {}
impl BitByteAddrVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("A")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbitbank().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsfrbyte().disassembly() != 28i128 {
            return None;
        }
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:619:1, end:619:12))"]
#[derive(Clone, Debug)]
struct BitByteAddrVar1 {}
impl BitByteAddrVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::B)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbitbank().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsfrbyte().disassembly() != 30i128 {
            return None;
        }
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:620:1, end:620:12))"]
#[derive(Clone, Debug)]
struct BitByteAddrVar2 {}
impl BitByteAddrVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::PSW)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbitbank().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsfrbyte().disassembly() != 26i128 {
            return None;
        }
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:617:1, end:617:12))"]
#[derive(Clone, Debug)]
struct BitByteAddrVar3 {
    sfrbyte: TokenField_sfrbyte,
}
impl BitByteAddrVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_byteaddr: i128 = 0;
        calc_byteaddr = u32::try_from(3i128)
            .ok()
            .map(|shl| self.sfrbyte.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_byteaddr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_byteaddr: i128 = 0;
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbitbank().disassembly() != 1i128 {
            return None;
        }
        calc_byteaddr = u32::try_from(3i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldsfrbyte()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0);
        let sfrbyte = token_parser.TokenFieldsfrbyte();
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sfrbyte }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:622:1, end:622:12))"]
#[derive(Clone, Debug)]
struct BitByteAddrVar4 {
    lowbyte: TokenField_lowbyte,
}
impl BitByteAddrVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_byteaddr: i128 = 0;
        calc_byteaddr = self.lowbyte.disassembly().wrapping_add(32i128);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_byteaddr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_byteaddr: i128 = 0;
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbitbank().disassembly() != 0i128 {
            return None;
        }
        calc_byteaddr = token_parser
            .TokenFieldlowbyte()
            .disassembly()
            .wrapping_add(32i128);
        let lowbyte = token_parser.TokenFieldlowbyte();
        let sfrbit = token_parser.TokenFieldsfrbit();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lowbyte }))
    }
}
#[derive(Clone, Debug)]
enum TableBitByteAddr {
    Var0(BitByteAddrVar0),
    Var1(BitByteAddrVar1),
    Var2(BitByteAddrVar2),
    Var3(BitByteAddrVar3),
    Var4(BitByteAddrVar4),
}
impl TableBitByteAddr {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = BitByteAddrVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = BitByteAddrVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = BitByteAddrVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = BitByteAddrVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = BitByteAddrVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:630:1, end:630:7))"]
#[derive(Clone, Debug)]
struct Addr11Var0 {
    aopaddr: TokenField_aopaddr,
    adata: TokenField_adata,
}
impl Addr11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_relAddr: i128 = 0;
        calc_relAddr = (i128::try_from(inst_next).unwrap() & 16775168i128)
            .wrapping_add(self.aopaddr.disassembly().wrapping_mul(256i128))
            .wrapping_add(self.adata.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_relAddr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_relAddr: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let aopaddr = token_parser.TokenFieldaopaddr();
        let adata = token_parser.TokenFieldadata();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { aopaddr, adata }))
    }
}
#[derive(Clone, Debug)]
enum TableAddr11 {
    Var0(Addr11Var0),
}
impl TableAddr11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Addr11Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:631:1, end:631:7))"]
#[derive(Clone, Debug)]
struct Addr16Var0 {
    addr16: TokenField_addr16,
}
impl Addr16Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_addr: i128 = 0;
        calc_addr = (i128::try_from(inst_next).unwrap() & 16711680i128)
            .wrapping_add(self.addr16.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_addr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_addr: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let addr16 = token_parser.TokenFieldaddr16();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr16 }))
    }
}
#[derive(Clone, Debug)]
enum TableAddr16 {
    Var0(Addr16Var0),
}
impl TableAddr16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Addr16Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:640:1, end:640:5))"]
#[derive(Clone, Debug)]
struct Rel8Var0 {
    rel8: TokenField_rel8,
}
impl Rel8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_relAddr: i128 = 0;
        calc_relAddr = i128::try_from(inst_next)
            .unwrap()
            .wrapping_add(self.rel8.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_relAddr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_relAddr: i128 = 0;
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let rel8 = token_parser.TokenFieldrel8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[derive(Clone, Debug)]
enum TableRel8 {
    Var0(Rel8Var0),
}
impl TableRel8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Rel8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:641:1, end:641:6))"]
#[derive(Clone, Debug)]
struct Rel16Var0 {
    rel16: TokenField_rel16,
}
impl Rel16Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_relAddr: i128 = 0;
        calc_relAddr = i128::try_from(inst_next)
            .unwrap()
            .wrapping_add(self.rel16.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_relAddr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_relAddr: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let rel16 = token_parser.TokenFieldrel16();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[derive(Clone, Debug)]
enum TableRel16 {
    Var0(Rel16Var0),
}
impl TableRel16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Rel16Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:95:1, end:95:7))"]
#[derive(Clone, Debug)]
struct AtWRjbVar0 {
    wrj47: TokenField_wrj47,
}
impl AtWRjbVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("@"), self.wrj47.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtWRjb {
    Var0(AtWRjbVar0),
}
impl TableAtWRjb {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            AtWRjbVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:96:1, end:96:7))"]
#[derive(Clone, Debug)]
struct AtWRjwVar0 {
    wrj47: TokenField_wrj47,
}
impl AtWRjwVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("@"), self.wrj47.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtWRjw {
    Var0(AtWRjwVar0),
}
impl TableAtWRjw {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            AtWRjwVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:99:1, end:99:7))"]
#[derive(Clone, Debug)]
struct AtDRkbVar0 {
    drk47: TokenField_drk47,
}
impl AtDRkbVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("@"), self.drk47.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let drk47 = token_parser.TokenFielddrk47();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk47 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtDRkb {
    Var0(AtDRkbVar0),
}
impl TableAtDRkb {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            AtDRkbVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:100:1, end:100:7))"]
#[derive(Clone, Debug)]
struct AtDRkwVar0 {
    drk47: TokenField_drk47,
}
impl AtDRkwVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("@"), self.drk47.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let drk47 = token_parser.TokenFielddrk47();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk47 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtDRkw {
    Var0(AtDRkwVar0),
}
impl TableAtDRkw {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            AtDRkwVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:101:1, end:101:7))"]
#[derive(Clone, Debug)]
struct AtDRktVar0 {
    drk47: TokenField_drk47,
}
impl AtDRktVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("@"), self.drk47.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let drk47 = token_parser.TokenFielddrk47();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk47 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtDRkt {
    Var0(AtDRktVar0),
}
impl TableAtDRkt {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            AtDRktVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:105:1, end:105:14))"]
#[derive(Clone, Debug)]
struct AtWRj47Dis16bVar0 {
    wrj47: TokenField_wrj47,
    data16: TokenField_data16,
}
impl AtWRj47Dis16bVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("@"),
            self.wrj47.display(),
            DisplayElement::Literal("+"),
            self.data16.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let data16 = token_parser.TokenFielddata16();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, data16 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtWRj47Dis16b {
    Var0(AtWRj47Dis16bVar0),
}
impl TableAtWRj47Dis16b {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = AtWRj47Dis16bVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:106:1, end:106:14))"]
#[derive(Clone, Debug)]
struct AtWRj47Dis16wVar0 {
    wrj47: TokenField_wrj47,
    data16: TokenField_data16,
}
impl AtWRj47Dis16wVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("@"),
            self.wrj47.display(),
            DisplayElement::Literal("+"),
            self.data16.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let wrj47 = token_parser.TokenFieldwrj47();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let data16 = token_parser.TokenFielddata16();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, data16 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtWRj47Dis16w {
    Var0(AtWRj47Dis16wVar0),
}
impl TableAtWRj47Dis16w {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = AtWRj47Dis16wVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:108:1, end:108:14))"]
#[derive(Clone, Debug)]
struct AtWRj03Dis16bVar0 {
    wrj03: TokenField_wrj03,
    data16: TokenField_data16,
}
impl AtWRj03Dis16bVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("@"),
            self.wrj03.display(),
            DisplayElement::Literal("+"),
            self.data16.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let wrj03 = token_parser.TokenFieldwrj03();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let data16 = token_parser.TokenFielddata16();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj03, data16 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtWRj03Dis16b {
    Var0(AtWRj03Dis16bVar0),
}
impl TableAtWRj03Dis16b {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = AtWRj03Dis16bVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:109:1, end:109:14))"]
#[derive(Clone, Debug)]
struct AtWRj03Dis16wVar0 {
    wrj03: TokenField_wrj03,
    data16: TokenField_data16,
}
impl AtWRj03Dis16wVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("@"),
            self.wrj03.display(),
            DisplayElement::Literal("+"),
            self.data16.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let wrj03 = token_parser.TokenFieldwrj03();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let data16 = token_parser.TokenFielddata16();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj03, data16 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtWRj03Dis16w {
    Var0(AtWRj03Dis16wVar0),
}
impl TableAtWRj03Dis16w {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = AtWRj03Dis16wVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:111:1, end:111:14))"]
#[derive(Clone, Debug)]
struct AtDRk47Dis24bVar0 {
    drk47: TokenField_drk47,
    data24: TokenField_data24,
}
impl AtDRk47Dis24bVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("@"),
            self.drk47.display(),
            DisplayElement::Literal("+"),
            self.data24.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let drk47 = token_parser.TokenFielddrk47();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 3u64 as u32;
        let token_parser = <TokenParser<3usize>>::new(tokens_current)?;
        let data24 = token_parser.TokenFielddata24();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk47, data24 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtDRk47Dis24b {
    Var0(AtDRk47Dis24bVar0),
}
impl TableAtDRk47Dis24b {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = AtDRk47Dis24bVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:112:1, end:112:14))"]
#[derive(Clone, Debug)]
struct AtDRk47Dis24wVar0 {
    drk47: TokenField_drk47,
    data24: TokenField_data24,
}
impl AtDRk47Dis24wVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("@"),
            self.drk47.display(),
            DisplayElement::Literal("+"),
            self.data24.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let drk47 = token_parser.TokenFielddrk47();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 3u64 as u32;
        let token_parser = <TokenParser<3usize>>::new(tokens_current)?;
        let data24 = token_parser.TokenFielddata24();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk47, data24 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtDRk47Dis24w {
    Var0(AtDRk47Dis24wVar0),
}
impl TableAtDRk47Dis24w {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = AtDRk47Dis24wVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:114:1, end:114:14))"]
#[derive(Clone, Debug)]
struct AtDRk03Dis24bVar0 {
    drk03: TokenField_drk03,
    data24: TokenField_data24,
}
impl AtDRk03Dis24bVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("@"),
            self.drk03.display(),
            DisplayElement::Literal("+"),
            self.data24.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let drk03 = token_parser.TokenFielddrk03();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 3u64 as u32;
        let token_parser = <TokenParser<3usize>>::new(tokens_current)?;
        let data24 = token_parser.TokenFielddata24();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk03, data24 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtDRk03Dis24b {
    Var0(AtDRk03Dis24bVar0),
}
impl TableAtDRk03Dis24b {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = AtDRk03Dis24bVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:115:1, end:115:14))"]
#[derive(Clone, Debug)]
struct AtDRk03Dis24wVar0 {
    drk03: TokenField_drk03,
    data24: TokenField_data24,
}
impl AtDRk03Dis24wVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("@"),
            self.drk03.display(),
            DisplayElement::Literal("+"),
            self.data24.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let drk03 = token_parser.TokenFielddrk03();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 3u64 as u32;
        let token_parser = <TokenParser<3usize>>::new(tokens_current)?;
        let data24 = token_parser.TokenFielddata24();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk03, data24 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtDRk03Dis24w {
    Var0(AtDRk03Dis24wVar0),
}
impl TableAtDRk03Dis24w {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = AtDRk03Dis24wVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:118:1, end:118:9))"]
#[derive(Clone, Debug)]
struct Direct8wVar0 {
    mainreg: TokenField_mainreg,
}
impl Direct8wVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.mainreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbank().disassembly() != 0i128 {
            return None;
        }
        let mainreg = token_parser.TokenFieldmainreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mainreg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:119:1, end:119:9))"]
#[derive(Clone, Debug)]
struct Direct8wVar1 {
    Direct: TableDirect,
}
impl Direct8wVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.Direct.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldbank().disassembly() != 1i128 {
            return None;
        }
        let Direct = if let Some((len, table)) = TableDirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct }))
    }
}
#[derive(Clone, Debug)]
enum TableDirect8w {
    Var0(Direct8wVar0),
    Var1(Direct8wVar1),
}
impl TableDirect8w {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Direct8wVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Direct8wVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:122:1, end:122:10))"]
#[derive(Clone, Debug)]
struct Direct16bVar0 {
    addr16: TokenField_addr16,
}
impl Direct16bVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.addr16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let addr16 = token_parser.TokenFieldaddr16();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr16 }))
    }
}
#[derive(Clone, Debug)]
enum TableDirect16b {
    Var0(Direct16bVar0),
}
impl TableDirect16b {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Direct16bVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:123:1, end:123:10))"]
#[derive(Clone, Debug)]
struct Direct16wVar0 {
    addr16: TokenField_addr16,
}
impl Direct16wVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.addr16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let addr16 = token_parser.TokenFieldaddr16();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr16 }))
    }
}
#[derive(Clone, Debug)]
enum TableDirect16w {
    Var0(Direct16wVar0),
}
impl TableDirect16w {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Direct16wVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:124:1, end:124:10))"]
#[derive(Clone, Debug)]
struct Direct16dVar0 {
    addr16: TokenField_addr16,
}
impl Direct16dVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.addr16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let addr16 = token_parser.TokenFieldaddr16();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr16 }))
    }
}
#[derive(Clone, Debug)]
enum TableDirect16d {
    Var0(Direct16dVar0),
}
impl TableDirect16d {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Direct16dVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:126:1, end:126:9))"]
#[derive(Clone, Debug)]
struct Data16x0Var0 {
    data16: TokenField_data16,
}
impl Data16x0Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.data16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let data16 = token_parser.TokenFielddata16();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { data16 }))
    }
}
#[derive(Clone, Debug)]
enum TableData16x0 {
    Var0(Data16x0Var0),
}
impl TableData16x0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Data16x0Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:127:1, end:127:9))"]
#[derive(Clone, Debug)]
struct Data16x1Var0 {
    data16: TokenField_data16,
}
impl Data16x1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_val: i128 = 0;
        calc_val = 4294901760i128.wrapping_add(self.data16.disassembly());
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("#"),
            DisplayElement::Number(true, calc_val),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        calc_val = 4294901760i128
            .wrapping_add(token_parser.TokenFielddata16().disassembly());
        let data16 = token_parser.TokenFielddata16();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { data16 }))
    }
}
#[derive(Clone, Debug)]
enum TableData16x1 {
    Var0(Data16x1Var0),
}
impl TableData16x1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Data16x1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:129:1, end:129:7))"]
#[derive(Clone, Debug)]
struct Addr24Var0 {
    addr24: TokenField_addr24,
}
impl Addr24Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.addr24.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 3u64 as u32;
        let token_parser = <TokenParser<3usize>>::new(tokens_current)?;
        let addr24 = token_parser.TokenFieldaddr24();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr24 }))
    }
}
#[derive(Clone, Debug)]
enum TableAddr24 {
    Var0(Addr24Var0),
}
impl TableAddr24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Addr24Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:132:1, end:132:6))"]
#[derive(Clone, Debug)]
struct ShortVar0 {
    short01: TokenField_short01,
}
impl ShortVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.short01.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let short01 = token_parser.TokenFieldshort01();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { short01 }))
    }
}
#[derive(Clone, Debug)]
enum TableShort {
    Var0(ShortVar0),
}
impl TableShort {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ShortVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:137:1, end:137:13))"]
#[derive(Clone, Debug)]
struct xBitByteAddrVar0 {}
impl xBitByteAddrVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let bitaddr8 = token_parser.TokenFieldbitaddr8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablexBitByteAddr {
    Var0(xBitByteAddrVar0),
}
impl TablexBitByteAddr {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = xBitByteAddrVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:139:1, end:139:9))"]
#[derive(Clone, Debug)]
struct xBitAddrVar0 {
    bit02: TokenField_bit02,
    bitaddr8: TokenField_bitaddr8,
}
impl xBitAddrVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_bitaddr: i128 = 0;
        calc_bitaddr = u32::try_from(3i128)
            .ok()
            .map(|shl| self.bitaddr8.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            .wrapping_add(self.bit02.disassembly());
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Number(true, calc_bitaddr),
            DisplayElement::Literal("."),
            self.bit02.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_bitaddr: i128 = 0;
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let bit02 = token_parser.TokenFieldbit02();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        calc_bitaddr = u32::try_from(3i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldbitaddr8()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            .wrapping_add(token_parser.TokenFieldbit02().disassembly());
        let bitaddr8 = token_parser.TokenFieldbitaddr8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { bit02, bitaddr8 }))
    }
}
#[derive(Clone, Debug)]
enum TablexBitAddr {
    Var0(xBitAddrVar0),
}
impl TablexBitAddr {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            xBitAddrVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:140:1, end:140:10))"]
#[derive(Clone, Debug)]
struct xBitAddr2Var0 {
    bit02: TokenField_bit02,
    bitaddr8: TokenField_bitaddr8,
}
impl xBitAddr2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_bitaddr: i128 = 0;
        calc_bitaddr = u32::try_from(3i128)
            .ok()
            .map(|shl| self.bitaddr8.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            .wrapping_add(self.bit02.disassembly());
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("/"),
            DisplayElement::Number(true, calc_bitaddr),
            DisplayElement::Literal("."),
            self.bit02.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_bitaddr: i128 = 0;
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let bit02 = token_parser.TokenFieldbit02();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        calc_bitaddr = u32::try_from(3i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldbitaddr8()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            .wrapping_add(token_parser.TokenFieldbit02().disassembly());
        let bitaddr8 = token_parser.TokenFieldbitaddr8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { bit02, bitaddr8 }))
    }
}
#[derive(Clone, Debug)]
enum TablexBitAddr2 {
    Var0(xBitAddr2Var0),
}
impl TablexBitAddr2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            xBitAddr2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
pub fn parse_instruction<T>(
    tokens: &[u8],
    context: &mut T,
    inst_start: u32,
    global_set: &mut impl GlobalSetTrait,
) -> Option<(u32, Vec<DisplayElement>)>
where
    T: ContextTrait + Clone,
{
    let (inst_len, instruction) =
        Tableinstruction::parse(tokens, context, inst_start)?;
    let inst_next = inst_start + inst_len;
    let mut display = vec![];
    instruction.display_extend(
        &mut display,
        context,
        inst_start,
        inst_next,
        global_set,
    );
    Some((inst_next, display))
}
